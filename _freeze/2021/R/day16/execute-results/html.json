{
  "hash": "14aa0c2a5a4d02f96163484db9ab12d5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 16\"\ndate: 2021-12-16\nauthor:\n  name: https://adventofcode.com/2021/day/16\n  url: https://adventofcode.com/2021/day/16\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\nRead input from file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(file = \"../input/day16.txt\")\n```\n:::\n\n\n\n\n## Part 1\n\nConvert hex input to a binary string:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbin <- input |> \n  str_split_1(\"\") |> \n  strtoi(base = 16L) |> \n  map_chr(\n    ~ .x |> \n      intToBits() |> \n      as.integer() |>       \n      rev() |> \n      tail(4) |> \n      str_flatten()\n  ) |> \n  str_flatten()\n```\n:::\n\n\n\n\nDefine a helper function to parse binary strings larger than 32 bits (which can't be handled by the built-in `strtoi` function):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstrtodbl <- function(str) {\n  str |> \n    str_split_1(\"\") |> \n    rev() |> \n    as.integer() |> \n    imap_dbl(\\(x, idx) if_else(x == 1, 2^(idx - 1), 0)) |> \n    sum()\n}\n```\n:::\n\n\n\n\nDefine a function to convert a binary string into an integer following the designated decoding pattern, where values are grouped into sets of 5 bits:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_literal <- function(bin) {\n  str <- str_extract(bin, \"^(1....)*(0....)\")\n  bin <- str_replace_all(str, \"(.(....))\", \"\\\\2\")\n  val <- strtoi(bin, base = 2)\n  \n  # strtoi can only handle 32 bit integers. Use helper func for larger cases\n  if (is.na(val)) {\n    val <- strtodbl(bin)\n  }\n  \n  lst(value = val, nbits = str_length(str))\n}\n```\n:::\n\n\n\n\nDefine a function to read the header info from a packet and delagate the rest of the packet to the correct function to parse:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_packet <- function(bin) {\n  \n  # Return early if the end is an artifact of decimal representation\n  if (str_length(bin) < 4 | str_detect(bin, \"^0+$\")) \n    return(lst(ver = NULL, type = NULL, nbits = str_length(bin), value = NULL))\n  \n  # Read in packet header/metadata\n  ver  <- str_sub(bin, start = 1L, end =  3L) |> strtoi(base = 2)\n  type <- str_sub(bin, start = 4L, end =  6L) |> strtoi(base = 2)\n  bin  <- str_sub(bin, start = 7L, end = -1L)\n  \n  # Choose the correct function to read in the packet based on type ID\n  fn <- get(case_match(type, 4 ~ \"read_literal\", .default = \"read_subpackets\"))\n  output <- fn(bin)\n  \n  lst(ver = ver, type = type, nbits = output$nbits + 6L, value = output$value)\n}\n```\n:::\n\n\n\n\nDefine a function to read and merge sub-packets from within an operator packet:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_subpackets <- function(bin) {\n  \n  # Determine whether the length is in terms of bits or # of subpackets\n  type <- str_sub(bin, end = 1L) |> as.integer()\n  \n  # Pull length value as an integer and assign the max packet number if applcbl\n  bits <- case_match(type, 0 ~ 15L, 1 ~ 11L)\n  len  <- str_sub(bin, start = 2L, end = bits + 1L) |> strtoi(base = 2)\n  nmax <- case_match(type, 0 ~ Inf, 1 ~ len)\n  \n  # Trim the binary str to begin after the header and end at designated length\n  bin <- str_sub(\n    bin, \n    start = bits + 2L,\n    end = case_match(type, 0 ~ bits + 1L + len, 1 ~ -1L)\n  )\n\n  # Initialize the loop\n  packets <- list()\n  nbits   <- bits + 1L\n  \n  # Parse subpackets until the end of the binary value or max count is reached\n  while (str_length(bin) > 0 & length(packets) < nmax) {\n    output  <- read_packet(bin)\n    nbits   <- nbits + output$nbits\n    packets <- c(packets, list(output))\n    bin     <- str_sub(bin, start = output$nbits + 1L)\n  }\n  \n  return(lst(nbits = nbits, value = packets))\n}\n```\n:::\n\n\n\n\nParse puzzle input into a set of nested packets of integers:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparsed <- read_packet(bin)\n```\n:::\n\n\n\n\nSum the version numbers from each packet:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparsed |>\n  unlist() |>\n  keep_at(~ str_detect(.x, \"ver\")) |>\n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 974\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nType IDs (other than 4) now represent operations. Map these IDs to their operation:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nop_lst   <- c(\"+\", \"*\", \"min\", \"max\", \"I\", \">\", \"<\", \"==\")\nid_to_op <- \\(id) get(op_lst[id + 1])\n```\n:::\n\n\n\n\nDefine a function that parses the nested packet structure and calculates the appropriate output:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalc_packet <- function(packet) {\n  if (packet$type == 4) return(packet$value)\n  \n  packet$value |> \n    map_dbl(calc_packet) |> \n    reduce(id_to_op(packet$type)) |> \n    as.numeric()\n}\n```\n:::\n\n\n\n\nCalculate the output:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalc_packet(parsed)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 180616437720\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}