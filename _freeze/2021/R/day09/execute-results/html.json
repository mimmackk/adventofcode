{
  "hash": "08fa7165faa9a1b66dc1e2adc553b3ec",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 9\"\ndate: 2021-12-09\nauthor:\n  name: https://adventofcode.com/2021/day/9\n  url: https://adventofcode.com/2021/day/9\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(igraph)\n```\n:::\n\n\n\n\nRead input from file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- scan(file = \"../input/day09.txt\", what = character(), quiet = TRUE)\n```\n:::\n\n\n\n\nConvert input from plaintext to an integer matrix:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtx <- input |> \n  str_split(\"\") |> \n  list_c() |> \n  as.integer() |> \n  matrix(nrow = length(input), byrow = TRUE)\n```\n:::\n\n\n\n\n## Part 1\n\nCreate shifted versions of our matrix to get the values above, below, to the left, and to the right of any given cell:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtx_above <- lag(mtx)\nmtx_below <- lead(mtx)\nmtx_left  <- t(lag(t(mtx)))\nmtx_right <- t(lead(t(mtx)))\n```\n:::\n\n\n\n\nFind all low points:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlow <- (\n  mtx < mtx_above & \n  mtx < mtx_below & \n  mtx < mtx_left  & \n  mtx < mtx_right\n)\n\nlow[is.na(low)] <- TRUE\n```\n:::\n\n\n\n\nCompute the risk level of each low point:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(mtx[low] + 1)\n```\n:::\n\n\n\n\n## Part 2\n\nFor each applicable point on the map, determine its smallest surrounding coordinate(s) where smoke will flow:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneighbors <- pmap(\n  list(mtx, mtx_left, mtx_right, mtx_above, mtx_below),\n  \\(i, l, r, u, d) {\n    dirs <- c(\"I\" = i, \"L\" = l, \"R\" = r, \"U\" = u, \"D\" = d)\n    flow <- dirs[dirs == min(dirs, na.rm = TRUE)] |> \n      discard(is.na) |> \n      discard_at(\"I\") |> \n      names()\n    if (i != 9) flow else character(0)\n  }\n) |> \n  enframe(name = \"loc_id\", value = \"neighbor\") |> \n  unnest_longer(neighbor) |> \n  mutate(\n    neighbor = case_match(neighbor,\n      \"U\" ~ loc_id - 1,\n      \"D\" ~ loc_id + 1,\n      \"L\" ~ loc_id - nrow(mtx),\n      \"R\" ~ loc_id + nrow(mtx)\n    )\n  )\n```\n:::\n\n\n\n\nConvert list of neighbors to a graph:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- neighbors |> \n  pmap(~ c(..1, ..2)) |> \n  list_c() |> \n  make_graph()\n```\n:::\n\n\n\n\nFor each low point, compute the size of its basin from its graph neighborhood:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbasin_ids  <- components(g)$membership[which(low)]\nbasin_size <- components(g)$csize[basin_ids]\n```\n:::\n\n\n\n\nMultiply together the sizes of the three largest basins:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbasin_size |> \n  sort(decreasing = TRUE) |> \n  head(3) |> \n  prod()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}