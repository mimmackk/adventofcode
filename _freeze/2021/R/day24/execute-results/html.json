{
  "hash": "bce1d61ebe98cda490c053fbda2cd467",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 24\"\ndate: 2021-12-24\nauthor:\n  name: https://adventofcode.com/2021/day/24\n  url: https://adventofcode.com/2021/day/24\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(unglue)\n```\n:::\n\n\n\n\nRead and parse text input from file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day24.txt\") |> \n  unglue_data(patterns = c(\"{f=...} {a=.}\", \"{f} {a=.} {b}\"))\n```\n:::\n\n\n\n\n## Part 1\n\nBy visual inspection, the instructions are all minor variations on the same repeated set of instructions. Block 1 is interpreted below:\n\n| Instruction | Description                     | Output Value |\n|-------------|---------------------------------|--------------|\n| inp w       | Read a new digit into w         | w = {1:9}    |\n| mul x 0     | Zero out x                      | x = 0        |\n| add x z     | Set x equal to z                | x = 0        |\n| mod x 26    | Modulo x by 26 (0)              | x = 0        |\n| div z 1     | Divide z by 1 (no effect)       | z = 0        |\n| add x 14    | Add 14 to x (14)                | x = 14       |\n| eql x w     | Check if x equals w             | x = 0        |\n| eql x 0     | Check if above is true          | x = 1        |\n| mul y 0     | Zero out y                      | y = 0        |\n| add y 25    | Set y to 25                     | y = 25       |\n| mul y x     | Multiply y by x (either 1 or 0) | y = 25       |\n| add y 1     | Add 1 to y                      | y = 26       |\n| mul z y     | Multiply z by y                 | z = 0        |\n| mul y 0     | Zero out y                      | y = 0        |\n| add y w     | Set y to w                      | y = w        |\n| add y 12    | Add 12 to y                     | y = w + 12   |\n| mul y x     | Multiply y by x (either 1 or 0) | y = w + 12   |\n| add z y     | Add y to z                      | z = w + 12   |\n\nIf we represent the set of 3 integers that vary from block to block as \"c1\\[i\\]\", \"c2\\[i\\]\", and \"c3\\[i\\]\", with i indicating the block number ranging from 1:14, this series of instructions is equivalent to the following code:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example 14-digit number\nw <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4)  \nz <- 0\n\nfor (i in 1:length(w)) {\n  if (z %% 26 + c2[i] == w[i]) \n    z <- floor(z / c1[i]) \n  else \n    z <- floor(z / c1[i]) * 26 + w[i] + c3[i]\n}\n```\n:::\n\n\n\n\nExtract the c1, c2, and c3 values from the input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconst <- input |> \n  mutate(grp = cumsum(f == \"inp\")) |> \n  mutate(row = row_number(), .by = grp) |> \n  summarize(b = list(b), .by = row) |> \n  pull(b) |> \n  keep_at(c(5, 6, 16)) |> \n  map(parse_number)\n\nc1 <- const[[1]]\nc2 <- const[[2]]\nc3 <- const[[3]]\n```\n:::\n\n\n\n\nBelow, we define the set of code blocks as a recursive function to loop through possible input values and find one that ends on zero.\n\nTo improve performance, we prune branches early on if they can never reach zero in the remaining rounds:\n  - Each round, the best-case scenario for a large z to shrink toward zero is for the if-else statement to be true, which would result in z becoming floor(z / c1\\[i\\]).\n  - If z is greater than or equal to the product of the remaining c1 values, it can't be reduced to zero by the last round.\n  - Example: as a test case, imagine that c1 = 2 in every round.\n      - When there's 1 round remaining, the final output is 0 if the input z is no greater than 0 or 1.\n      - When there's 2 rounds remaining, the round's output can be 0/1 if the input z is no greater than 0/1/2/3.\n      - When there's 3 rounds remaining, the round's output can be 0/1/2/3 if the input z is no greater than 0/1/2/3/4/5/6/7, i.e., if the input z < 2^3.\n  - Generalizing, in the 14th round, the input z must be less than c1\\[14\\]. In the 13th round, the input z must be less than c1\\[14\\] \\* c1\\[13\\], etc.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzmax <- accumulate(c1, prod, .dir = \"backward\")\n```\n:::\n\n\n\n\nDefine our recursive search funtion as described above:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(z = 0, vec = c(), i = 1, digits) {\n  \n  # Check if the last round has been reached. Return success if z is 0.\n  if (i == 15) {\n    if (z == 0) \n      return(vec) \n    else \n      return()\n  }\n  \n  # Abort early if z is too large and can never reach 0 by the end\n  if (z >= zmax[i])\n    return()\n  \n  # Loop through possible input values (in increasing or decreasing order)\n  for (w in digits) {\n    if (z %% 26 + c2[i] == w)\n      result <- f(floor(z / c1[i]), c(vec, w), i + 1, digits)\n    else \n      result <- f(floor(z / c1[i]) * 26 + w + c3[i], c(vec, w), i + 1, digits)\n    \n    if (!is.null(result))\n      return(result)\n  }\n}\n```\n:::\n\n\n\n\nSearch in order from highest to lowest input values:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(f(digits = 9:1), sep = \"\")\n```\n:::\n\n\n\n\n## Part 2\n\nReverse the search vector from 9:1 to 1:9 to search from lowest to highest values, and re-run:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(f(digits = 1:9), sep = \"\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}