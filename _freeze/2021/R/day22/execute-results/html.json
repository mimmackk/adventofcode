{
  "hash": "89452660af51bf43e2d731e0f41a6ab2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 22\"\ndate: 2021-12-22\nauthor:\n  name: https://adventofcode.com/2021/day/22\n  url: https://adventofcode.com/2021/day/22\n---\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sets)\n```\n:::\n\n\n\nDisable scientific formatting when displaying large numbers:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(scipen = 999)\n```\n:::\n\n\n\nRead and parse text input from file:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day22.txt\") |> \n  unglue_data(\n    \"{state} x={xmin}..{xmax},y={ymin}..{ymax},z={zmin}..{zmax}\",\n    convert = TRUE\n  ) |> \n  mutate(\n    id = row_number(), \n    state = case_match(state, \"on\" ~ 1, \"off\" ~ 0), \n    .before = everything()\n  )\n```\n:::\n\n\n\n## Part 1\n\nThis part of the problem has a small enough total area that it runs with a simple approach.\n\nInitialize the cuboid to a 101x101x101 array (representing x/z/y values from -50 to 50) where all values are \"off\" (zero):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncuboid <- array(rep(0, 101^3), c(101, 101, 101))\n```\n:::\n\n\n\nDefine a function to modify a cuboid at the given coordinates:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodify_cuboid <- function(cuboid, x, y, z, state) {\n  cuboid[x, y, z] <- state\n  cuboid\n}\n```\n:::\n\n\n\nFor each step in the input, turn the designated cubes on/off:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput |> \n  \n  # Bound the input indices between -50 and 50, then translate to R indices\n  mutate(\n    across(ends_with(\"min\"), ~ pmax(.x, -50)),\n    across(ends_with(\"max\"), ~ pmin(.x,  50)),\n    across(ends_with(c(\"min\", \"max\")), ~ .x + 51)\n  ) |> \n  \n  # Remove any out-of-bounds indices\n  filter((xmin <= xmax) & (ymin <= ymax) & (zmin <= zmax)) |> \n  \n  # Apply steps to the cuboid\n  pmap(\\(id, state, xmin, xmax, ymin, ymax, zmin, zmax) {\n    list(state = state, x = xmin:xmax, y = ymin:ymax, z = zmin:zmax)\n  }) |> \n  reduce(\n    .f = ~ do.call(what = modify_cuboid, args = c(.y, cuboid = list(.x))),\n    .init = cuboid\n  ) |> \n  sum()\n```\n:::\n\n\n\n## Part 2\n\nThe full region of interest is now too large. We now use set intervals to store our cuboids rather than storing each voxel individually.\n\nNudge from the Reddit daily megathread: rather than storing the state of the full cuboid at each step, compute the change in volume at each step instead, and work in reverse order.\n\nWith this approach, every new 'on' step in reverse order adds the total volume of any 'on' cuboid, minus any intersection with any 'off' or 'on' cuboid later in the step sequence. When an 'off' cuboid is encountered, it can be ignored.\n\nDefine a helper function to subtract one cuboid from another, breaking down to up to six non-overlapping sub-cuboids if necessary:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncuboid_difference <- function(a, b) {\n  diff <- map2(a, b, ~ as.list(interval_complement(.y, .x)))\n  intr <- map2(a, b, interval_intersection)\n  c(\n    map(diff$z, \\(z) lst(x = a$x, y = a$y,    z = z)),\n    map(diff$y, \\(y) lst(x = a$x, y = y,      z = intr$z)),\n    map(diff$x, \\(x) lst(x = x,   y = intr$y, z = intr$z))\n  )\n}\n```\n:::\n\n\n\nDefine a helper function to compute the volume of a cuboid: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncuboid_size <- function(cuboid) {\n  if (any(map_lgl(cuboid, interval_is_empty)))\n    return(0)\n  cuboid |> \n    map_dbl(~ max(.x) - min(.x) + 1) |> \n    prod()\n}\n```\n:::\n\n\n\nConver the input cuboids into a set of integer intervals for each step:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsteps <- input |> \n  mutate(\n    x = map2(xmin, xmax, integers),\n    y = map2(ymin, ymax, integers),\n    z = map2(zmin, zmax, integers),\n    cuboid = pmap(lst(x, y, z), lst)\n  ) |>\n  select(id, state, cuboid)\n```\n:::\n\n\n\nFor each 'on' cuboid, compute the regions of intersection with any later-step cuboid:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_rm <- inner_join(steps, steps, join_by(x$id < y$id)) |>\n  filter(state.x == 1) |> \n  mutate(\n    overlap = map2(cuboid.x, cuboid.y, ~ map2(.x, .y, interval_intersection)),\n    empty = map_lgl(overlap, \\(cuboid) any(map_lgl(cuboid, interval_is_empty))),\n    id = id.x\n  ) |> \n  filter(!empty) |> \n  summarize(overlap = list(overlap), .by = id)\n```\n:::\n\n\n\nRemove the overlapping regions from the step's original cuboid:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- steps |> \n  inner_join(to_rm, join_by(id)) |> \n  mutate(\n    new = map2(cuboid, overlap, \\(base, intr) {\n      reduce(intr, .init = list(base), \\(acc, nxt) {\n        list_flatten(map(acc, ~ cuboid_difference(.x, nxt)))\n      })\n    })\n  )\n```\n:::\n\n\n\nCompute the volume of each final 'on' cuboid, and sum to get the final result:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsteps |> \n  filter(state == 1) |> \n  left_join(select(res, id, new), join_by(id)) |> \n  mutate(\n    uniq = map2(new, cuboid, ~ if (is.null(.x)) list(.y) else .x),\n    size = map_dbl(uniq, \\(cuboid_set) sum(map_dbl(cuboid_set, cuboid_size)))\n  ) |> \n  pull(size) |> \n  sum()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}