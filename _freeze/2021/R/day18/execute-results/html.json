{
  "hash": "34093fde39a97b00dbdb33636cc7530a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 18\"\ndate: 2021-12-18\nauthor:\n  name: https://adventofcode.com/2021/day/18\n  url: https://adventofcode.com/2021/day/18\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\nRead input from file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(file = \"../input/day18.txt\")\n```\n:::\n\n\n\n\nConvert JSON-like input to \"snailfish number\" format: a flat, named vector whose names give the depth of the nesting:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnested_to_sn <- function(nested, depth = 0) {\n  if (is.integer(nested))\n    set_names(nested, depth)\n  else\n    map(nested, \\(lst) nested_to_sn(lst, depth + 1)) |> \n      list_c()\n}\n\nsn <- input |> \n  map(~ jsonlite::fromJSON(.x, simplifyVector = FALSE)) |> \n  map(nested_to_sn)\n```\n:::\n\n\n\n\n\n## Part 1\n\nDefine a function to explode the first applicable pair in a snailfish number:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexplode_sn <- function(x) {\n  \n  idx <- which((names(x) == lead(names(x))) & names(x) > 4) |> head(1)\n  \n  # Return as-is if there are no numbers to explode\n  if (length(idx) == 0) return(x)\n  \n  # Add the values of the exploding pair outward to the left and right\n  1:length(x) |> \n    case_match(\n      idx - 1 ~ x + lead(x),\n      idx + 2 ~ x + lag(x),\n      .default = x\n    ) |> \n    \n    # Replace the exploded pair with 0 and reduce its depth\n    discard_at(idx) |> \n    modify_at(idx, ~ 0) |> \n    set_names(\\(nm) {\n      case_match(\n        1:length(nm), \n        idx ~ as.character(as.numeric(nm) - 1), \n        .default = nm\n      )\n    })\n}\n```\n:::\n\n\n\n\nDefine a function to split the first applicable pair in a snailfish number:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsplit_sn <- function(x) {\n  idx <- detect_index(x, ~ .x >= 10)\n  val <- keep_at(x, idx)\n\n  # Return as-is if there are no numbers to split\n  if (idx == 0) return(x)\n  \n  # Convert the value to a new pair at 1 level greater depth\n  pair <- c(floor(val / 2), ceiling(val / 2)) |> \n    set_names(\\(nm) as.character(as.numeric(nm) + 1))\n  \n  # Replace the old value with the new pair\n  c(head(x, idx - 1), pair, tail(x, -idx))\n}\n```\n:::\n\n\n\n\nDefine a function to reduce a snailfish number by iteravely exploding and splitting its contents:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreduce_sn <- function(x) {\n  prv <- x\n\n  repeat {\n    x <- explode_sn(x)\n    if (identical(x, prv)) {\n      x <- split_sn(x)\n      if (identical(x, prv)) return(x)\n    }\n    prv <- x\n  }\n}\n```\n:::\n\n\n\n\nDefine a function that adds two snailfish numbers by combining them as a new pair and then reducing them:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_sn <- \\(x, y) {\n  c(x, y) |> \n    set_names(\\(nm) as.character(as.numeric(nm) + 1)) |> \n    reduce_sn()\n}\n```\n:::\n\n\n\n\nDefine a function to compute the magnitude of a snailfish number:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmagnitude <- function(x) {\n  \n  # Iteratively replace the deepest pair with its magnitude\n  while (length(x) > 1) {\n    idx <- which(as.numeric(names(x)) == max(as.numeric(names(x)))) |> head(1)\n    mag <- (x[idx] * 3 + x[idx + 1] * 2) |> \n      set_names(\\(nm) as.character(as.numeric(nm) - 1))\n    x <- c(head(x, idx - 1), mag, tail(x, -(idx + 1)))\n  }\n  \n  unname(x)\n}\n```\n:::\n\n\n\n\nAdd together all numbers from the input in order:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfinal_sn <- reduce(sn, add_sn)\n```\n:::\n\n\n\n\nCompute the magnitude of the result:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmagnitude(final_sn)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4480\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nProduce all pairs of values from the input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- sn |>\n  as_tibble_col(column_name = \"sn1\") |>\n  mutate(id1 = row_number())\n\npairs <- df |>\n  cross_join(rename(df, sn2 = sn1, id2 = id1)) |>\n  filter(id2 != id1)\n```\n:::\n\n\n\n\nCompute the maximum magnitude across all summed pairs:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npairs |>\n  pmap_dbl(\\(sn1, sn2, ...) magnitude(add_sn(sn1, sn2))) |>\n  max()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4676\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}