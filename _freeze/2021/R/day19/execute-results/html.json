{
  "hash": "ecb4108ede671913408c621321422b27",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 19\"\ndate: 2021-12-19\nauthor:\n  name: https://adventofcode.com/2021/day/19\n  url: https://adventofcode.com/2021/day/19\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(unglue)\n```\n:::\n\n\n\n\nRead input from file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day19.txt\")\n```\n:::\n\n\n\n\nConvert plaintext input into sets of numeric coordinates by scanner:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- input |> \n  unglue_data(\n    patterns = c(\"--- scanner {scanner} ---\", \"{x},{y},{z}\"),\n    convert = TRUE\n  ) |> \n  mutate(across(c(x, y, z), as.numeric)) |> \n  fill(scanner, .direction = \"down\") |> \n  drop_na() |> \n  mutate(id = row_number(), .before = everything())\n```\n:::\n\n\n\n\n## Part 1\n\nDefine the set of all rotation matrices around the x/y/z axes in 90 degree increments:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxrot <- \\(x) matrix(c(1, 0, 0, 0, cos(x), sin(x), 0, -sin(x), cos(x)), nrow = 3)\nyrot <- \\(x) matrix(c(cos(x), 0, -sin(x), 0, 1, 0, sin(x), 0, cos(x)), nrow = 3)\nzrot <- \\(x) matrix(c(cos(x), sin(x), 0, -sin(x), cos(x), 0, 0, 0, 1), nrow = 3)\n```\n:::\n\n\n\n\nConvert each combination of unique x/y/z rotations (e.g., 90 degrees around the x axis then 180 degrees around the z axis) into a single rotation matrix:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrot <- lst(x = xrot, y = yrot, z = zrot) |> \n  map(\\(f) map(0:3, ~ round(f(.x * pi / 2)))) |> \n  do.call(what = expand_grid) |> \n  pmap(~ ..1 %*% ..2 %*% ..3) |> \n  unique()\n```\n:::\n\n\n\n\nConvert x/y/z coordinate sets from the input into a matrix of coordinate values for each scanner:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtx <- df |>\n  select(scanner, x, y, z) |> \n  nest(beacons = c(x, y, z)) |> \n  mutate(beacons = map(beacons, ~ t(as.matrix(.x))))\n```\n:::\n\n\n\n\nDetermine which scanners have overlapping beacons and define matrix transformations to translate points between various scanner coordinates: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntranslation <- mtx |> \n  \n  # Create pairwise combinations of all scanners\n  cross_join(mtx, suffix = c(\".src\", \".out\")) |> \n  filter(scanner.src != scanner.out) |> \n  \n  # Apply all possible sets of rotations to the source beacons\n  expand_grid(rotate = rot) |> \n  \n  # Find a translation for each pair of scanners that aligns at least 12 beacons\n  mutate(\n    beacons.src = map2(rotate, beacons.src, \\(A, x) A %*% x),\n    shift = map2(beacons.src, beacons.out, \\(src, out) {\n      expand_grid(src = split(src, col(src)), out = split(out, col(out))) |> \n        mutate(shift = map2(src, out, \\(src, out) out - src)) |> \n        mutate(n = n(), .by = shift) |> \n        slice_max(n)\n    }),\n    n = map_int(shift, ~ max(.x$n)),\n  ) |> \n  filter(n >= 12) |> \n  \n  # Convert rotation and translation to a single function that transforms a vec \n  mutate(\n    shift = list_flatten(map(shift, ~ unique(.x$shift))),\n    shift = map(shift, ~ diag(4) + cbind(matrix(0, 4, 3), c(.x, 0))),\n    f = map2(rotate, shift, \\(A, S) function(x) {\n      head(S %*% rbind(A %*% x, matrix(1, 1, ncol(x))), -1)\n    })\n  ) |> \n  select(scanner.src, scanner.out, f)\n```\n:::\n\n\n\n\nDefine a function that re-orients a scanner's beacons into the coordinate system of the zero scanner:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreorient <- function(vecs, path) {\n  if (tail(path, 1) == 0)\n    return(vecs)\n  \n  translation |> \n    filter(scanner.src == tail(path, 1) & !(scanner.out %in% path)) |> \n    pmap(\\(scanner.out, f, ...) reorient(f(vecs), c(path, scanner.out))) |> \n    compact() |> \n    pluck(1)\n}\n```\n:::\n\n\n\n\nFor each scanner in the input, convert all coordinates to the zero-scanner system and count the unique resulting beacons:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap2(mtx$beacons, mtx$scanner, reorient) |> \n  map(~split(.x, col(.x))) |> \n  list_flatten() |> \n  unique() |> \n  length()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 394\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nConvert each scanner's coordinates, which are each centered at (0, 0, 0) in their own coordinate system, to the zero-scanner's system:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscanners <- map(mtx$scanner, ~ reorient(matrix(0, 3, 1), .x))\n```\n:::\n\n\n\n\nCompute the greatest manhattan distance between any two pairs of scanners:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpand_grid(x = scanners, y = scanners) |> \n  mutate(dist = map2_dbl(x, y, ~ sum(abs(.x - .y)))) |> \n  pull(dist) |> \n  max()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12304\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}