{
  "hash": "a570a4703a9dd81800de431ffabfc3f8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 08\"\ndate: 2021-12-08\nauthor:\n  name: https://adventofcode.com/2021/day/08\n  url: https://adventofcode.com/2021/day/08\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\nRead input from file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_delim(\n  file = \"../input/day08.txt\", \n  delim = \" | \",\n  col_names = c(\"signal\", \"output\"),\n  show_col_types = FALSE\n) |> \n  mutate(across(everything(), ~ str_split(.x, \" \")))\n```\n:::\n\n\n\n\n## Part 1\n\nCount the total number of digits 1, 4, 7, and 8 in each output by counting the number of output values with length 2, 3, 4, or 7:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput |> \n  pull(output) |> \n  list_c() |> \n  str_length() |> \n  keep(~ .x %in% c(2, 3, 4, 7)) |> \n  length()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 245\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nBy visual examination, we have the following rules:\n\n-   Digits 1, 4, 7, and 8 are identifiable by length alone.\n-   Digits 0, 6, 9 all have the same length:\n    -   9 is the only superset of 4\n    -   Once 9 is identified, 0 is the only remaining superset of 1\n    -   6 is the last remaining value.\n-   Digits 2, 3, 5 all have the same length.\n    -   3 is the only superset of 1\n    -   5 is the only subset of 6\n    -   2 is the remainder\n\nUsing these rules, we can quickly identify which signals correspond to which digits. First, we define a helper function needed to fill null values in a single-value list:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlst_fill <- function(x) {\n  x |> \n    discard(is.null) |> \n    unique() |> \n    rep(length(x))\n}\n```\n:::\n\n\n\n\nNext, prepare our input by splitting and sorting the characters in each code:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- input |> \n  mutate(entry_id = row_number()) |> \n  pivot_longer(c(signal, output), names_to = \"type\", values_to = \"code\") |> \n  unnest_longer(code) |> \n  mutate(\n    code = map(code, ~ sort(str_split_1(.x, \"\"))),\n    length = map_int(code, length)\n  )\n```\n:::\n\n\n\n\nIdentify the digit corresponding to each code:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- df |> \n  mutate(\n    \n    # Identify digits 1, 4, 7, 8 by length only\n    digit = case_match(length, 2 ~ 1, 4 ~ 4, 3 ~ 7, 7 ~ 8),\n    \n    # Identify digits 0, 6, 9 by whether they have 1/4 as a subset\n    four = lst_fill(case_when(digit == 4 ~ code)),\n    one  = lst_fill(case_when(digit == 1 ~ code)),\n    digit = case_when(\n      length == 6 & map2_lgl(code, four, ~ all(.y %in% .x)) ~ 9,\n      length == 6 & map2_lgl(code, one,  ~ all(.y %in% .x)) ~ 0,\n      length == 6 ~ 6,\n      .default = digit\n    ),\n    \n    # Identify digits 2, 3, 5 by whether they have 1/6 as a subset/superset\n    six = lst_fill(case_when(digit == 6 ~ code)),\n    digit = case_when(\n      length == 5 & map2_lgl(code, one, ~ all(.y %in% .x)) ~ 3,\n      length == 5 & map2_lgl(code, six, ~ all(.x %in% .y)) ~ 5,\n      length == 5 ~ 2,\n      .default = digit\n    ),\n    \n    .by = entry_id\n  ) |> \n  select(entry_id, type, digit, code)\n```\n:::\n\n\n\n\nDetermine the output value for each entry and take the sum for the final result:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult |> \n  filter(type == \"output\") |> \n  summarize(\n    value = parse_number(str_c(digit, collapse = \"\")), \n    .by = entry_id\n  ) |> \n  pull(value) |> \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 983026\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}