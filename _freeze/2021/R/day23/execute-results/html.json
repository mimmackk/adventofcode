{
  "hash": "7a8bd9ed1fb9ac673e41b05dd2b2a73f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 23\"\ndate: 2021-12-23\nauthor:\n  name: https://adventofcode.com/2021/day/23\n  url: https://adventofcode.com/2021/day/23\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(igraph)\nlibrary(memoise)\n```\n:::\n\n\n\n\nRead and parse text input from file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day23.txt\", skip = 2, n_max = 2) |> \n  str_extract_all(\"[A-Z]\") |> \n  pmap(~ c(..1, ..2))\n```\n:::\n\n\n\n\n## Part 1\n\nWe represent every state of the board as a string, which allows us to concisely store board and to leverage regex in our computations.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhalls <- str_flatten(c(' ', rep(c(' ', '#'), 4), '  '))\nrooms <- map_chr(input, str_flatten)\nboard <- str_c(halls, str_flatten(rooms, collapse = \",\"), sep = \":\")\n```\n:::\n\n\n\n\nFor a given arrangement of free & blocked spaces in the hallway (irrelavant of the occupants of the blocked spaces and the status of the rooms), determine the set of legal moves from each room to a space in the hall:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract the free spaces around each room and convert to a list of indices:\n.room_moves <- function(halls) {\n  halls |> \n    str_locate_all('( *# *)+') |> \n    pluck(1) |> \n    as_tibble() |> \n    transmute(\n      room_idx = map2(start, end, \\(start, end) {\n        keep(c(0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 0)[start:end], ~ .x > 0)\n      }),\n      hall_idx = map2(start, end, \\(start, end) {\n        keep(c(1, 2, 0, 4, 0, 6, 0, 8, 0, 10, 11)[start:end], ~ .x > 0)\n      })\n    ) |> \n    unnest_longer(room_idx) |> \n    pull(hall_idx)\n}\n\n# Memoize for performance: only 128 configurations in total (7 choose k)\n.room_moves <- memoize(.room_moves)\nroom_moves <- \\(x) .room_moves(str_replace_all(x, \"[A-Z]\", \"X\"))\n```\n:::\n\n\n\n\nThe list of unblocked moves from the hall to a room is narrower, since an amphipod can only move into its final room:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhall_moves <- function(halls) {\n  map(1:4, \\(room_num) {\n    str_l <- str_sub(halls, 1L, 2 * room_num)\n    str_r <- str_sub(halls, 2 * room_num + 2, -1L)\n    \n    idx_l <- str_locate(str_l, str_c(LETTERS[room_num], \"[# ]*$\"))[,\"start\"]\n    idx_r <- str_locate(str_r, str_c(\"^[# ]*\", LETTERS[room_num]))[,\"end\"]\n    idx_r <- idx_r + 2 * room_num + 1\n    \n    unname(discard(c(idx_l, idx_r), is.na))\n  })\n}\n\nhall_moves <- memoize(hall_moves)\n```\n:::\n\n\n\n\nDefine helper functions to compute the cost of moving between two locations on board:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_spaces <- function(hall, room, room_size) {\n  n <- room_size + 1\n  \n  room_entry <- ceiling((room - 12) / n) * 2 + 1\n  room_depth <- (room - 13) %% n + 1\n  abs(hall - room_entry) + room_depth\n}\n\nnum_spaces <- memoize(num_spaces)\n\ncost <- function(from, to, chr, room_size) {\n  idx <- match(chr, LETTERS) \n  10^(idx - 1) * num_spaces(min(from, to), max(from, to), room_size)\n}\n\ncost <- memoize(cost)\n```\n:::\n\n\n\n\nDefine a helper function to convert a nested list of room indices and hall indices along with information about the current board state into to a new board configuration (as a string):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nto_board <- function(moves, spaces, vec, room_size, dir = c(\"in\", \"out\")) {\n  \n  n <- which(c(\"in\", \"out\") == dir)\n  \n  map2(\n    moves,\n    (0:3 * (room_size + 1) + 11) + spaces + n,\n    \\(hall_set, room_idx) {\n      map_chr(hall_set, \\(hall_idx) {\n        to   <- c(room_idx, hall_idx)[n]\n        from <- c(room_idx, hall_idx)[-n]\n        str_c(\n          str_flatten(replace(vec, c(from, to), c(\" \", vec[from]))),\n          cost(from, to, vec[from], room_size),\n          sep = \";\"\n        )\n      })\n    }\n  ) |> \n    unlist()\n  \n}\n```\n:::\n\n\n\n\nFrom a given hall/room configuration, get a list of valid next moves:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nroom_spaces <- \\(x) str_count(x, \" \")\nroom_has_invalid <- \\(x) str_detect(x, c(\"[BCD]\", \"[ACD]\", \"[ABD]\", \"[ABC]\"))\n\nnext_moves <- function(board, room_size) {\n  vec <- str_split_1(board, \"\")\n  board <- str_split_1(board, \":\")\n  halls <- board[1]\n  rooms <- board[2] |> str_split_1(\",\")\n  \n  # Determine which amphipods can move OUT of their room in the next step:\n  room_spaces <- room_spaces(rooms)\n  room_has_invalid <- room_has_invalid(rooms)\n  \n  # Get all valid hall-to-room moves first, then room-to-hall if none available.\n  hall_to_room <- hall_moves(halls)\n  hall_to_room[room_has_invalid] <- list(numeric(0))\n  \n  # If there are any hall-to-room moves, that's the only path we should take.\n  if (any(map_int(hall_to_room, length) > 0)) {\n    to_board(hall_to_room, room_spaces, vec, room_size, \"in\")\n  } else {\n    room_to_hall <- room_moves(halls)\n    room_to_hall[!room_has_invalid] <- list(numeric(0))\n    to_board(room_to_hall, room_spaces, vec, room_size, \"out\")\n  }\n}\n```\n:::\n\n\n\n\nCreate a queue to explore every board state. Once the connections between all board states has been established, convert to a graph and find the shortest distance between the start and end, weighted by movement cost:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_dist <- function(start, end) {\n  \n  room_size <- start |> \n    str_split_1(\":\") |> \n    pluck(2) |> \n    str_split_1(\",\") |> \n    pluck(1) |> \n    str_length()\n  \n  queue <- start\n  steps <- list()\n  \n  i <- 1\n  \n  while(i <= length(queue)) {\n    cur <- queue[i]\n    nxt <- next_moves(cur, room_size)\n    steps[cur] <- list(nxt)\n    nxt <- nxt |> str_split(';') |> map_chr(~ .x[1])\n    queue <- c(queue, setdiff(nxt, queue))\n    i <- i + 1\n  }\n  \n  g <- steps |>\n    enframe(name = \"V1\") |> \n    unnest_longer(value) |> \n    separate_wider_delim(value, delim = \";\", names = c(\"V2\", \"weight\")) |> \n    mutate(weight = as.numeric(weight)) |> \n    graph_from_data_frame(directed = TRUE)\n  \n  distances(g, v = start, to = end)[1, 1]\n}\n```\n:::\n\n\n\n\nRun on puzzle input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_dist(board, \"  # # # #  :AA,BB,CC,DD\")\n```\n:::\n\n\n\n\n## Part 2\n\nManually insert the new lines:\n\n```\n#D#C#B#A#\n#D#B#A#C#\n```\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrooms <- map2(\n  rooms,\n  c(\"DD\", \"CB\", \"BA\", \"AC\"),\n  ~ str_split_1(.x, \"\") |> \n    str_flatten(collapse = .y)\n)\n\nboard <- str_c(halls, str_flatten(rooms, collapse = \",\"), sep = \":\")\n```\n:::\n\n\n\n\nRe-run on the new input to get the new distance:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_dist(board, \"  # # # #  :AAAA,BBBB,CCCC,DDDD\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}