{
  "hash": "53c2f4d2d87ed167fdb8ad7cb07001c9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 17\"\ndate: 2021-12-17\nauthor:\n  name: https://adventofcode.com/2021/day/17\n  url: https://adventofcode.com/2021/day/17\n---\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(unglue)\n```\n:::\n\n\n\nRead input from file:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(file = \"../input/day17.txt\")\n```\n:::\n\n\n\nExtract numeric bounds from text input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntarget <- unglue_data(\n  input,\n  \"target area: x={xmin}..{xmax}, y={ymin}..{ymax}\", \n  convert = TRUE\n) |> \n  as.list()\n```\n:::\n\n\n\n## Part 1\n\nThe minimum x velocity is whichever value will cause the probe to come to rest just inside the target region. The maximum x velocity is the greatest x-value of the target (as the probe will get there in 1 step).\n\nTo compute the minimum starting x velocity, we take the ceiling of the n-value from the following formula:\n\n$$\\sum_{i = 1}^n i = \\frac{n(n+1)}{2} = \\mathrm{xmin} \\quad \\rightarrow \\quad \\frac{1}{2}n^2 + \\frac{1}{2}n - \\mathrm{xmin} = 0 \\quad \\rightarrow \\quad n = -\\frac{1}{2} + \\sqrt{\\frac{1}{4} + 2*\\mathrm{xmin}}$$\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_vmin <- ceiling(-0.5 + sqrt(0.25 + 2 * target$xmin))\nx_vmax <- target$xmax\n```\n:::\n\n\n\nWe also know that since gravity behaves symmetrically, we can't have an initial y velocity greater than the ymin boundary. Otherwise by the time it returns to y = 0, it will overshoot the target area in the next step.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny_vmin <- target$ymin\ny_vmax <- abs(target$ymin)\n```\n:::\n\n\n\nCompute the min/maximum number time steps when the probe is in the target x/y range. Compute x and y ranges separately, first:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_set <- tibble(v = x_vmin:x_vmax) |> \n  mutate(\n    pos  = map(v, ~ accumulate(.x:1, sum)),\n    xmax  = map_int(pos, ~ tail(.x, 1)),\n    tset = map(pos, \\(x) which(between(x, target$xmin, target$xmax))),\n    tmin = map_dbl(tset, min),\n    tmax = map_dbl(tset, max),\n    tmax = if_else(between(xmax, target$xmin, target$xmax), Inf, tmax)\n  ) |> \n  select(-tset) |> \n  filter(tmin <= tmax)\n\ny_set <- tibble(v = y_vmin:y_vmax) |>\n  mutate(\n    pos  = map(v, \\(v) accumulate(v:(-abs(v) - abs(target$ymin)), sum)),\n    tset = map(pos,  \\(y) which(between(y, target$ymin, target$ymax))),\n    tmin = map_dbl(tset, min),\n    tmax = map_dbl(tset, max),\n    ymax = map2_dbl(pos, tmax, \\(y, t) max(head(y, t)))\n  ) |> \n  select(-tset) |> \n  filter(tmin <= tmax)\n```\n:::\n\n\n\nCombine the x and y valid ranges to detect when both are in the target at the same time:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalid_set <- cross_join(x_set, y_set) |> \n  mutate(\n    tmin = pmax(tmin.x, tmin.y),\n    tmax = pmin(tmax.x, tmax.y)\n  ) |> \n  filter(tmin <= tmax)\n```\n:::\n\n\n\nPull the maximum y value attained by all valid starting velocities:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalid_set |> \n  pull(ymax) |> \n  max()\n```\n:::\n\n\n\n## Part 2\n\nCount the entries in the valid set of starting velocities:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(valid_set)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}