{
  "hash": "6fb721403afad54fa92f1d6189e08d35",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 21\"\ndate: 2021-12-21\nauthor:\n  name: https://adventofcode.com/2021/day/21\n  url: https://adventofcode.com/2021/day/21\n---\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(memoise)\n```\n:::\n\n\n\nDisable scientific formatting when displaying large numbers:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(scipen = 999)\n```\n:::\n\n\n\nRead and parse text input from file:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day21.txt\") |> \n  unglue_vec(\"Player {x} starting position: {y}\", var = 2, convert = TRUE)\n```\n:::\n\n\n\n## Part 1\n\nDefine a helper function to perform modulo operations using R's start-at-one indexing:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrmod <- \\(x, n) rep_len(1:n, max(x))[x]\n```\n:::\n\n\n\nSince all actions are deterministic, all scores can be determined with modulo arithmetic. If we assume a worst-case scenario where each player's score increments by only 1 each round, we calculate the scores of the first 1000 rounds for each player, then determine which won.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate the scores for the first 1000 turns in the game for each player\ngame <- tibble(roll = 1:(1000 * 3 * 2)) |> \n  mutate(\n    dice = rmod(roll, 100),\n    turn = ceiling(roll / 3),\n    player = rmod(turn, 2)\n  ) |> \n  summarize(move = sum(dice), .by = c(player, turn)) |> \n  mutate(\n    space = rmod(cumsum(move) + input[player], 10), \n    score = cumsum(space),\n    nrolls = turn * 3,\n    won = score >= 1000,\n    .by = player\n  ) |> \n  \n  # Keep only the turns up until a player wins the game\n  filter(lag(cumsum(won) == 0, default = TRUE))\n```\n:::\n\n\n\nMultiply the score of the losing player by total dice rolls until the game was won:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrev(game$score)[2] * max(game$nrolls)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1196172\n```\n\n\n:::\n:::\n\n\n\n## Part 2\n\nThe sum of each set of 3 quantum rolls can be equivalently interpreted as moves 3-9 with a corresponding number of universes:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnquant <- expand_grid(r1 = 1:3, r2 = 1:3, r3 = 1:3) |> \n  pmap_int(sum) |> \n  table()\n```\n:::\n\n\n\nDefine a function that simulates the set of all possible moves at each turn. Once any player reaches 21 points, the game ends and the total universes possible arrive at that state are summed.\n\nMemoization is leveraged for performance.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndirac <- function(player = 1, pos = input, score = c(0, 0)) {\n  if (any(score >= 21))\n    return(modify_at(c(0, 0), rmod(player + 1, 2), ~ 1))\n\n  map2(3:9, nquant, \\(roll, universes) {\n    new_space <- rmod(pos[player] + roll, 10)\n    universes * dirac(\n      player = rmod(player + 1, 2),\n      pos = modify_at(pos, player, ~ new_space),\n      score = modify_at(score, player, ~ .x + new_space)\n    )\n  }) |> \n    reduce(`+`)\n}\n\ndirac <- memoise(dirac)\n```\n:::\n\n\n\nRun the simulation on the puzzle input and find the count of total universes associated with the winning player:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax(dirac())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 106768284484217\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}