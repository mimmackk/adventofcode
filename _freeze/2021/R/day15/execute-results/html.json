{
  "hash": "5850e69a3544ce0c375778224256824e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 15\"\ndate: 2021-12-15\nauthor:\n  name: https://adventofcode.com/2021/day/15\n  url: https://adventofcode.com/2021/day/15\n---\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(igraph)\n```\n:::\n\n\n\nRead input from file into a row/column indexed data frame:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(file = \"../input/day15.txt\") |> \n  str_split(\"\") |> \n  imap_dfr(\\(vec, idx) {\n    tibble(row = idx, col = 1:length(vec), risk = as.integer(vec))\n  }) |> \n  mutate(id = row_number(), .before = everything())\n```\n:::\n\n\n\n## Part 1\n\nConvert input into a directed graph. Define the edge weights to be the risk level of each target vertex.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_to_graph <- function(df) {\n  \n  edges <- df |> \n  \n    # Define all neighbors and edge weights to the n/s/w/e of each vertex\n    mutate(n_target =  lag(id), n_weight =  lag(risk), .by = col) |> \n    mutate(s_target = lead(id), s_weight = lead(risk), .by = col) |> \n    mutate(w_target =  lag(id), w_weight =  lag(risk), .by = row) |> \n    mutate(e_target = lead(id), e_weight = lead(risk), .by = row) |> \n    \n    # Convert to a list of formatted vertex pairs for igraph\n    pivot_longer(\n      starts_with(c(\"n_\", \"s_\", \"w_\", \"e_\")), \n      names_to = \".value\", \n      names_pattern = \"._(.*)\",\n      values_drop_na = TRUE\n    ) |> \n    select(src = id, target, weight)\n  \n  # Convert to a weighted graph\n  g <- make_graph(list_c(map2(edges$src, edges$target, ~ c(.x, .y))))\n  E(g)$weight <- edges$weight\n  \n  return(g)\n}\n```\n:::\n\n\n\nFind the path with the least total risk and compute its risk:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin_risk <- function(df) {\n  vtx_start <- min(df$id)\n  vtx_end   <- max(df$id)\n \n  graph <- df_to_graph(df)\n  path <- shortest_paths(graph, from = vtx_start, to = vtx_end)$vpath[[1]]\n  \n  df$risk[path] |> \n    tail(n = -1) |> \n    sum()\n}\n```\n:::\n\n\n\nRun on puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin_risk(input)\n```\n:::\n\n\n\n## Part 2\n\nExpand the input X5 in each direction:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow <- max(input$row)\nncol <- max(input$col)\n\ndf_big <- accumulate(\n  1:4, \n  \\(df, n) mutate(df, col = col + ncol, risk = pmax(1, (risk + 1) %% 10)), \n  .init = input\n) |> \n  bind_rows() |> \n  accumulate(\n    1:4, \n    \\(df, n) mutate(df, row = row + nrow, risk = pmax(1, (risk + 1) %% 10)), \n    .init = _\n  ) |> \n  bind_rows() |> \n  arrange(row, col) |> \n  mutate(id = row_number())\n```\n:::\n\n\n\nRe-run the minimum risk function on the expanded input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin_risk(df_big)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}