{
  "hash": "578424080dd4fd5a085bf47fe300f5e9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 24\"\ndate: 2023-12-24\nauthor:\n  name: https://adventofcode.com/2023/day/24\n  url: https://adventofcode.com/2023/day/24\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput <- read_lines(\"../input/day24.txt\", skip_empty_rows = FALSE)\n```\n:::\n\n\n\n## Part 1\n\nConvert text input to structured data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbound_min <- 200000000000000\nbound_max <- 400000000000000\n\ndf <- input |> \n  unglue_data(\"{px}, {py}, {pz} @ {vx}, {vy}, {vz}\", convert = TRUE) |> \n  mutate(id = row_number(), .before = everything())\n\nvecs_2d <- df |> \n  transmute(\n    id,\n    p = pmap(lst(px, py), ~ matrix(c(..1, ..2), ncol = 1)),\n    v = pmap(lst(vx, vy), ~ matrix(c(..1, ..2), ncol = 1))\n  )\n\nvecs_3d <- df |> \n  transmute(\n    id,\n    p = pmap(lst(px, py, pz), ~ matrix(c(..1, ..2, ..3), ncol = 1)),\n    v = pmap(lst(vx, vy, vz), ~ matrix(c(..1, ..2, ..3), ncol = 1))\n  )\n```\n:::\n\n\n\nThe position $\\vec a$ of a hailstone at any given time $t$ can be written in the format:\n\n$$\\vec vt + \\vec p$$\n\nThe intersection of the paths of any two given hailstones is therefore the point $\\vec a$ where:\n\n$$\n\\vec a = \\vec v_1t_1 + \\vec p_1 = \\vec v_2t_2 = \\vec p_2\n$$\n\nThis can be re-written as the system of equations:\n\n$$\n\\begin{bmatrix}\\vec v_1 &-\\vec v_2\\end{bmatrix}\\begin{bmatrix}t_1\\\\t_2\\end{bmatrix} = \\vec p_2 - \\vec p_1\n$$\n\nSolving this system of equations for each pair of hailstones will give us the values of $t_1$ and $t_2$ that can then be used to compute the coordinates of their intersection, $\\vec a$.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Combine all hailstones' paths pairwise and solve the system of equations\npairs <- inner_join(\n  vecs_2d, \n  vecs_2d, \n  join_by(x$id < y$id), \n  suffix = c(\"1\", \"2\")\n) |> \n  mutate(\n    A = map2(v1, v2, ~ cbind(..1, -..2)),\n    b = map2(p1, p2, ~ ..2 - ..1),\n    det = map_dbl(A, det),\n    t = pmap(lst(A, b, det), \\(A, b, det) if (det != 0) as.vector(solve(A, b)))\n  ) |> \n  unnest_wider(t, names_sep = \"\") |> \n  \n  # Check if each path cross is within the bounding box and forward in time\n  mutate(\n    intersection = pmap(lst(t1, v1, p1), ~ ..1 * ..2 + ..3),\n    in_bounds = map_lgl(intersection, ~ all(between(.x, bound_min, bound_max))),\n    future_time = t1 >= 0 & t2 >= 0,\n    flag = replace_na(in_bounds & future_time, FALSE)\n  )\n\n# Count the number of future-crossing paths:\npairs |> \n  pull(flag) |> \n  sum()\n```\n:::\n\n\n\n## Part 2\n\nNow our equation has changed. For each hailstone $i$, and for our initial position $\\vec p_*$ and velocity $\\vec v_*$, we have the following relationship, where $t_i$ is the nonzero collision time of our rock and the given hailstone:\n\n$$\n(\\vec v_* - \\vec v_i)t_i = \\vec p_* - \\vec p_i\n$$\n\nSince $t_i$ is a scalar for each $i$, then $\\vec v_i - \\vec v_*$ and $\\vec p_i - \\vec p_*$ are scalar multiples of each other. Thanks to a hint from Reddit user [u/evouga](https://www.reddit.com/r/adventofcode/comments/18pnycy/comment/kepu26z/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button), as these vectors are parallel, their cross product is zero, meaning that for all $i$:\n\n$$\n(\\vec p_* - \\vec p_i) \\times (\\vec v_* - \\vec v_i) = 0\n$$\n\nExpanding this equation by the distributive property of the vector cross product, we get:\n\n$$\n(\\vec p_* \\times \\vec v_*) - (\\vec p_* \\times \\vec v_i) - (\\vec p_i \\times \\vec v_*) + (\\vec p_i \\times \\vec v_i) = 0\n$$\n\nVia [properties of the cross product](https://en.wikipedia.org/wiki/Cross_product#Conversion_to_matrix_multiplication), we can then represent this as:\n\n$$\n(\\vec p_* \\times \\vec v_*) - [\\vec v_i]_\\times^\\intercal \\vec p_* - [\\vec p_i]_\\times \\vec v_* + (\\vec p_i \\times \\vec v_i) = 0\n$$\n\nwhere $[\\vec a]_\\times$ is defined as:\n\n$$\n[\\vec a]_\\times = \\begin{bmatrix}0 & -a_3 & a_2 \\\\ a_3 & 0 & -a_1 \\\\ -a_2 & a_1 & 0\\end{bmatrix}\n$$\n\nWe can now (nearly) re-write this as a system of linear equations:\n\n$$\nA_i\\vec x = \\vec b_i + (\\vec p_* \\times \\vec v_*)\n$$\n\nwhere\n\n$$\nA_i = \\begin{bmatrix}[\\vec v_i]_\\times^\\intercal & [\\vec p_i]_\\times\\end{bmatrix}, \\quad \\vec x = \\begin{bmatrix}\\vec p_* \\\\ \\vec v_*\\end{bmatrix}, \\quad b_i = (\\vec p_i \\times \\vec v_i)\n$$\n\nSince this equation holds for all $i$, we can remove the needless term $(\\vec p_* \\times \\vec v_*)$ and solve for $\\vec x$ by subtracting two of these linear systems of equations from each other (using $i = 1,2$ as below, or any other two values of $i$ whose vectors from part 1 are not parallel):\n\n$$\n(A_1 - A_2)\\vec x = \\vec b_1 - \\vec b_2\n$$\n\nFinally, since we've arrived at a system of 3 equations and 6 unknowns, we append $A$ and $\\vec b$ with an additional pair of equations (using $i = 2,3$, for example) to solve for a final unique result:\n\n$$\n\\begin{bmatrix}A_1 - A_2\\\\A_2 - A_3\\end{bmatrix}\\vec x = \\begin{bmatrix}\\vec b_1 - \\vec b_2\\\\ \\vec b_2 - \\vec b_3\\end{bmatrix}\n$$\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a function to compute the skeq symmetric matrix [a]_x\nskewsym <- function(x) {\n  matrix(c(0, x[[3]], -x[[2]], -x[[3]], 0, x[[1]], x[[2]], -x[[1]], 0), ncol = 3)\n}\n\n# For the first three vectors in our list, compute their A and b values\nlineqs <- vecs_3d |> \n  slice_head(n = 3) |> \n  mutate(\n    A = map2(p, v, \\(p, v) cbind(t(skewsym(v)), skewsym(p))),\n    b = map2(p, v, \\(p, v) pracma::cross(p, v))\n  )\n\n# Combine the 3 linear equations into a single system & solve\nA <- rbind(lineqs$A[[1]] - lineqs$A[[2]], lineqs$A[[2]] - lineqs$A[[3]])\nb <- rbind(lineqs$b[[1]] - lineqs$b[[2]], lineqs$b[[2]] - lineqs$b[[3]])\nx <- solve(A, b)\n```\n:::\n\n\n\nFinally, add together the three px, py, and pz coordinates for the initial position:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(x[1:3]) |> \n  format(scientific = FALSE)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}