{
  "hash": "9ac3d3c3a5dea7a0f52f9d5ea71d8301",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 20\"\ndate: 2023-12-20\nauthor:\n  name: https://adventofcode.com/2023/day/20\n  url: https://adventofcode.com/2023/day/20\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput <- read_lines(\"../input/day20.txt\", skip_empty_rows = FALSE)\n```\n:::\n\n\n\n## Part 1\n\nConvert text input into a nested list of modules:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- input |> \n  unglue_data(\"{prefix=(%|&)?}{name} -> {destinations}\") |> \n  mutate(destinations = str_split(destinations, \",\\\\s*\"))\n\nsources <- df |> \n  unnest_longer(destinations) |> \n  summarize(sources = list(name), .by = destinations)\n\nblank_add <- sources |> \n  anti_join(df, join_by(x$destinations == y$name)) |> \n  transmute(name = destinations, prefix = '')\n\nmodules <- df |> \n  left_join(sources, join_by(x$name == y$destinations)) |> \n  add_row(name = \"button\", prefix = '', destinations = list(\"broadcaster\")) |> \n  bind_rows(blank_add) |> \n  mutate(\n    state = case_when(prefix == '%' ~ FALSE),\n    memories = case_when(\n      prefix == '&' ~ map(sources, ~ set_names(rep(FALSE, length(.x)), .x))\n    ),\n    n_lo = 0,\n    n_hi = 0\n  ) |> \n  transmute(\n    name,\n    value = pmap(lst(prefix, destinations, state, memories, n_lo, n_hi), lst)\n  ) |> \n  deframe()\n```\n:::\n\n\n\nDefine a function that modifies a set of modules when the button is pushed:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npush_button <- function(modules) {\n  queue <- list(list(source = \"button\", target = \"broadcaster\", pulse = FALSE))\n  modules$button$n_lo <- modules$button$n_lo + 1\n  \n  while (length(queue) > 0) {\n    signal <- queue[[1]]\n    queue  <- queue[-1]\n    module <- modules[[signal$target]]\n    output <- NULL\n    \n    if (signal$target == \"broadcaster\") {\n      output <- signal$pulse\n    } else if (module$prefix == '%' & signal$pulse == FALSE) {\n      modules[[signal$target]]$state <- !module$state\n      output <- !module$state\n    } else if (module$prefix == '&') {\n      modules[[signal$target]]$memories[[signal$source]] <- signal$pulse\n      output <- !all(modules[[signal$target]]$memories == TRUE)\n    }\n    \n    if (!is.null(output)) {\n      queue_add <- module$destinations |> \n        map(~ list(source = signal$target, target = .x, pulse = output))\n      queue <- c(queue, queue_add)\n      \n      n <- length(module$destinations)\n      \n      if (output == TRUE)\n        modules[[signal$target]]$n_hi <- modules[[signal$target]]$n_hi + n\n      else\n        modules[[signal$target]]$n_lo <- modules[[signal$target]]$n_lo + n \n    }\n  }\n  \n  modules\n}\n```\n:::\n\n\n\nDefine a function that sums the total low vs high buttons sent at a given state of the modules:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_pulses <- function(modules) {\n  c(\n    lo = sum(map_int(modules, ~ .x$n_lo)),\n    hi = sum(map_int(modules, ~ .x$n_hi))\n  )\n}\n```\n:::\n\n\n\nRun on puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput <- modules\n\nfor (i in 1:1000) {\n  output <- push_button(output)\n}\n\ncount_pulses(output) |> \n  prod()\n```\n:::\n\n\n\n## Part 2\n\nExamining the input, tj sends a low pulse to rx if its last memories (kk, xc, sk, vt) are all high pulses. For each of those memories, we just check when it first sends a high pulse to compute its cycle length, then take the LCM:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npushes_until_sent <- function(modules, name, pulse = c(\"hi\", \"lo\")) {\n  pulse <- c(\"n_\", pulse)\n  i <- 0\n  \n  while (pluck(modules, name, \"n_hi\") == 0) {\n    modules <- push_button(modules)\n    i <- i + 1\n  }\n  \n  return(i)\n}\n\nc(\"kk\", \"xc\", \"sk\", \"vt\") |> \n  map_dbl(~ pushes_until_sent(modules, .x, \"hi\")) |> \n  numbers::mLCM() |> \n  format(scientific = FALSE)\n```\n:::\n",
    "supporting": [
      "day20_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}