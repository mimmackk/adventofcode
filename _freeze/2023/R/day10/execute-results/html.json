{
  "hash": "7c803e1221b7641b9a2f8d4c10b2426f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 10\"\ndate: 2023-12-10\nauthor:\n  name: https://adventofcode.com/2023/day/10\n  url: https://adventofcode.com/2023/day/10\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput <- read_lines(\"../input/day10.txt\", skip_empty_rows = TRUE)\n```\n:::\n\n\n\n## Part 1\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndirs <- list(\n  n = c(row = -1, col =  0),\n  s = c(row =  1, col =  0),\n  w = c(row =  0, col = -1),\n  e = c(row =  0, col =  1)\n)\n\npipes <- list(\n  '|' = list(dirs$n, dirs$s),\n  '-' = list(dirs$w, dirs$e),\n  'L' = list(dirs$n, dirs$e),\n  'J' = list(dirs$n, dirs$w),\n  '7' = list(dirs$s, dirs$w),\n  'F' = list(dirs$s, dirs$e)\n)\n```\n:::\n\n\n\nConvert text input into a graph:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute row and column of every tile in the input text\nmaze_src <- input |> \n  enframe(name = \"row\") |> \n  mutate(value = str_split(value, \"\")) |> \n  unnest_longer(value, indices_to = \"col\") |> \n  transmute(\n    id = row_number(),\n    chr = value, \n    coords = map2(row, col, ~ c(row = .x, col = .y))\n  )\n\n# Save the index of the starting tile\nid_s <- maze_src |> \n  filter(chr == 'S') |> \n  pull(id)\n\n# Create a copy of the maze for each possible 'S' pipe and compute their conns\nmazes <- map(names(pipes), \\(pipe) {\n  maze_src |> \n    mutate(\n      chr = replace(chr, id_s, pipe),\n      conn = map(chr, ~ pipes[[.x]])\n    ) |> \n    unnest_longer(conn, indices_to = \"conn_num\") |> \n    mutate(conn = map2(coords, conn, ~ .x + .y)) |> \n    unnest_wider(coords) |> \n    unnest_wider(conn, names_sep = \"_\")\n})\n\n# Turn each maze into an undirected graph\ng <- mazes |> \n  map(\\(maze) {\n    edge_list <- maze |> \n      left_join(\n        distinct(maze, conn_id = id, row, col), \n        join_by(x$conn_row == y$row, x$conn_col == y$col)\n      ) |> \n      distinct(id, conn = conn_id) |> \n      drop_na(conn) |> \n      pmap(~ c(..1, ..2))\n    \n    intersect(edge_list, map(edge_list, rev)) |> \n      keep(~ .x[[1]] < .x[[2]]) |> \n      unlist()\n  }) |> \n  map(~ make_graph(as.integer(.x), directed = FALSE))\n\n\n# For each graph, check if there's a cycle containing the starting index\nhas_cycle_s <- map_lgl(g, \\(graph) {\n  subgraphs <- components(graph)$membership\n  sub_vtx <- which(subgraphs == subgraphs[[id_s]])\n  \n  if (length(sub_vtx) <= 2) \n    FALSE\n  else\n    graph |> \n      subgraph(sub_vtx) |> \n      has_eulerian_cycle()\n})\n\n# Keep only the graph that contain a cycle from the starting index\npipe_id_s <- which(has_cycle_s)\nmaze_g <- g[[pipe_id_s]]\n```\n:::\n\n\n\nCompute the furthest distance on the loop from the starting point:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmembership   <- components(maze_g)$membership\nloop_members <- which(membership == membership[[id_s]])\nloop_g       <- subgraph(maze_g, loop_members)\n\nceiling(girth(loop_g)$girth / 2)\n```\n:::\n\n\n\n## Part 2\n\nHint from Reddit ([link](https://www.reddit.com/r/adventofcode/comments/18evyu9/comment/kcqtow6/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)): To determine if a point is enclosed within a loop, check if a ray in any direction intersects the loop an even or odd number of times.\n\nFlag the tiles in the maze that make up the loop:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaze <- maze_src |> \n  mutate(chr = str_replace(chr, \"S\", names(pipes)[[pipe_id_s]])) |> \n  unnest_wider(coords) |> \n  mutate(in_loop = id %in% loop_members)\n```\n:::\n\n\n\nSeparate the loop by rows and count the number of orthogonal loop tiles for each:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaze_loop <- filter(maze, in_loop)\n\nloop_rows <- maze_loop |> \n  select(row, col, chr) |> \n  arrange(row, col) |> \n  mutate(\n    segment_num = cumsum(replace_na(col - lag(col), 1) > 1) + 1,\n    .by = row\n  ) |> \n  summarize(\n    col_min = min(col),\n    col_max = max(col),\n    chr = str_c(chr, collapse = \"\"),\n    .by = c(row, segment_num)\n  ) |> \n  mutate(\n    num_crossings = chr |> \n      str_replace_all(\"-\", \"\") |> \n      str_replace_all(\"F7|LJ\", \"\") |> \n      str_replace_all(\"FJ|L7\", \"|\") |> \n      str_count(\"\\\\|\")\n  ) |> \n  select(row, col_min, col_max, num_crossings)\n```\n:::\n\n\n\nFor each non-loop member of the maze, count the number of times it intersects the loop.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Count all loop crossings to the left of each non-loop tile\nmaze |> \n  filter(!in_loop) |> \n  left_join(loop_rows, join_by(row, col < col_min)) |> \n  summarize(\n    num_crossings = sum(replace_na(num_crossings, 0)),\n    .by = c(id, row, col)\n  ) |> \n  mutate(num_crossings = num_crossings %% 2) |> \n  pull(num_crossings) |> \n  sum()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}