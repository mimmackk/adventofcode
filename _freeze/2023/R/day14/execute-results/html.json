{
  "hash": "f8375c249ad9c65b57b3a01e1c248151",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 14\"\ndate: 2023-12-14\nauthor:\n  name: https://adventofcode.com/2023/day/14\n  url: https://adventofcode.com/2023/day/14\n---\n\n\n\n\n## Setup\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput <- read_lines(\"../input/day14.txt\", skip_empty_rows = FALSE)\n```\n:::\n\n\n\n\n## Part 1\n\nConvert the input text into a matrix:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtx <- input |> \n  str_split(\"\") |> \n  unlist() |> \n  matrix(nrow = length(input), byrow = TRUE)\n```\n:::\n\n\n\n\nFrom Reddit hints: can use [matrix transforms](https://www.reddit.com/r/adventofcode/comments/18i0xtn/comment/kdabenl/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button) and [regex](https://www.reddit.com/r/adventofcode/comments/18i0xtn/comment/kdact5r/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button) to make the tilting computations more efficient.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# For a set of string vectors, shift all rocks in them to the left. \nshift <- function(str) {\n  repeat {\n    new <- str_replace_all(str, \"\\\\.O\", \"O\\\\.\")\n\n    if (all(str == new))\n      return(str)\n    else\n      str <- new\n  }\n}\n\n# Tilt the entire matrix in a given direction (N/S/W/E)\ntilt <- function(mtx, dir = 'N') {\n  \n  if (dir %in% c('W', 'E'))\n    mtx <- t(mtx)\n  if (dir %in% c('S', 'E'))\n    mtx <- apply(mtx, 2, rev)\n  \n  # Split the matrix into columns, shift the rocks, and recombine\n  mtx <- split(mtx, col(mtx)) |> \n    map(str_flatten) |> \n    shift() |> \n    str_split(\"\") |> \n    do.call(args = _, what = cbind)\n  \n  if (dir %in% c('S', 'E'))\n    mtx <- apply(mtx, 2, rev)\n  if (dir %in% c('W', 'E'))\n    mtx <- t(mtx)\n  \n  mtx\n}\n```\n:::\n\n\n\n\nTilt the matrix and sum up the load:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompute_load <- function(mtx) {\n  split(mtx, col(mtx)) |> \n    map(~ which(rev(.x) == \"O\")) |> \n    unlist() |> \n    sum()\n}\n\nmtx |> \n  tilt() |> \n  compute_load()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 109661\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nLook for a cycle, then jump ahead to the 1000000000th state\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncycle <- \\(mtx) reduce(c('N', 'W', 'S', 'E'), tilt, .init = mtx)\n\n# Initialize\ncur  <- mtx\nloop <- list()\ni <- 0\n\n# Loop through cycles until a repeating loop is found\nrepeat {\n  i <- i + 1\n  cur <- cycle(cur)\n  loop[[i]] <- cur\n  \n  if (any(duplicated(loop)))\n    break\n}\n\n# Compute the length of the cycle and its starting point\ncycle_rep   <- which(duplicated(loop) | duplicated(loop, fromLast = TRUE))\ncycle_len   <- max(cycle_rep) - min(cycle_rep)\ncycle_start <- min(cycle_rep)\n\n# Compute an equivalent index to find the state at the 1000000000th cycle\nidx <- (1000000000 - cycle_start) %% cycle_len + cycle_start\n\nloop[[idx]] |> \n  compute_load()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 90176\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}