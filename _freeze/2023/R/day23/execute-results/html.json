{
  "hash": "5eb2d0bf642807840a3ce4bb271a21b7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 23\"\ndate: 2023-12-23\nauthor:\n  name: https://adventofcode.com/2023/day/23\n  url: https://adventofcode.com/2023/day/23\n---\n\n\n\n\n## Setup\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput <- read_lines(\"../input/day23.txt\", skip_empty_rows = FALSE)\n```\n:::\n\n\n\n\n## Part 1\n\nConvert text input to a directed graph:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert to a dataframe with IDs and coordinates per cell\ndf <- input |> \n  str_split(\"\") |> \n  enframe(name = \"row\") |> \n  unnest_longer(value, indices_to = \"col\") |> \n  mutate(id = row_number()) |> \n  filter(value != '#') |> \n  relocate(id, value, row, col)\n\n# Compute the list of directed edges between cells\nedges <- df |> \n  mutate(\n    row_n = row - 1,\n    row_s = row + 1,\n    col_w = col - 1,\n    col_e = col + 1\n  ) |> \n  left_join(df, join_by(x$row_n == y$row, col), suffix = c(\"\", \"_n\")) |> \n  left_join(df, join_by(x$row_s == y$row, col), suffix = c(\"\", \"_s\")) |> \n  left_join(df, join_by(x$col_w == y$col, row), suffix = c(\"\", \"_w\")) |> \n  left_join(df, join_by(x$col_e == y$col, row), suffix = c(\"\", \"_e\")) |> \n  select(-starts_with(c(\"row\", \"col\", \"value_\"))) |> \n  pivot_longer(\n    starts_with(\"id_\"),\n    names_to = \"dir\",\n    values_to = \"neighbor\",\n    names_prefix = \"id_\"\n  ) |> \n  \n  # For slope tiles, remove any non-downhill neighbors\n  filter(\n    (value == \".\" & !is.na(neighbor)) |\n      (value == \"^\" & dir == \"n\") | \n      (value == \"v\" & dir == \"s\") |\n      (value == \"<\" & dir == \"w\") | \n      (value == \">\" & dir == \"e\") \n  ) |> \n  pmap(\\(id, neighbor, ...) c(id, neighbor)) |> \n  unlist()\n\n# Convert to a graph\ng <- make_graph(edges)\n```\n:::\n\n\n\n\nFind the longest possible path from the start point to the end point:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource <- min(df$id)\ntarget <- max(df$id)\n\nmax_hike <- function(g, from = source, to = target) {\n  all_simple_paths(g, from, to) |> \n    map_dbl(~ length(.x) - 1) |> \n    sort(decreasing = TRUE) |> \n    max()\n}\n\nmax_hike(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2074\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nConvert to an undirected graph to remove the slope constraint:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- as_undirected(g)\nV(g)$name <- V(g)\n```\n:::\n\n\n\n\nThe graph is too large to simply run the hike length function again -- an overflow results.\n\nInstead, we notice that the input maze consists of relatively few intersections. Most of the maze input is simple corridors with no path decisions. We can reduce the graph complexity/size by trimming away our non-choice verftices and converting the length of those paths to an edge weight.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv_zero_edges   <- names(which(degree(g) == 0))\nv_two_edges    <- names(which(degree(g) == 2))\nv_nontwo_edges <- names(which(degree(g) != 2))\n\n# Extract all corridor vertices\ng_corridors <- delete_vertices(g, v_nontwo_edges)\ncorridors <- components(g_corridors)\n\n# Determine which edges to add to replace the corridors and their weight\nnew_weights <- corridors$csize + 1\nnew_edges <- corridors$membership |> \n  keep_at(names(which(degree(g_corridors) == 1))) |> \n  enframe(name = \"vtx\", value = \"group\") |> \n  mutate(vtx = map_chr(vtx, ~ setdiff(names(neighbors(g, .x)), v_two_edges))) |> \n  summarize(edge = list(vtx), .by = group) |> \n  arrange(group) |> \n  pull(edge)\n\n# Create a new graph without the corridor vertices, then add its new edges\ng_new <- reduce2(\n  .x = new_edges,\n  .y = new_weights,\n  .f = \\(g, e, w) add_edges(g, e, weight = w),\n  .init = delete_vertices(g, c(v_zero_edges, v_two_edges))\n)\n```\n:::\n\n\n\n\nView a plot of the resulting simplified graph:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvtx_labels <- g_new |> \n  V() |> \n  names() |> \n  case_match(\n    as.character(source) ~ \"S\", \n    as.character(target) ~ \"E\", \n    .default = \"\"\n  )\n\nplot(\n  g_new, \n  vertex.size = 8,\n  vertex.label = vtx_labels, \n  edge.label = E(g_new)$weight\n)\n```\n\n::: {.cell-output-display}\n![](day23_files/figure-html/unnamed-chunk-5-1.png){width=960}\n:::\n:::\n\n\n\n\nCompute all paths from the start to the end using our smaller graph:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_paths <- g_new |> \n  all_simple_paths(as.character(source), as.character(target))\n```\n:::\n\n\n\n\nUsing the edge weights of our graph, compute the total length of each path and select the longest:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_paths |> \n  map(\n    ~ .x |> \n      as_ids() |> \n      rep(each = 2) |> \n      head(-1) |> \n      tail(-1) |> \n      get_edge_ids(graph = g_new)\n  ) |> \n  map(~ E(g_new)$weight[.x]) |> \n  map_dbl(sum) |> \n  max()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6494\n```\n\n\n:::\n:::\n",
    "supporting": [
      "day23_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}