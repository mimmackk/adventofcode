{
  "hash": "148878dca84c3830e8842aac44f187ee",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 12\"\ndate: 2023-12-12\nauthor:\n  name: https://adventofcode.com/2023/day/12\n  url: https://adventofcode.com/2023/day/12\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput <- read_lines(\"../input/day12.txt\", skip_empty_rows = TRUE)\n```\n:::\n\n\n\n## Part 1\n\nConvert text input to a dataframe.  Identifiy the indices of each unknown value per row, and convert the numeric input into a regex pattern to test if a given spring arrangement is possible:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- input |> \n  unglue_data(\"{chr} {num}\") |> \n  mutate(\n    regex_pattern = str_c(\n      \"^\\\\.*#{\", \n      str_replace_all(num, \",\", \"}\\\\.+#{\"),\n      \"}\\\\.*$\"\n    ),\n    u_idx = map(chr, ~ which(str_split_1(.x, \"\") == \"?\")),\n    num = map(num, ~ as.integer(str_split_1(.x, \",\"))),\n    total_broken = map_int(num, sum),\n    cur_broken = str_count(chr, \"#\"),\n    num_b = total_broken - cur_broken\n  )\n```\n:::\n\n\n\nDefine a function to compute the total number of possible arrangements of broken springs for a given row using regex:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidx_permutations <- function(u_idx, num_b) {\n  \n  if (num_b == 0) {\n    list(list(B = numeric(0), O = u_idx))\n  } else {\n    permutations <- combn(length(u_idx), num_b)\n    map(\n      1:ncol(permutations),\n      ~ list(\n        B = u_idx[permutations[,.x]],\n        O = u_idx[-permutations[,.x]]\n      )\n    )\n  }\n  \n}\n\nnum_arragements <- function(input, regex_pattern, u_idx, num_b) {\n  perms <- idx_permutations(u_idx, num_b)\n  vec   <- str_split_1(input, \"\")\n  \n  perms |> \n    map_chr(\\(perm) {\n      vec |> \n        replace(perm$O, \".\") |> \n        replace(perm$B, \"#\") |> \n        str_c(collapse = \"\")\n    }) |> \n    str_detect(regex_pattern) |> \n    sum()\n}\n```\n:::\n\n\n\nRun on puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  pmap_int(\\(chr, regex_pattern, u_idx, num_b, ...) {\n    num_arragements(chr, regex_pattern, u_idx, num_b)\n  }) |> \n  sum()\n```\n:::\n\n\n\n\n## Part 2\n\nWith hints from [Reddit](https://www.reddit.com/r/adventofcode/comments/18ge41g/comment/kd0dw9e/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button), re-define the arrangement-counting function using memoization and recursion to examine at each character:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_arr <- memoise::memoise(function(str, grps, grp_count) {\n\n  # Check for contradictions and/or the end of the input\n  if (length(grps) == 0)\n    return(if_else(grp_count == 0 & str_detect(str, \"^(\\\\.|\\\\?)*$\"), 1, 0))\n  else if (str == \"\")\n    return(0)\n  else if (grp_count > grps[1]) \n    return(0)\n\n  # Initialize the total number of arrangements to 0 and get the current char\n  total_arr <- 0\n  cur_chr   <- str_sub(str, 1, 1)\n  \n  # If the char is unknown, examine both of the two possible states\n  if (cur_chr == \"?\")\n    cur_chr <- c(\".\", \"#\")\n  \n  for (chr in cur_chr) {\n    \n    # If '#', recurse within the current group\n    if (chr == \"#\")\n      total_arr <- total_arr + count_arr(str_sub(str, 2), grps, grp_count + 1)\n    \n    # If '.', close the current group (if one is active) & recurse\n    else if (chr == \".\") {\n      if (grp_count == 0)\n        total_arr <- total_arr + count_arr(str_sub(str, 2), grps, grp_count)\n      else if (grp_count == grps[1])\n        total_arr <- total_arr + count_arr(str_sub(str, 2), tail(grps, -1), 0)\n    }\n    \n  }\n  \n  total_arr\n})\n```\n:::\n\n\n\nRun on puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  pmap_dbl(\\(chr, num, ...) {\n    count_arr(str_c(str_c(rep(chr, 5), collapse = \"?\"), \".\"), rep(num, 5), 0)\n  }) |> \n  sum() |> \n  format(scientific = FALSE)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}