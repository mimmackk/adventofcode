{
  "hash": "b83f7ee8a314ba5e6f1ff46419c8a9f6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 21\"\ndate: 2023-12-21\nauthor:\n  name: https://adventofcode.com/2023/day/21\n  url: https://adventofcode.com/2023/day/21\n---\n\n\n\n\n## Setup\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput <- read_lines(\"../input/day21.txt\", skip_empty_rows = FALSE)\n```\n:::\n\n\n\n\n## Part 1\n\nConvert text input to a graph:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert text input to grid coordinates\ndf <- input |> \n  str_split(\"\") |> \n  enframe(name = \"row\") |> \n  unnest_longer(value, indices_to = \"col\") |> \n  mutate(id = row_number())\n\nvertices <- pull(df, value)\n\n# Compute edges for all cells to convert to a graph\nneighbors <- df |>\n  mutate(\n    n = case_when(lag(value)  != '#' ~ lag(id)),\n    s = case_when(lead(value) != '#' ~ lead(id)),\n    .by = col\n  ) |> \n  mutate(\n    w = case_when(lag(value)  != '#' ~ lag(id)),\n    e = case_when(lead(value) != '#' ~ lead(id)),\n    .by = row\n  ) |> \n  filter(value != '#') |> \n  select(id, n, s, w, e) |> \n  pivot_longer(\n    c(n, s, w, e),\n    names_to = \"dir\", \n    values_to = \"neighbor\", \n    values_drop_na = TRUE\n  ) |> \n  summarize(neighbors = list(neighbor), .by = id) |> \n  complete(id = 1:length(vertices)) |> \n  pull(neighbors) |> \n  map(sort)\n```\n:::\n\n\n\n\nFor 64 steps, loop through neighbors to find possible locations:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_plots <- function(start, n_steps) {\n  locs <- start\n  for (i in 1:n_steps) {\n    locs <- neighbors |> \n      keep_at(locs) |> \n      unlist() |> \n      unique()\n  }\n  length(locs)\n}\n\nnum_plots(match('S', vertices), 64)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3532\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nSince there are no obstacles in the center row or column (where the starting position is), we can easily compute how quickly it takes to enter a given \"box\" (repeat of the map) and from which direction we enter.\n\nFirst, we compute the number of steps it takes for a given box to enter a periodic cycle, depending on whether its starting location is from the center starting point, the middle of an edge, or a corner:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfind_cycle <- function(start_vtx) {\n  locs_prv <- NULL\n  locs_cur <- start_vtx\n  i <- 0\n\n  repeat {\n    locs_new <- neighbors |> \n      keep_at(locs_cur) |> \n      unlist() |> \n      unique() |> \n      sort()\n    \n    if (identical(locs_prv, locs_new)) \n      return(i - 1)\n    \n    locs_prv <- locs_cur\n    locs_cur <- locs_new\n    i <- i + 1\n  }\n}\n\nw_max <- max(df$col)\nw_mid <- ceiling(w_max / 2)\n\nstarting_points <- df |> \n  mutate(name = case_when(\n    value == 'S' ~ 'center',\n    col == w_mid & row == 1     ~ 'n',\n    col == w_mid & row == w_max ~ 's',\n    row == w_mid & col == 1     ~ 'w',\n    row == w_mid & col == w_max ~ 'e',\n    col == 1     & row == 1     ~ 'nw',\n    col == w_max & row == 1     ~ 'ne',\n    col == 1     & row == w_max ~ 'sw',\n    col == w_max & row == w_max ~ 'se'\n  )) |> \n  filter(!is.na(name)) |> \n  select(name, id) |> \n  deframe()\n\n# Determine when a cycle first occurs for the center, mid-edge, and corner pieces\ncycles <- map(\n  c(\n    corner   = starting_points[[\"nw\"]],\n    mid_edge = starting_points[[\"n\"]],\n    center   = starting_points[[\"center\"]]\n  ), \n  find_cycle\n)\n```\n:::\n\n\n\n\nNext, we split our total map into different box types. Boxes along the same horizontal/vertical lines as the initial starting point will always be entered from a mid-edge plot. All other boxes -- those along the diagonal/off-diagonal -- will be entered from the corner closest to the origin.\n\nWe can map the non-straight-line boxes as concentric rings indicating their Manhattan distance from the origin:\n\n```         \n  3X3\n 32X23\n321X123\nXXX.XXX\n321X123\n 32X23\n  3X3\n```\n\nNote that in each quadrant, there's 1 box 1 unit from the origin, 2 boxes 2 units away, 3 boxes 3 units away, etc. Meanwhile, for the straight-line boxes, there's only one box along each axis of its distance from the origin.\n\nFinally, we also have to take into account the fact that the periodic cycles alternate between odd and even steps. The number of plots in a box at a given step number depends on whether we entered that box on an even or an odd step. Below, all boxes entered on an odd step are labeled as A-type boxes, and those entered on an even step are B-type.\n\nThe number of plots in a cycling box are straightforward to compute. However, when a box is entered near the last of the steps and doesn't have enough time to enter a cycle, we have to compute its current number of plots separately at the time the simulation ends.\n\nWe begin with the diagonal/off-diagonal boxes:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 26501365\n\nrings_reached     <- ceiling(n / w_max - 1)\nrings_cycling     <- ceiling((n - cycles$corner) / w_max - 1)\nrings_in_progress <- (rings_cycling + 1):rings_reached\n\n# Compute the current value for the non-cycling diags\nplots_in_progress <- starting_points |> \n  keep_at(c(\"nw\", \"ne\", \"sw\", \"se\")) |> \n  map(\\(init_idx) {\n    rings_in_progress |> \n      # Compute the step when each ring was entered from its corner\n      map_dbl(~ w_max * .x + 1) |> \n      # Compute how many steps into the cycle each box currently is\n      map_dbl(~ n - .x) |> \n      map_dbl(~ num_plots(init_idx, .x))\n  }) |> \n  map(~ .x * rings_in_progress) |> \n  map_dbl(sum)\n\n# Compute the current value for the cycling diags\ncycling_a <- (1:rings_cycling) |> \n  keep(~ .x %% 2 == 0) |> \n  sum()\n\ncycling_b <- (1:rings_cycling) |> \n  keep(~ .x %% 2 == 1) |> \n  sum()\n\ncycle_steps_even <- cycles$corner + if_else(cycles$corner %% 2 == 0, 0, 1)\ncycle_steps_odd  <- cycles$corner + if_else(cycles$corner %% 2 == 0, 1, 0)\n\nplots_a <- cycling_a * num_plots(1, cycle_steps_even)\nplots_b <- cycling_b * num_plots(1, cycle_steps_odd)\n\nplots_cycling <- plots_a + plots_b\n\n# Compute total value of all diagonal boxes\nplots_diag <- 4 * plots_cycling + sum(plots_in_progress)\n```\n:::\n\n\n\n\nNow repeat for the straight-line boxes:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstraights_reached     <- ceiling((n + w_mid) / w_max - 1)\nstraights_cycling     <- ceiling((n + w_mid - cycles$mid_edge) / w_max - 1)\nstraights_in_progress <- (straights_cycling + 1):straights_reached\n\n# Compute the current value for the non-cycling straights\nplots_in_progress <- starting_points |> \n  keep_at(c(\"n\", \"s\", \"w\", \"e\")) |> \n  map_dbl(\\(init_idx) {\n    straights_in_progress |> \n      # Compute the step number when each box was entered from the edge\n      map_dbl(~ w_max * .x - w_mid + 1) |> \n      # Compute how many steps into the cycle each box currently is\n      map_dbl(~ n - .x) |> \n      map_dbl(~ num_plots(init_idx, .x)) |> \n      sum()\n  })\n\n# Compute the current value for the cycling straights\ncycling_a <- (1:straights_cycling) |> \n  keep(~ .x %% 2 == 0) |> \n  length()\n\ncycling_b <- (1:straights_cycling) |> \n  keep(~ .x %% 2 == 1) |> \n  length()\n\ncycle_steps_even <- cycles$mid_edge + if_else(cycles$mid_edge %% 2 == 0, 0, 1)\ncycle_steps_odd  <- cycles$mid_edge + if_else(cycles$mid_edge %% 2 == 0, 1, 0)\n\nplots_a <- cycling_a * num_plots(w_mid, cycle_steps_even)\nplots_b <- cycling_b * num_plots(w_mid, cycle_steps_odd)\n\nplots_cycling  <- plots_a + plots_b\n\n# Compute total value of all straight-line boxes\nplots_straight <- 4 * plots_cycling + sum(plots_in_progress)\n```\n:::\n\n\n\n\nFinally, compute the value for the center box:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncycle_steps_odd <- if_else(cycles$center %% 2 == 0, 1, 0) + cycles$center\nplots_center <- num_plots(match('S', vertices), cycle_steps_odd)\n```\n:::\n\n\n\n\nSum to get the final result:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformat(plots_center + plots_straight + plots_diag, scientific = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"590104708070703\"\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}