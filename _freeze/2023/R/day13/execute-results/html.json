{
  "hash": "50a916dd846cbcc4b81584e837c49142",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 13\"\ndate: 2023-12-13\nauthor:\n  name: https://adventofcode.com/2023/day/13\n  url: https://adventofcode.com/2023/day/13\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput <- read_lines(\"../input/day13.txt\", skip_empty_rows = FALSE)\n```\n:::\n\n\n\n## Part 1\n\nConvert each set of input strings into its own matrix:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtx <- tibble(chr = input) |> \n  group_split(cumsum(chr == \"\")) |> \n  map(~ pull(.x, chr)) |> \n  map(\n    ~ str_split(.x, \"\") |> \n      unlist() |> \n      matrix(nrow = sum(.x != \"\"), byrow = TRUE)\n  )\n```\n:::\n\n\n\nDefine a function that checks for a mirror along the given dimension (rows vs columns) of a given matrix:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmirror_idx <- function(mtx, dim = c(\"row\", \"col\")) {\n  vecs <- split(mtx, get(case_match(dim, \"row\" ~ \"col\", \"col\" ~ \"row\"))(mtx))\n  len  <- get(str_c(\"n\", dim))(mtx)\n  \n  refl_idx <- c(0)\n  \n  for (idx in 1:(len - 1)) {\n    n_trim <- min(idx, len - idx)\n    \n    is_mirror <- vecs |> \n      map_lgl(\\(vec) {\n        h1 <- rev(vec[1:idx])[1:n_trim]\n        h2 <- vec[(idx + 1):(idx + n_trim)]\n        all(h1 == h2)\n      }) |> \n      all()\n    \n    if (is_mirror) \n      refl_idx <- c(refl_idx, idx)\n  }\n  \n  refl_idx\n}\n```\n:::\n\n\n\nFor each matrix in the list, add the column indices of each vertical reflection line with 100 times the row indices of each horizontal reflection line:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscore_matrices <- function(mtx_list) {\n  mtx_list |> \n    map_dbl(~ sum(mirror_idx(.x, \"col\")) + sum(mirror_idx(.x, \"row\") * 100)) |> \n    sum()\n}\n\nscore_matrices(mtx)\n```\n:::\n\n\n\n## Part 2\n\nDefine a function that finds the row or column index of the single smudge for a given matrix:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmudge_idx <- function(mtx, dim = c(\"row\", \"col\")) {\n  \n  vecs <- split(mtx, get(case_match(dim, \"row\" ~ \"col\", \"col\" ~ \"row\"))(mtx))\n  len  <- get(str_c(\"n\", dim))(mtx)\n  \n  for (idx in 1:(len - 1)) {\n    n_trim <- min(idx, len - idx)\n    \n    noteq <- vecs |> \n      map(\\(vec) {\n        h1 <- rev(vec[1:idx])[1:n_trim]\n        h2 <- vec[(idx + 1):(idx + n_trim)]\n        which(h1 != h2)\n      })\n    \n    if (length(unlist(noteq)) == 1) return(idx)\n  }\n  return(0)\n}\n```\n:::\n\n\n\nRe-score the input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscore_unsmudged <- function(mtx_list) {\n  mtx_list |> \n    map_dbl(~ sum(smudge_idx(.x, \"col\")) + sum(smudge_idx(.x, \"row\") * 100)) |> \n    sum()\n}\n\nscore_unsmudged(mtx)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}