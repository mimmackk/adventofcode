{
  "hash": "4af39da506d0c9c6396140618a1f0777",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 3\"\ndate: 2023-12-03\nauthor:\n  name: https://adventofcode.com/2023/day/3\n  url: https://adventofcode.com/2023/day/3\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput <- read_lines(\"../input/day03.txt\", skip_empty_rows = FALSE)\n```\n:::\n\n\n\n## Part 1\n\nConvert the input strings into a character matrix for ease of indexing:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtx <- input |> \n  str_split(\"\") |> \n  unlist() |> \n  matrix(nrow = length(input), byrow = TRUE)\n\nmax_row <- nrow(mtx)\nmax_col <- ncol(mtx)\n```\n:::\n\n\n\nIdentify all candidates for part numbers and their coordinates in the matrix representation of the input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pull all candidates from the text input\nparts <- input |> \n  str_extract_all(\"\\\\d+\") |> \n  map(unique)\n\n# Compute the indices of each candidate within each input string\nparts_locations <- map2(input, parts, \\(chr_row, row_parts) {\n  chr_row |> \n    str_locate_all(str_c(\"\\\\b\", row_parts, \"\\\\b\")) |>\n    map(partial(asplit, MARGIN = 1))\n})\n```\n:::\n\n\n\nIdentify all neighbors of each part number candidate:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparts_df <- parts_locations |> \n  \n  # Combine all candidates and their indices into a data frame of coordiantes\n  enframe(name = \"row\") |> \n  unnest_longer(value, values_to = \"locations\", indices_to = \"part_id\") |> \n  unnest_longer(locations, values_to = \"col_seq\", indices_to = \"loc_id\") |> \n  mutate(col_seq = map(col_seq, partial(full_seq, period = 1))) |> \n  left_join(\n    parts |> \n      enframe(name = \"row\") |> \n      unnest_longer(\n        value, \n        values_to = \"part_int\", \n        indices_to = \"part_id\", \n        transform = as.integer\n      ),\n    join_by(row, part_id)\n  ) |> \n  mutate(part_id = cur_group_id(), .by = c(row, part_id, loc_id)) |> \n  \n  # Pull the neighboring characters for every part in the input\n  mutate(\n    search_rows = map(row, \\(row) {\n      c(row - 1, row, row + 1) |> \n        keep(partial(between, left = 1, right = max_row))\n    }),\n    search_cols = map(col_seq, \\(col_seq) {\n      c(min(col_seq) - 1, col_seq, max(col_seq) + 1) |> \n        keep(partial(between, left = 1, right = max_row))\n    }),\n    neighbor = map2(search_rows, search_cols, \\(rows, cols) {\n      expand_grid(row = rows, col = cols) |> \n        mutate(chr = map2_chr(row, col, \\(row, col) mtx[row, col]))\n    })\n  ) |> \n  unnest(neighbor, names_sep = \"_\") |> \n  \n  # Simplify into a list of part IDs, integer values, and neighboring chars\n  select(row, part_id, part_int, starts_with(\"neighbor\")) |> \n  mutate(\n    neighbor_id = cur_group_id(), \n    .by = c(neighbor_row, neighbor_col),\n    .before = neighbor_chr\n  )\n```\n:::\n\n\n\nPull all candidates that are true part numbers (have a neighboring symbol) and sum their values:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparts_df |> \n  filter(!str_detect(neighbor_chr, \"[0-9.]\")) |> \n  distinct(part_id, part_int) |> \n  pull(part_int) |> \n  sum()\n```\n:::\n\n\n\n## Part 2\n\nPull symbols with exactly two adjacent parts, multiply the part integers to get each gear ratio, and sum the total of the gear ratios:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparts_df |> \n  filter(!str_detect(neighbor_chr, \"[0-9.]\")) |> \n  filter(n() == 2, .by = neighbor_id) |> \n  summarize(gear_ratio = prod(part_int), .by = neighbor_id) |> \n  pull(gear_ratio) |> \n  sum()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}