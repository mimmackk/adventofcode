{
  "hash": "476cb60100dcaefdf6170337a1b4c7e1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 16\"\ndate: 2023-12-16\nauthor:\n  name: https://adventofcode.com/2023/day/16\n  url: https://adventofcode.com/2023/day/16\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput <- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE)\n```\n:::\n\n\n\n## Part 1\n\nConvert text input to a character matrix:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtx <- input |> \n  str_split(\"\") |> \n  map(~ matrix(.x, nrow = 1)) |> \n  reduce(rbind)\n```\n:::\n\n\n\nDefine a function that converts a direction, direction index, and sublocation along that direction into standard row/column form, then into a single ID value:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtx_id <- function(dir, vec_idx, loc_idx) {\n  row <- case_match(dir, c('W', 'E') ~ vec_idx, c('N', 'S') ~ loc_idx)\n  col <- case_match(dir, c('W', 'E') ~ loc_idx, c('N', 'S') ~ vec_idx)\n  \n  (row - 1) * ncol(mtx) + col\n}\n```\n:::\n\n\n\nDefine a function that tracks the beam through the matrix and returns the IDs of the elements visited:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbeam <- function(dir, vec_idx = 1, start_idx, visited) {\n  \n  if (!between(start_idx, 1, nrow(mtx))) return(visited)\n  \n  # Initialize\n  vec <- if (dir %in% c('W', 'E')) mtx[vec_idx,] else mtx[,vec_idx]\n\n  end_idx      <- case_match(dir, c('E', 'S') ~ length(vec), c('N', 'W') ~ 1)\n  chr_split    <- case_match(dir, c('W', 'E') ~ '|',         c('N', 'S') ~ '-')\n  chr_turn_neg <- case_match(dir, c('N', 'W') ~ '\\\\',        c('S', 'E') ~ '/')\n  chr_turn_pos <- case_match(dir, c('N', 'W') ~ '/',         c('S', 'E') ~ '\\\\')\n  dir_split_1  <- case_match(dir, c('W', 'E') ~ 'N',         c('N', 'S') ~ 'W')\n  dir_split_2  <- case_match(dir, c('W', 'E') ~ 'S',         c('N', 'S') ~ 'E')\n  dir_turn_neg <- case_match(dir, c('N', 'S') ~ 'W',         c('W', 'E') ~ 'N')\n  dir_turn_pos <- case_match(dir, c('N', 'S') ~ 'E',         c('W', 'E') ~ 'S')\n  \n  for (i in start_idx:end_idx) {\n    \n    id <- mtx_id(dir, vec_idx, i)\n    \n    if (id %in% visited[[dir]])\n      return(visited)\n    else\n      visited[[dir]] <- c(visited[[dir]], id)\n    \n    if (vec[[i]] == chr_split) {\n      visited <- beam(dir_split_1, i, vec_idx - 1, visited)\n      visited <- beam(dir_split_2, i, vec_idx + 1, visited)\n      break\n    }\n    else if (vec[[i]] == chr_turn_neg) {\n      visited <- beam(dir_turn_neg, i, vec_idx - 1, visited)\n      break\n    }\n    else if (vec[[i]] == chr_turn_pos) {\n      visited <- beam(dir_turn_pos, i, vec_idx + 1, visited)\n      break\n    }\n  }\n  \n  visited\n}\n```\n:::\n\n\n\nStarting from upper left, loop through the matrix and count the number of energized tiles:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninit_visited <- map(set_names(c(\"N\", \"S\", \"W\", \"E\")), ~ c())\n\nbeam(\"E\", vec_idx = 1, start_idx = 1, visited = init_visited) |> \n  unlist() |> \n  unique() |> \n  length()\n```\n:::\n\n\n\n## Part 2\n\nIf the beam can enter from any edge, find the maximum number of energizable tiles:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenergize_from <- function(dir, vec_idx, start_idx) {\n  beam(dir, vec_idx, start_idx, init_visited) |> \n    unlist() |> \n    unique() |> \n    length()\n}\n\nexpand_grid(dir = c('N', 'S', 'W', 'E'), vec = 1:nrow(mtx)) |> \n  mutate(start = case_match(dir, c('S', 'E') ~ 1, c('N', 'W') ~ nrow(mtx))) |> \n  pmap_dbl(\\(dir, vec, start) energize_from(dir, vec, start)) |> \n  max()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}