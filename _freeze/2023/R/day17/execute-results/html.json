{
  "hash": "40653e781270d948930f52b4d627ec63",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 17\"\ndate: 2023-12-17\nauthor:\n  name: https://adventofcode.com/2023/day/17\n  url: https://adventofcode.com/2023/day/17\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput <- read_lines(\"../input/day17.txt\", skip_empty_rows = TRUE)\n```\n:::\n\n\n\n## Part 1\n\nConvert text input to a set of 2D coordinates (stored as complex numbers) and their costs:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvtx <- input |> \n  enframe(name = \"row\") |> \n  mutate(value = str_split(value, \"\")) |> \n  unnest_longer(value, indices_to = \"col\") |> \n  transmute(\n    id = row_number(),\n    z = complex(real = col, imaginary = row),\n    cost = as.integer(value)\n  )\n\nz    <- pull(vtx, z)\ncost <- pull(vtx, cost)\n\nnmax <- length(z)\n```\n:::\n\n\n\nDefine a set of helper functions needed for the pathfinding algorithm:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sort a list of lists by the value at the given/named index of the inner lists\nnested_sort <- \\(x, idx) x[order(sapply(x, '[[', idx))]\npsort <- partial(nested_sort, idx = \"priority\")\n\n# Compute the manhattan distance between any two vertices\nmanhattan_dist <- \\(a, b) abs(Re(a - b)) + abs(Im(a - b))\n\n# Pull a vertex's neighbors along the given axis (Re/Im) within a set dist range\nneighbors <- function(vtx, axis = c(\"Re\", \"Im\"), dmin, dmax) {\n  rng <- c(-dmax:-dmin, dmin:dmax) \n  nbr <- vtx + (rng * complex(real = axis == \"Re\", imaginary = axis == \"Im\"))\n  keep(nbr, ~ .x %in% z)\n}\n\n# Compute the cost of moving in a straight line between two vertices\nmove_cost <- function(source, target) {\n  path_indices <- complex(\n    real      = seq(Re(source), Re(target)),\n    imaginary = seq(Im(source), Im(target))\n  ) |> \n    discard(~ .x == source) |> \n    match(z)\n  \n  sum(cost[path_indices])\n}\n```\n:::\n\n\n\nA\\* pathfinding implementation (with much help from Reddit on use of complex numbers and storing the turns as part of the state):\n\n-   https://en.wikipedia.org/wiki/A\\*\\_search_algorithm\n-   https://www.redblobgames.com/pathfinding/a-star/introduction.html\n-   https://www.reddit.com/r/adventofcode/comments/18khohi/comment/kdrkivy/\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na_star <- function(start, goal, h, dmin, dmax) {\n  \n  # Current set of discovered nodes awaitng further investigation\n  frontier <- list(\n    list(id = start, axis = 'Re', priority = 0),\n    list(id = start, axis = 'Im', priority = 0)\n  )\n  \n  # For each vertex, the immediately preceeding vertex on its cheapest path\n  came_from <- rep(list(lst(Re = NA, Im = NA)), nmax)\n  \n  # Tracks the current min cost to get from 'start' node to node n\n  cost_so_far <- rep(list(lst(Re = Inf, Im = Inf)), nmax)\n  cost_so_far[[start]]$Re <- 0\n  cost_so_far[[start]]$Im <- 0\n  \n  while (length(frontier) > 0) {\n    cur_id   <- frontier[[1]]$id\n    cur_z    <- z[[cur_id]]\n    cur_axis <- frontier[[1]]$axis\n    nxt_axis <- case_match(cur_axis, 'Re' ~ 'Im', 'Im' ~ 'Re')\n    frontier <- tail(frontier, -1)\n    \n    # Return info about best path to goal\n    if (cur_id == goal) return(cost_so_far[[cur_id]][[cur_axis]])\n    \n    # If this path is better than the current record, then replace it\n    for (nxt_z in neighbors(cur_z, cur_axis, dmin, dmax)) {\n      nxt_id <- match(nxt_z, z)\n      tentative_cost <- cost_so_far[[cur_id]][[cur_axis]] + move_cost(cur_z, nxt_z)\n      \n      if (tentative_cost < cost_so_far[[nxt_id]][[nxt_axis]]) {\n        came_from[[nxt_id]][[nxt_axis]] <- cur_id\n        cost_so_far[[nxt_id]][[nxt_axis]] <- tentative_cost\n        \n        frontier <- psort(c(frontier, list(list(\n          id = nxt_id, \n          axis = nxt_axis, \n          priority = tentative_cost + h(nxt_z, z[[goal]])\n        ))))\n      }\n    }\n  }\n}\n```\n:::\n\n\n\nRun on puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na_star(1, nmax, h = manhattan_dist, dmin = 1, dmax = 3)\n```\n:::\n\n\n\n## Part 2\n\nRe-run on puzzle input with modified min/max distance values passed to the neighbors function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na_star(1, nmax, h = manhattan_dist, dmin = 4, dmax = 10)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}