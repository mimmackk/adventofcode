{
  "hash": "3718cb2675b8b06db75538a7ffd7d392",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 22\"\ndate: 2023-12-22\nauthor:\n  name: https://adventofcode.com/2023/day/22\n  url: https://adventofcode.com/2023/day/22\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(igraph)\n\n# Read input from file\ninput <- read_lines(\"../input/day22.txt\", skip_empty_rows = FALSE)\n```\n:::\n\n\n\n## Part 1\n\nConvert text input to a list of bricks with x/y/z coordinates:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbricks <- input |> \n  unglue_data(\"{x1},{y1},{z1}~{x2},{y2},{z2}\", convert = TRUE) |> \n  transmute(\n    id = row_number(),\n    x = map2(x1, x2, seq),\n    y = map2(y1, y2, seq),\n    z = map2(z1, z2, seq)\n  ) |> \n  transmute(\n    name = id,\n    value = pmap(lst(x, y, z), ~ lst(x = ..1, y = ..2, z = ..3))\n  ) |> \n  deframe()\n```\n:::\n\n\n\nFor performance, gather a list of dependencies between bricks, so that the full list doesn't need to be searched each time.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid <- input |> \n  unglue_data(\"{x1},{y1},{z1}~{x2},{y2},{z2}\", convert = TRUE) |> \n  transmute(\n    id = row_number(),\n    x  = map2(x1, x2, seq),\n    y  = map2(y1, y2, seq),\n    z  = map2(z1, z2, seq),\n  ) |> \n  unnest_longer(x) |> \n  unnest_longer(y) |> \n  unnest_longer(z)\n\ndepends_on <- bricks |> \n  map(\\(cur) {\n    inner_join(\n      grid,\n      expand_grid(x = cur$x, y = cur$y, z = min(cur$z)),\n      join_by(x, y, x$z < y$z),\n      suffix = c(\"_dep\", \"_cur\")\n    ) |> \n      pull(id) |> \n      unique() |> \n      as.character()\n  })\n\ndependents <- depends_on |> \n  enframe() |> \n  unnest_longer(value) |> \n  summarize(name = list(name), .by = value) |> \n  arrange(as.numeric(value)) |> \n  deframe()\n```\n:::\n\n\n\nDefine a function to check if a given brick will fall at a given snapshot in time:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfall_dist <- function(bricks, id) {\n  active <- bricks[[id]]\n  others <- bricks[depends_on[[id]]] |> discard(~ is.null(.x))\n  \n  # Initialize the current max z dist that the brick could drop\n  z_drop <- min(active$z) - 1\n  \n  # Check if brick is already on the ground\n  if (z_drop == 0) return(0)\n  \n  # Check if blocked by any other bricks\n  for (other in others) {\n    z_dist <- min(active$z) - max(other$z) - 1\n    if (z_dist == 0) \n      return(0)\n    else if (z_dist < z_drop) \n      z_drop <- z_dist\n  }\n  \n  z_drop\n}\n```\n:::\n\n\n\nSort the bricks using a DAG to avoid needless looping:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- dependents |> \n  imap(\\(children, parent) map(children, \\(child) c(parent, child))) |> \n  unlist() |> \n  unname() |> \n  as.numeric() |> \n  make_graph(n = length(bricks))\n\nis_dag(g)\nordering <- as.character(as.numeric(topo_sort(g)))\n```\n:::\n\n\n\nDefine a function to make all bricks fall into place:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrop_bricks <- function(bricks) {\n  new_stack <- bricks[ordering]\n  \n  for (i in names(new_stack))\n    new_stack[[i]]$z <- new_stack[[i]]$z - fall_dist(new_stack, i)\n\n  new_stack\n}\n```\n:::\n\n\n\nDrop all bricks down and determine which can be safely disentegrated. If a single brick is removed, does re-dropping the bricks change the result? If not, then it can be disintegrated.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsettled <- drop_bricks(bricks)\n\nnames(bricks) |> \n  \n  # For each brick, determine whether it can be safely disintegrated.\n  map_lgl(\\(brick_id) {\n    disintegrated <- discard_at(settled, brick_id)\n    disintegrated <- disintegrated[ordering]\n    for (i in dependents[[brick_id]]) {\n      if (fall_dist(disintegrated, i) > 0) return(FALSE)\n    }\n    return(TRUE)\n  }) |> \n  \n  # Sum the total number of safely disintegratable bricks\n  sum()\n```\n:::\n\n\n\n\n## Part 2\n\nFor each brick, determine the number of cascading bricks that will fall if this one is disintegrated:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_affected_bricks <- function(bricks, id) {\n  new_stack <- bricks[ordering] |> \n    discard_at(id)\n  \n  to_examine <- tail(ordering[as.logical(cumsum(ordering == id))], -1)\n  \n  total_moved <- 0\n  \n  for (i in to_examine) {\n    move <- fall_dist(new_stack, i)\n    if (move > 0) {\n      new_stack[[i]]$z <- new_stack[[i]]$z - move\n      total_moved <- total_moved + 1\n    }\n  }\n  total_moved\n}\n```\n:::\n\n\n\nRun on puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(settled) |> \n  map_dbl(num_affected_bricks, bricks = settled) |> \n  sum()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}