{
  "hash": "5d8168a4a6123c914b4c0b673aa8d4be",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 19\"\ndate: 2023-12-19\nauthor:\n  name: https://adventofcode.com/2023/day/19\n  url: https://adventofcode.com/2023/day/19\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sets)\n\n# Read input from file\ninput <- read_lines(\"../input/day19.txt\", skip_empty_rows = FALSE)\n```\n:::\n\n\n\n## Part 1\n\nSeparate the input into rules and parts:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparts <- input |> \n  keep(~ str_starts(.x, \"\\\\{\")) |> \n  unglue_data(\n    \"{x=[x],m=[m],a=[a],s=[s]}\", \n    open = \"[\", \n    close = \"]\", \n    convert = TRUE\n  ) |> \n  pmap(\\(x, m, a, s) lst(x, m, a, s))\n\nrules <- input |> \n  keep(~ str_starts(.x, \"\\\\w\")) |> \n  unglue_data(\"[name]{[rules]}\", open = \"[\", close = \"]\") |> \n  mutate(rules = str_split(rules, \",\")) |> \n  unnest_longer(rules, values_to = \"condition\", indices_to = \"cond_num\") |> \n  unglue_unnest(\n    condition, \n    c(\"{var}{eq=[<>]}{val}:{goto}\", \"{goto}\"), \n    convert = TRUE\n  ) |> \n  mutate(value = pmap(\n    lst(var, eq, val, goto), \n    ~ lst(var = ..1, eq = ..2, val = ..3, goto = ..4)\n  )) |> \n  summarize(value = list(value), .by = name) |> \n  deframe()\n```\n:::\n\n\n\nDefine a function that rates a part according to the rule list for each workflow:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrate <- function(part, workflow = \"in\") {\n  if (workflow %in% c('A', 'R')) \n    return(workflow == 'A')\n  \n  workflow <- rules[[workflow]]\n  \n  for (rule in workflow) {\n    if (is.na(rule$var))\n      return(rate(part, rule$goto))\n    if (get(rule$eq)(part[[rule$var]], rule$val))\n      return(rate(part, rule$goto))\n  }\n}\n```\n:::\n\n\n\nRate the list of parts, then for the accepted parts, add all ratings:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkeep(parts, map_lgl(parts, rate)) |> \n  unlist() |> \n  sum()\n```\n:::\n\n\n\n## Part 2\n\nDefine a function to cut the valid set of inputs into a set of intervals. Looping through our rules, trim down the intervals for x, m, a, and s until we have the final set of valid inputs:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkeys  <- set_names(c(\"x\", \"m\", \"a\", \"s\"))\nempty <- map(keys, ~ interval(domain = 'Z'))\ninit  <- map(keys, ~ interval(l = 1, r = 4000, domain = 'Z'))\n\nrate_range <- function(cur_range, workflow = \"in\") {\n  \n  if (workflow == 'A') \n    return(list(cur_range))\n  if (workflow == 'R')\n    return(list())\n  \n  workflow <- rules[[workflow]]\n  accepted <- list()\n\n  for (rule in workflow) {\n    if (is.na(rule$var)) {\n      accepted <- c(accepted, rate_range(cur_range, rule$goto))\n      return(accepted)\n    }\n\n    rule_range <- sets::interval(\n      l = case_match(rule$eq, '<' ~ 1,            '>' ~ rule$val + 1),\n      r = case_match(rule$eq, '<' ~ rule$val - 1, '>' ~ 4000),\n      domain = 'Z'\n    )\n\n    rule_pass <- cur_range |>\n      modify_at(rule$var, ~ interval_intersection(.x, rule_range))\n    rule_fail <- cur_range |>\n      modify_at(rule$var, ~ interval_complement(rule_range, .x))\n\n    accepted <- c(accepted, rate_range(rule_pass, rule$goto))\n    cur_range <- rule_fail\n  }\n}\n```\n:::\n\n\n\nRun and compute the number of total valid combinations:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrate_range(init) |> \n  map(\\(intrvl) map_dbl(intrvl, ~ length(as.set(.x)))) |> \n  map_dbl(prod) |>\n  sum() |> \n  format(scientific = FALSE)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}