{
  "hash": "ba1db0b8363fc37a2239575abad8dd21",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 16\"\ndate: 2022-12-16\nauthor:\n  name: https://adventofcode.com/2022/day/16\n  url: https://adventofcode.com/2022/day/16\n---\n\n\n\n\n## Setup\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput <- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE) |> \n  unglue::unglue_data(\n    c(\n      \"Valve {source} has flow rate={rate}; tunnels lead to valves {target}\",\n      \"Valve {source} has flow rate={rate}; tunnel leads to valve {target}\"\n    ),\n    convert = TRUE\n  ) |> \n  mutate(target = map(target, \\(x) str_split_1(x, \", \")))\n```\n:::\n\n\n\n\n## Part 1\n\nRepresent tunnels and valves as a graph:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- input |>\n  unnest(target) |> \n  pmap(function(source, target, ...) c(source, target)) |> \n  unique() |> \n  unlist() |> \n  make_graph(directed = TRUE) |> \n  as_undirected()\n```\n:::\n\n\n\n\nGet the list of valves with nonzero flow:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflows <- input |> \n  filter(rate > 0 | source == \"AA\") |> \n  select(source, rate) |> \n  deframe()\n\nnon_init_flows <- flows |> \n  discard_at(\"AA\")\n\nvalves <- names(flows)\n\ndists <- distances(g, valves, valves)\n```\n:::\n\n\n\n\nList all permutations of possible valves to visit with a total distance less than 30:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_path <- function(choices, last, cur_length, max_length) {\n  if (cur_length >= max_length)\n    return(head(last, -1))\n  if (length(choices) == 0)\n    return(last)\n  \n  ls <- list()\n  for (valve in choices) {\n    ls <- append(\n      ls, \n      list(get_path(\n        choices[choices != valve], \n        c(last, valve), \n        cur_length + dists[tail(last, 1), valve] + 1,\n        max_length\n      ))\n    )\n  }\n  ls |> \n    discard(is_null) |> \n    list_flatten() |> \n    unique()\n}\n\ncombos <- get_path(names(non_init_flows), names(flows[\"AA\"]), 0, 30)\n```\n:::\n\n\n\n\nCompute total pressure released for each permutation:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_pressures <- function(paths, max_time) {\n  map_dbl(paths, \\(path) {\n    valve      <- tail(path, -1)\n    valve_lag  <- head(path, -1)\n    flow       <- tail(flows[path], -1)\n    \n    dist       <- map2_int(valve_lag, valve, \\(src, target) dists[src, target])\n    time_start <- cumsum(dist) + 1:length(dist) + 1\n    pressure   <- (max_time - time_start + 1) * flow\n    \n    sum(pressure[time_start <= max_time])\n  })\n}\n\npressures <- get_pressures(combos, 30)\n```\n:::\n\n\n\n\nFind the permutation that gives the maximum pressure:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax_idx <- which.max(pressures)\npressures[max_idx]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1947\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nList all permutations of possible valves to visit with a total distance less than 26:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nel_combos    <- get_path(names(non_init_flows), names(flows[\"AA\"]), 0, 26)\nel_pressures <- get_pressures(el_combos, 26)\n```\n:::\n\n\n\n\nFor each set of permutations, get the best pressure.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nel_best <- tibble(valves = map(el_combos, sort), pressure = el_pressures) |> \n  slice_max(pressure, by = valves, with_ties = FALSE)\n```\n:::\n\n\n\n\nGet best combinations of permutations between yourself and the elephant:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nel_best |> \n  rename(el_valves = valves, el_pressure = pressure) |> \n  pmap_dbl(\\(el_valves, el_pressure) {\n    el_valves <- el_valves[el_valves != \"AA\"]\n    el_pressure + el_best |>\n      filter(map_lgl(valves, ~ length(intersect(.x, el_valves)) == 0)) |> \n      pull(pressure) |> \n      max()\n  }) |> \n  max()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2556\n```\n\n\n:::\n:::\n",
    "supporting": [
      "day16_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}