{
  "hash": "a643653d5f363db6b9db1d6107541342",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 21\"\ndate: 2022-12-21\nauthor:\n  name: https://adventofcode.com/2022/day/21\n  url: https://adventofcode.com/2022/day/21\n---\n\n\n\n\n## Setup\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput <- read_lines(\"../input/day21.txt\", skip_empty_rows = TRUE) |> \n  unglue::unglue_data(\n    patterns = c(\n      \"{monkey}: {input_1} {operation} {input_2}\",\n      \"{monkey}: {number}\"\n    ),\n    convert = TRUE\n  )\n```\n:::\n\n\n\n\n## Part 1\n\nIteratively apply each monkey-to-monnkey operation until complete:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- input |> \n  select(monkey, number) |> \n  deframe()\n\neqns <- input |> \n  filter(!is.na(operation)) |> \n  select(-number)\n\ncompute_monkeys <- function(numbers, eqns) {\n  repeat {\n    new_values <- eqns |> \n      mutate(\n        value_1 = numbers[input_1],\n        value_2 = numbers[input_2]\n      ) |> \n      drop_na(value_1, value_2) |> \n      mutate(output = pmap_dbl(\n        list(operation, value_1, value_2), \n        ~ get(..1)(..2, ..3)\n      )) |> \n      select(monkey, output) |> \n      deframe()\n    \n    if (length(new_values) == 0) {\n      break\n    } else {\n      numbers[names(new_values)] <- new_values\n      eqns <- filter(eqns, !(monkey %in% names(new_values)))\n    }\n  }\n  \n  numbers\n}\n```\n:::\n\n\n\n\nRun on puzzle input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompute_monkeys(numbers, eqns) |> \n  keep_at(\"root\") |>  \n  format(scientific = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            root \n\"87457751482938\" \n```\n\n\n:::\n:::\n\n\n\n\n\n## Part 2\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Replace 'humn' number with NA and re-compute known equation values\nmodified_numbers <- compute_monkeys(\n  modify_at(numbers, \"humn\", ~ NA),\n  mutate(eqns, operation = if_else(monkey == \"root\", \"==\", operation))\n)\n\nmonkey_funcs <- eqns |> \n  \n  # Reformat equations\n  mutate(operation = if_else(monkey == \"root\", \"==\", operation)) |> \n  mutate(\n    value_1 = modified_numbers[input_1], \n    value_2 = modified_numbers[input_2],\n    const = unname(coalesce(value_1, value_2)),\n    xposn = if_else(is.na(value_1), 1, 2),\n    input = if_else(is.na(value_1), input_1, input_2),\n  ) |> \n  filter(is.na(value_1) | is.na(value_2)) |> \n  \n  # Convert each operation into an inverse function\n  mutate(\n    f = pmap(list(operation, const, xposn), \\(op, const, xposn) {\n      if (op == \"+\")                   partial(`-`, ... = , const)\n      else if (op == \"*\")              partial(`/`, ... = , const)\n      else if (op == \"-\" & xposn == 1) partial(`+`, ... = , const)\n      else if (op == \"/\" & xposn == 1) partial(`*`, ... = , const)\n      else if (op == \"-\" & xposn == 2) partial(`-`, const, ... = )\n      else if (op == \"/\" & xposn == 2) partial(`/`, const, ... = )\n    }),\n  ) |> \n  select(output = monkey, f, input, const)\n\n# Initiate starting monkey value at the root monkey\ncur_monkey  <- filter(monkey_funcs, output == \"root\")\ncur_value   <- cur_monkey$const\nnext_monkey <- cur_monkey$input\n\n# Compute function inverse for each monkey until \"humn\" is reached\nwhile (next_monkey != \"humn\") {\n  cur_monkey  <- filter(monkey_funcs, output == next_monkey)\n  cur_value   <- cur_monkey$f[[1]](cur_value)\n  next_monkey <- cur_monkey$input\n}\n\n# View final input needed to achieve equality\ncur_value |> \n  format(scientific = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3221245824363\"\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}