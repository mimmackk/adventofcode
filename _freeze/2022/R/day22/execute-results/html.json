{
  "hash": "1d67d9496961f3daca4ca90d350b15eb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 22\"\ndate: 2022-12-22\nauthor:\n  name: https://adventofcode.com/2022/day/22\n  url: https://adventofcode.com/2022/day/22\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput <- read_lines(\"../input/day22.txt\", skip_empty_rows = TRUE)\n```\n:::\n\n\n\n## Part 1\n\nConvert input to a grid board and a series of steps in the path:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboard <- input |> \n  head(-1) |> \n  enframe(name = \"row\") |> \n  mutate(value = str_split(value, \"\")) |> \n  unnest(value) |> \n  mutate(col = row_number(), .by = row, .after = row) |> \n  filter(value %in% c(\".\", \"#\")) |> \n  mutate(id = row_number(), .before = everything())\n\npath <- input |>\n  tail(1) |> \n  str_split_1(\"(?<=.)(?=[LR])\") |> \n  as_tibble_col(column_name = \"input\") |> \n  mutate(\n    turn = case_match(str_extract(input, \"L|R\"), \n      \"R\" ~ 1, \n      \"L\" ~ -1, \n      .default = 0\n    ),\n    walk = parse_number(input),\n  )\n```\n:::\n\n\n\nCreate a set of 2D lists by direction:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvecs <- map(\n  c(row = \"row\", col = \"col\"),\n  ~ board |> \n    select({{ .x }}, id, value) |> \n    arrange(.data[[.x]]) |> \n    nest(vec = c(id, value)) |> \n    mutate(vec = map(vec, deframe)) |> \n    select(vec) |> \n    deframe()\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrap_head <- \\(x, n) c(tail(x,  n), head(x, -n))\nwrap_tail <- \\(x, n) c(tail(x, -n), head(x,  n))\n\ndirs_2d <- c(\"row_pos\", \"col_pos\", \"row_neg\", \"col_neg\")\n\nnext_dir <- function(dir_vec, prv_dir, turn) {\n  dir_vec[((which(dir_vec == prv_dir) + turn - 1) %% length(dir_vec)) + 1]\n}\n\nwalk_n <- function(id_start, dir_start, n) {\n  dir_vec  <- str_extract(dir_start, \"row|col\")\n  dir_sign <- case_match(str_extract(dir_start, \"pos|neg\"), \n    \"pos\" ~ 1, \n    \"neg\" ~ -1\n  )\n  \n  vec_idx <- board |> \n    filter(id == id_start) |> \n    pull({{ dir_vec }})\n  \n  x   <- vecs[[dir_vec]][[vec_idx]]\n  idx <- which(names(x) == id_start)\n  \n  for (i in 1:n) {\n    idx_next <- (idx + dir_sign - 1) %% length(x) + 1\n    \n    if (x[idx_next] == \"#\")\n      break\n    else\n      idx <- idx_next\n  }\n  \n  as.numeric(names(x)[idx])\n}\n\ncompute_pwd <- function(cell_id, dir_num) {\n  final <- filter(board, id == cell_id)\n  1000 * final$row + 4 * final$col + unname(dir_num)\n}\n\ninit_cell <- board |> \n  filter(value == \".\") |> \n  pull(id) |> \n  min()\n```\n:::\n\n\n\nRun on puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncell <- init_cell\ndir  <- \"row_pos\"\n  \nfor (i in 1:nrow(path)) {\n  prv_dir  <- dir\n  prv_cell <- cell\n  \n  dir  <- next_dir(dirs_2d, prv_dir, path$turn[i])\n  cell <- walk_n(cell, dir, path$walk[i])\n}\n\ncompute_pwd(cell, which(dirs_2d == dir) - 1)\n```\n:::\n\n\n\n## Part 2\n\nConvert from row/col vectors to roll/pitch/yaw vectors:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbox_dim <- 50\n\nvecs[[\"roll\"]] <- pmap(\n  list(\n    vecs$row[1:box_dim],\n    vecs$row[1:box_dim + box_dim * 2] |> \n      rev() |> \n      map(rev)\n  ),\n  ~ c(..1, ..2)\n)\n\nvecs[[\"pitch\"]] <- pmap(\n  list(\n    vecs$col[1:box_dim + box_dim],\n    vecs$row[1:box_dim + box_dim * 3] |> \n      map(rev)\n  ),\n  ~ c(..1, ..2)\n)\n\nvecs[[\"yaw\"]] <- pmap(\n  list(\n    vecs$row[1:box_dim + box_dim],\n    vecs$col[1:box_dim + box_dim * 2] |> \n      map(rev),\n    vecs$col[1:box_dim] |> \n      map(rev)\n  ),\n  ~ c(..1, ..2, ..3)\n)\n\ncoords_3d <- map(\n  c(roll = \"roll\", pitch = \"pitch\", yaw = \"yaw\"),\n  ~ vecs[[.x]] |> \n    map(~ as.numeric(names(.x))) |> \n    enframe(name = .x, value = \"id\") |> \n    unnest(id) |> \n    relocate(id)\n) |> \n  reduce(partial(full_join, by = join_by(id)))\n```\n:::\n\n\n\nCreate a new set of instructions for making left/right turns that depend on which box face is currently occupied:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndirs_3d <- list(\n  f1 = c(\"roll_pos\",  \"pitch_pos\", \"roll_neg\",  \"pitch_neg\"),\n  f2 = c(\"roll_pos\",  \"yaw_neg\",   \"roll_neg\",  \"yaw_pos\"),\n  f3 = c(\"yaw_pos\",   \"pitch_pos\", \"yaw_neg\",   \"pitch_neg\"),\n  f4 = c(\"roll_neg\",  \"yaw_neg\",   \"roll_pos\",  \"yaw_pos\"),\n  f5 = c(\"roll_neg\",  \"pitch_pos\", \"roll_pos\",  \"pitch_neg\"),\n  f6 = c(\"pitch_neg\", \"yaw_neg\",   \"pitch_pos\", \"yaw_pos\")\n) |> \n  map(partial(set_names, nm = c(\"row_pos\", \"col_pos\", \"row_neg\", \"col_neg\")))\n\nfaces <- board |> \n  mutate(\n    face_row = ceiling(row / box_dim), \n    face_col = ceiling(col / box_dim)\n  ) |>\n  arrange(id) |> \n  mutate(\n    box_face = cur_group_id(),\n    .by = c(face_row, face_col)\n  ) |> \n  select(id, box_face)\n\nboard_3d <- board |> \n  left_join(coords_3d, join_by(id)) |> \n  left_join(faces, join_by(id))\n```\n:::\n\n\n\nRedefine the walk function to take roll/pitch/yaw directions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwalk_n <- function(id_start, dir_start, n) {\n  dir_vec  <- str_extract(dir_start, \"roll|pitch|yaw\")\n  dir_sign <- case_match(str_extract(dir_start, \"pos|neg\"), \n    \"pos\" ~ 1, \n    \"neg\" ~ -1\n  )\n  \n  vec_idx <- board_3d |> \n    filter(id == id_start) |> \n    pull({{ dir_vec }})\n  \n  x   <- vecs[[dir_vec]][[vec_idx]]\n  idx <- which(names(x) == id_start)\n  \n  for (i in 1:n) {\n    idx_next <- (idx + dir_sign - 1) %% length(x) + 1\n    \n    if (x[idx_next] == \"#\")\n      break\n    else\n      idx <- idx_next\n  }\n  \n  as.numeric(names(x)[idx])\n}\n```\n:::\n\n\n\nRe-run the puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncell <- init_cell\ndir  <- \"roll_pos\"\ndir_vec <- dirs_3d$f1\n  \nfor (i in 1:nrow(path)) {\n  prv_dir  <- dir\n  prv_cell <- cell\n  \n  dir_vec <- dirs_3d[[board_3d$box_face[[prv_cell]]]]\n  \n  dir  <- next_dir(dir_vec, prv_dir, path$turn[i])\n  cell <- walk_n(cell, dir, path$walk[i])\n}\n\ncompute_pwd(cell, which(dir_vec == dir) - 1)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}