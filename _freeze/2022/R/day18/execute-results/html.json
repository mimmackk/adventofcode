{
  "hash": "bdaeb04d174693a0b55cd5135dbd7641",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 18\"\ndate: 2022-12-18\nauthor:\n  name: https://adventofcode.com/2022/day/18\n  url: https://adventofcode.com/2022/day/18\n---\n\n\n\n\n## Setup\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput <- read_lines(\"../input/day18.txt\", skip_empty_rows = TRUE) |> \n  unglue::unglue_data(\"{x},{y},{z}\", convert = TRUE) |> \n  mutate(id = row_number(), .before = everything())\n```\n:::\n\n\n\n\n## Part 1\n\nCreate a containing box for the set of cubes, padded by 1 voxel of air in each direction, and convert the full rectangular area into a graph:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxrange <- (min(input$x) - 1):(max(input$x) + 1)\nyrange <- (min(input$y) - 1):(max(input$y) + 1)\nzrange <- (min(input$z) - 1):(max(input$z) + 1)\n\n# Fill out each coordinate of the containing box with air\ncontainer <- input |> \n  mutate(type = \"cube\") |> \n  complete(x = xrange, y = yrange, z = zrange, fill = list(type = \"air\")) |> \n  mutate(id = row_number())\n\n# For each coordinate, create edges between adjacent coords of the same type\nedges <- container |>\n  arrange(x, y, z) |> \n  mutate(\n    edge_x1 = case_when(type == lag(type)  ~ lag(id)),\n    edge_x2 = case_when(type == lead(type) ~ lead(id)),\n    .by = c(y, z)\n  ) |> \n  mutate(\n    edge_y1 = case_when(type == lag(type)  ~ lag(id)),\n    edge_y2 = case_when(type == lead(type) ~ lead(id)),\n    .by = c(x, z)\n  ) |> \n  mutate(\n    edge_z1 = case_when(type == lag(type)  ~ lag(id)),\n    edge_z2 = case_when(type == lead(type) ~ lead(id)),\n    .by = c(x, y)\n  ) |> \n  mutate(across(starts_with(\"edge\"), \\(col) {\n    case_when(!is.na(col) ~ map2(id, col, ~ c(.x, .y)))\n  })) |> \n  select(starts_with(\"edge\")) |> \n  pivot_longer(everything()) |> \n  pull(value) |> \n  unlist()\n\n\n# Convert to a graph\ng <- make_graph(edges = edges, n = max(container$id), directed = TRUE) |> \n  as_undirected()\n```\n:::\n\n\n\n\nCompute the surface area of the cubes. Start by giving every cube a surface area of 6, then subtract the cube's vertex degree (which is the number of adjacent cubes):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the vertex IDs of all cubes\ncube_ids <- container |> \n  filter(type == \"cube\") |> \n  pull(id)\n\n# Compute the surface area of all cubes\ng |> \n  degree() |> \n  keep_at(cube_ids) |> \n  map_dbl(~ 6 - .x) |> \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3470\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nTo compute the external surface area, we compute the total surface area of the outermost containing box of air, then subtract away its known rectangular external surface area.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First vertex is external air padding, so we pull all vertices having its group\noutside_ids <- which(components(g)$membership == components(g)$membership[1])\n\n# Compute the surface area of the external air voxels using their vertex degree\ntotal_sa <- g |> \n  degree() |> \n  keep_at(outside_ids) |> \n  map_dbl(~ 6 - .x) |> \n  sum()\n\n# Compute the outer surface of the bounding box\nxlen <- max(xrange) - min(xrange) + 1\nylen <- max(yrange) - min(yrange) + 1\nzlen <- max(zrange) - min(zrange) + 1\nbounding_sa <- 2 * (xlen * ylen + xlen * zlen + ylen * zlen)\n\n# Subtract the outer surface area from the total surface area of the air padding\ntotal_sa - bounding_sa\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1986\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}