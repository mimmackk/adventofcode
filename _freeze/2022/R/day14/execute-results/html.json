{
  "hash": "d01be8b524e1f8579fecd54d4fb8fa57",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 14\"\ndate: 2022-12-14\nauthor:\n  name: https://adventofcode.com/2022/day/14\n  url: https://adventofcode.com/2022/day/14\n---\n\n\n\n\n## Setup\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from text\ninput <- read_lines(\"../input/day14.txt\")\n```\n:::\n\n\n\n\n## Part 1\n\nConvert input from rows of text lines to a list of obstacle coordinates:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract numeric values from the input text\ndf <- input |> \n  str_split(\" -> \") |> \n  imap_dfr(\\(input, idx) tibble(idx, input)) |> \n  unglue_unnest(input, \"{x},{y}\", convert = TRUE)\n\n\n# Expand the endpoints into a list of coordinates of every obstacle\nobstacles <- df |> \n  mutate(\n    seq_x = map2(x, lead(x), ~ if (!is.na(.x) & !is.na(.y)) .x:.y),\n    seq_y = map2(y, lead(y), ~ if (!is.na(.x) & !is.na(.y)) .x:.y),\n    .by = idx\n  ) |> \n  unnest(c(seq_x, seq_y)) |> \n  distinct(x = seq_x, y = seq_y) |> \n  mutate(chr = '#')\n```\n:::\n\n\n\n\nDefine a function to recursively drop a grain of sand until it comes to rest:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrop_grain <- function(scan, x_cur, y_cur) {\n  y_new <- y_cur + 1\n  \n  # Check if new y-coordinate is out of bounds\n  if (y_new > max(scan$y))\n    return(scan)\n  \n  for (x_new in c(x_cur, x_cur - 1, x_cur + 1)) {\n    # Check if next x-coordinate is out of bounds\n    if (!between(x_new, min(scan$x), max(scan$x)))\n      return(scan)\n    # If grain can flow into the next spot, recurse into next spot\n    else if (nrow(filter(scan, x == x_new, y == y_new)) == 0)\n      return(drop_grain(scan, x_new, y_new))\n  }\n\n  # If grain has nowhere to go, drop the grain in its current place and exit\n  return(add_row(scan, x = x_cur, y = y_cur, chr = \"o\"))\n}\n```\n:::\n\n\n\n\nDefine a function that fills the map with sand one grain at a time, starting from the designated point, until all sand comes to rest:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfill_sand <- function(scan, grain_func) {\n  repeat {\n    scan_new <- grain_func(scan)\n    \n    # If the scan is unchanged after dropping the grain, the sand is at rest. \n    if (nrow(scan_new) == nrow(scan)) break\n    \n    scan <- scan_new\n  }\n  scan\n}\n\ncount_grains <- function(scan) {\n  scan |> \n    filter(chr == \"o\") |> \n    nrow()\n}\n```\n:::\n\n\n\n\nCount the grains using the puzzle input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobstacles |> \n  fill_sand(grain_func = partial(drop_grain, x_cur = 500, y_cur = 0)) |> \n  count_grains()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 862\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nRe-define the drop_grain function to allow for the boundless floor:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrop_grain <- function(scan, x_cur, y_cur, floor) {\n  y_new <- y_cur + 1\n  \n  # Check if current location already has a grain of sand (entry blocked)\n  if (nrow(filter(scan, x == x_cur, y == y_cur)) > 0)\n    return(scan)\n  \n  # Check if the current sand grain is sitting on top of the floor\n  if (y_new == floor)\n    return(add_row(scan, x = x_cur, y = y_cur, chr = \"o\"))\n  \n  # If grain can flow into the next spot, recurse into next spot\n  for (x_new in c(x_cur, x_cur - 1, x_cur + 1)) {\n    if (nrow(filter(scan, x == x_new, y == y_new)) == 0)\n      return(drop_grain(scan, x_new, y_new, floor))\n  }\n\n  # If grain has nowhere to go, drop the grain in its current place and exit\n  return(add_row(scan, x = x_cur, y = y_cur, chr = \"o\"))\n}\n```\n:::\n\n\n\n\nCount the grains using the puzzle input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobstacles |> \n  fill_sand(\n    grain_func = partial(\n      drop_grain, \n      x_cur = 500, \n      y_cur = 0, \n      floor = max(obstacles$y) + 2\n    )\n  ) |> \n  count_grains()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 28744\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}