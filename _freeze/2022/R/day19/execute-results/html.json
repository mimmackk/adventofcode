{
  "hash": "68e58aeb7176554c5013d7ea253bb210",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 19\"\ndate: 2022-12-19\nauthor:\n  name: https://adventofcode.com/2022/day/19\n  url: https://adventofcode.com/2022/day/19\n---\n\n\n\n\n## Setup\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput <- read_lines(\"../input/day19.txt\", skip_empty_rows = TRUE)\n```\n:::\n\n\n\n\n## Part 1\n\nReformat the input as lists of robots with inputs and outputs for each blueprint:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nore      <- c(\"ore\" = 1, \"clay\" = 0, \"obsidian\" = 0, \"geode\" = 0)\nclay     <- c(\"ore\" = 0, \"clay\" = 1, \"obsidian\" = 0, \"geode\" = 0)\nobsidian <- c(\"ore\" = 0, \"clay\" = 0, \"obsidian\" = 1, \"geode\" = 0)\ngeode    <- c(\"ore\" = 0, \"clay\" = 0, \"obsidian\" = 0, \"geode\" = 1)\nempty    <- c(\"ore\" = 0, \"clay\" = 0, \"obsidian\" = 0, \"geode\" = 0)\n\nunglue_pattern <- str_c(\n  \"Blueprint {blueprint}:\",\n  \"Each ore robot costs {ore_ore} ore.\",\n  \"Each clay robot costs {clay_ore} ore.\",\n  \"Each obsidian robot costs {obsidian_ore} ore and {obsidian_clay} clay.\",\n  \"Each geode robot costs {geode_ore} ore and {geode_obsidian} obsidian.\",\n  sep = \" \"\n)\n\nblueprints <- input |> \n  unglue::unglue_data(unglue_pattern, convert = TRUE) |> \n  pivot_longer(\n    -blueprint, \n    names_to = c(\"robot\", \"cost_type\"), \n    values_to = \"cost_value\",\n    names_sep = \"_\"\n  ) |> \n  pivot_wider(names_from = cost_type, values_from = cost_value, values_fill = 0) |> \n  mutate(geode = 0) |> \n  nest(cost = c(ore, clay, obsidian, geode)) |> \n  mutate(\n    cost = map(cost, unlist),\n    output = map(robot, get)\n  ) |> \n  group_split(blueprint)\n```\n:::\n\n\n\n\nDefine a set of functions to find the maximum number of geodes for each blueprint.\n\nOptimizations to improve runtime were sourced from Reddit ([1](https://www.reddit.com/r/adventofcode/comments/zpihwi/comment/j0tvzgz/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button), [2](https://www.reddit.com/r/adventofcode/comments/zpy5rm/comment/j0vtecm/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax_geodes <- function(blueprint, inventory, production, time_left, max_cost, cur_best = 0) {\n  \n  # If the best possible set of geode robots in this branch can't outdo the current\n  # best, then don't traverse this branch.\n  theoretical_best <- inventory[\"geode\"] + \n    production[\"geode\"] * time_left +\n    sum(1:time_left - 1)\n  \n  if (time_left == 0 | theoretical_best <= cur_best)\n    return(inventory[\"geode\"])\n    \n  # Determine the amount of time required to build each robot next\n  time_to_build <- map_dbl(blueprint$cost, \n    ~ ceiling((.x - inventory) / production) |> \n      keep(.x > 0) |> \n      map_dbl(~ max(.x, 0) + 1) |> \n      max()\n  )\n  \n  # Determine which robots are buildable within the remaining time\n  idx <- which(\n    is.finite(time_to_build) & \n      time_to_build < time_left & \n      production < max_cost\n  )\n  \n  # Quit if there are no remaining options\n  if (length(idx) == 0)\n    return((inventory + time_left * production)[\"geode\"])\n  \n  # Loop through each branch of options\n  for (i in rev(idx)) {\n    branch_best <- max_geodes(\n        blueprint  = blueprint,\n        inventory  = inventory + \n          production * time_to_build[[i]] - \n          blueprint$cost[[i]],\n        production = production + blueprint$output[[i]],\n        time_left  = time_left - time_to_build[[i]],\n        max_cost   = max_cost,\n        cur_best   = cur_best\n      )\n    if (branch_best > cur_best)\n      cur_best <- branch_best\n  }\n  \n  return(cur_best)\n}\n\nblueprint_geodes <- function(blueprints, total_time) {\n  \n  best <- c()\n  \n  for (blueprint in blueprints) {\n    max_cost <- blueprint |> \n      pull(cost) |> \n      do.call(what = pmax) |> \n      modify_at(.at = \"geode\", ~ Inf)\n    best <- c(\n      best,\n      max_geodes(\n        blueprint  = blueprint,\n        inventory  = empty,\n        production = ore,\n        time_left  = total_time, \n        max_cost   = max_cost,\n        cur_best   = 0\n      )\n    )\n  }\n  \n  unname(best)\n}\n```\n:::\n\n\n\n\nCompute total quality score by multiplying the max geodes for each blueprint by its index:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblueprint_geodes(blueprints, total_time = 24) |> \n  imap_dbl(\\(geodes, i) i * geodes) |> \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2160\n```\n\n\n:::\n:::\n\n\n\n\n## Part 2\n\nFilter to the first 3 blueprints, increase the total time to 32 seconds, and take the product of the max geodes:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblueprints |> \n  keep_at(1:3) |> \n  blueprint_geodes(total_time = 32) |> \n  prod()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13340\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}