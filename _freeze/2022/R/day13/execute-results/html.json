{
  "hash": "9ce482d47f5075149c7e4ef7557cdb64",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 13\"\ndate: 2022-12-13\nauthor:\n  name: https://adventofcode.com/2022/day/13\n  url: https://adventofcode.com/2022/day/13\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input into a data frame and convert to indexed nested lists\ndf <- read_table(\"../input/day13.txt\", col_names = \"txt\") |> \n  mutate(\n    row_id   = row_number(),\n    group_id = floor((row_id - 1) / 2) + 1,\n    item_id  = (row_id - 1) %% 2 + 1,\n    lst      = map(txt, jsonlite::fromJSON, simplifyVector = FALSE)\n  )\n```\n:::\n\n\n\n## Part 1\n\nDefine a function to compare nested lists:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompare_nested <- function(a, b) {\n\n  # Compare if both inputs are numeric\n  if (is.numeric(a) & is.numeric(b)) {\n    if (a < b)  return(-1)\n    if (a > b)  return(1)\n    if (a == b) return(0)\n  }\n\n  # Compare if only one input is numeric\n  if (is.numeric(a) != is.numeric(b)) {\n    if (is.numeric(a))\n      return(compare_nested(list(a), b))\n    if (is.numeric(b))\n      return(compare_nested(a, list(b)))\n  }\n\n  # Compare if both inputs are lists\n  i <- 1\n  while (i <= min(length(a), length(b))) {\n    result <- compare_nested(a[[i]], b[[i]])\n    if (result %in% c(1, -1))\n      return(result)\n    i <- i + 1\n  }\n  # When all comparable values are equal, compare lengths\n  return(compare_nested(length(a), length(b)))\n}\n```\n:::\n\n\n\nSum the indices of packet pairs that are in order:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  select(group_id, item_id, lst) |>\n  pivot_wider(\n    names_from = item_id,\n    names_prefix = \"item_\",\n    values_from = lst\n  ) |>\n  mutate(comparison = map2_int(item_1, item_2, compare_nested)) |>\n  filter(comparison == -1) |>\n  pull(group_id) |> \n  sum()\n```\n:::\n\n\n\n## Part 2\n\nDefine a function to determine the pairwise order of nested lists:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort_nested <- function(lst) {\n  n <- length(lst)\n  indices <- 1:n\n\n  if (n == 0) return()\n  if (n == 1) return(indices)\n\n  # Bubble sort: loop through list and swap elements until sorted\n  repeat {\n    swap_occurred <- FALSE\n    for (i in 1:(n - 1)) {\n      j1 <- which(indices == i)\n      j2 <- which(indices == i + 1)\n      if (compare_nested(lst[[j1]], lst[[j2]]) == 1) {\n        indices[j1] <- i + 1\n        indices[j2] <- i\n        swap_occurred <- TRUE\n      }\n    }\n    if (!swap_occurred) break\n  }\n  return(indices)\n}\n```\n:::\n\n\n\nAdd new flagged packets, sort all, and multiply flagged indices:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_packets <- list(\"[[2]]\", \"[[6]]\") |>\n  map(jsonlite::fromJSON, simplifyVector = FALSE) |>\n  as_tibble_col(column_name = \"lst\")\n\ndf |>\n  transmute(lst, flag = FALSE) |>\n  add_row(new_packets, flag = TRUE) |>\n  mutate(ord = sort_nested(lst)) |>\n  filter(flag) |>\n  pull(ord) |> \n  prod()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}