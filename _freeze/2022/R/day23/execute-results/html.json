{
  "hash": "55a4440ee28c9580f6107d1afd9797f2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 23\"\ndate: 2022-12-23\nauthor:\n  name: https://adventofcode.com/2022/day/23\n  url: https://adventofcode.com/2022/day/23\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput <- read_lines(\"../input/day23.txt\", skip_empty_rows = TRUE) |> \n  enframe(name = \"row\") |> \n  mutate(value = map(value, ~ enframe(str_split_1(.x, \"\"), name = \"col\"))) |> \n  unnest(value)\n```\n:::\n\n\n\n## Part 1\n\nConvert map to a list of positions for each elf, using complex numbers to store 2D coords:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelves <- input |> \n  filter(value == \"#\") |> \n  mutate(z = complex(real = col, imaginary = row)) |> \n  pull(z)\n```\n:::\n\n\n\nDefine function to move elves in each round:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncardinal_dirs <- c(\n  n  =  0 - 1i,\n  s  =  0 + 1i,\n  w  = -1 + 0i,\n  e  =  1 + 0i,\n  nw = -1 - 1i,\n  ne =  1 - 1i,\n  sw = -1 + 1i,\n  se =  1 + 1i\n)\n\nadjacent_dirs <- list(\n  n = c(\"n\", \"nw\", \"ne\"),\n  s = c(\"s\", \"sw\", \"se\"),\n  w = c(\"w\", \"nw\", \"sw\"),\n  e = c(\"e\", \"ne\", \"se\")\n)\n\nmove_elves <- function(elves, round_num) {\n\n  # Determine which neighboring cells are occupied\n  neighbors <- map(cardinal_dirs, \\(dir) elves + dir)\n  occupied  <- map(neighbors, ~ .x %in% elves)\n  \n  # Determine which n/s/w/e moves are valid\n  valid <- map(adjacent_dirs, \\(dir_set) {\n    dir_set |> \n      map(~!occupied[[.x]]) |> \n      reduce(`&`)\n  })\n  \n  # Re-order the n/s/w/e priority according to the current round number\n  valid <- valid[(1:4 + round_num - 2) %% 4 + 1]\n  \n  # For all elves not surrounded by empty cells, determine their proposed move\n  all_borders_empty <- reduce(valid, `&`)\n  proposals <- valid |> \n    imap(\\(vec, dir) case_when(vec ~ neighbors[[dir]])) |>\n    pmap(\n      ~ c(discard(c(..1, ..2, ..3, ..4), is.na), NA) |> \n        head(1)\n    ) |> \n    unlist() |> \n    modify_if(all_borders_empty, ~ NA)\n  \n  # Nullify any colliding proposed moves\n  collisions <- na.omit(proposals)[duplicated(na.omit(proposals))]\n  movements <- if_else(proposals %in% collisions, NA, proposals)\n  \n  # Return the new elf coordinates\n  coalesce(movements, elves)\n}\n```\n:::\n\n\n\nDefine a function to compute the area of the bounding box then subtract away the number of elves:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_empty_tiles <- function(elves) {\n  height <- 1 + diff(range(Im(elves)))\n  width  <- 1 + diff(range(Re(elves)))\n  \n  height * width - length(elves)\n}\n```\n:::\n\n\n\nRun 10 rounds on puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreduce(1:10, move_elves, .init = elves) |> \n  n_empty_tiles()\n```\n:::\n\n\n\n## Part 2\n\nRun until no further movements occur:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 1\ncur_elves <- elves\n\nrepeat {\n  new_elves <- move_elves(cur_elves, i)\n  \n  if (all(new_elves == cur_elves)) break\n  \n  cur_elves <- new_elves\n  i <- i + 1\n}\n\ni\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}