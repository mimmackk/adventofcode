{
  "hash": "8504df7b791b2f0c5d85d199b6a54506",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 12\"\ndate: 2022-12-12\nauthor:\n  name: https://adventofcode.com/2022/day/12\n  url: https://adventofcode.com/2022/day/12\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput <- read_lines(\"../input/day12.txt\", skip_empty_rows = TRUE)\n```\n:::\n\n\n\n## Part 1\n\nReformat input as a data frame of coordinates and elevations:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- input |>\n  str_split(\"\") |>\n  unlist() |>\n  as_tibble() |>\n  transmute(\n    id = row_number(),\n    letter = value,\n    elevation = case_when(\n      letter == \"S\" ~  Inf,\n      letter == \"E\" ~ -Inf,\n      .default = match(letter, letters)\n    ),\n    row = floor((id - 1) / str_length(input[1]) + 1),\n    col = (id - 1) %% str_length(input[1]) + 1\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_to_graph <- function(df) {\n\n  # Flag whether each neighbor of each vertex is walkable\n  neighbors <- df |>\n    mutate(up   = lag(id), down  = lead(id), .by = col) |>\n    mutate(left = lag(id), right = lead(id), .by = row) |>\n    mutate(\n      across(\n        c(up, down, left, right),\n        ~ elevation[.x],\n        .names = \"{.col}_elev\"\n      ),\n      across(\n        ends_with(\"_elev\"),\n        ~ (.x - elevation) <= 1,\n        .names = \"{str_remove(.col, '_elev')}_walkable\"\n      )\n    ) |>\n    rename_with(.cols = c(up, down, left, right), ~ str_c(.x, \"_idx\")) |>\n    select(source_idx = id, ends_with(c(\"idx\", \"walkable\")))\n\n  # Construct a list of edges\n  edge_list <- neighbors |>\n    pivot_longer(\n      !source_idx,\n      names_to = c(\"target_dir\", \".value\"),\n      names_sep = \"_\"\n    ) |>\n    rename(\n      target_idx = idx,\n      target_walkable = walkable\n    ) |>\n    filter(target_walkable == TRUE) |>\n    pmap(function(source_idx, target_idx, ...) { c(source_idx, target_idx) }) |>\n    unlist()\n\n  # Convert to a directed graph\n  g <- make_empty_graph() |>\n    add_vertices(length(df$id)) |>\n    add_edges(edge_list)\n\n}\n\nshortest_path_length <- function(g, source_idx, target_idx) {\n  shortest_paths(g, from = source_idx, to = target_idx)$vpath[[1]] |>\n    length() - 1\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- df_to_graph(df)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the indices of the start and end vertices\nidx_start <- match(\"S\", df$letter)\nidx_end   <- match(\"E\", df$letter)\n\n# Compute shortest path from start to end\nshortest_path_length(g, idx_start, idx_end)\n```\n:::\n\n\n\n## Part 2\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Loop over all starting locations and find the shortest path to the end\nmin_dist <- Inf\nfor (i in c(idx_start, which(df$letter == \"a\"))) {\n  cur <- shortest_path_length(g, i, idx_end)\n  if (cur >= 0 & cur < min_dist) {\n    min_dist <- cur\n  }\n}\nmin_dist\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}