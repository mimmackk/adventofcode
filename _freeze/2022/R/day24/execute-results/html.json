{
  "hash": "8b2cff47c9ea02c0ad99c5891425aace",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 24\"\ndate: 2022-12-24\nauthor:\n  name: https://adventofcode.com/2022/day/24\n  url: https://adventofcode.com/2022/day/24\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput <- read_lines(\"../input/day24.txt\", skip_empty_rows = TRUE)\n```\n:::\n\n\n\n## Part 1\n\nConvert input string to a matrix of characters:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw <- str_length(input[[1]])\nh <- length(input)\n\nmtx <- input |> \n  str_split(\"\") |> \n  unlist() |> \n  matrix(nrow = h, byrow = TRUE)\n```\n:::\n\n\n\nDefine helper functions to determine whether a map space is occupied at a given time. Hint from reddit user [u/jaccomoc](https://www.reddit.com/r/adventofcode/comments/zu28ij/comment/jjeh95l/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button) to scan rows/columns for blizzards at a certain time, rather than simulating the entire map at every time point:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the constant start/end locations\ninit   <- c(row = 1, col = 2)\ntarget <- c(row = h, col = w - 1)\n\n# Wrap blizzards aroound the map edges\nwrap_w <- function(idx) (idx - 2) %% (w - 2) + 2\nwrap_h <- function(idx) (idx - 2) %% (h - 2) + 2\n\n# Check whether a given cell is open at a given time\nis_open <- function(idx, time) {\n  row <- idx[[1]]\n  col <- idx[[2]]\n  mtx[row, wrap_w(col - time)] != '>' & mtx[wrap_h(row - time), col] != 'v' &\n  mtx[row, wrap_w(col + time)] != '<' & mtx[wrap_h(row + time), col] != '^'\n}\n\n# Check whether a given cell is in the bounds of the map\nin_bounds <- function(idx) {\n  row <- idx[[1]]\n  col <- idx[[2]]\n  \n  (between(row, 2, h - 1) & between(col, 2, w - 1)) | \n  all(idx == init) | all(idx == target)\n}\n```\n:::\n\n\n\nDefine a function that loops through time points and stops when the first elf reaches the target. Hint on use of \"quantum elves\" that die if standing on a blizzard spot from Reddit user [u/SLiV9](https://www.reddit.com/r/adventofcode/comments/zu28ij/comment/j1i8usb/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoves <- list(\n  c(row =  1, col =  0),  # down\n  c(row =  0, col =  1),  # right\n  c(row = -1, col =  0),  # up\n  c(row =  0, col = -1),  # left\n  c(row =  0, col =  0)   # still\n)\n\ntime_cross <- function(time_start, init, target) {\n  \n  cur_locations <- list(init)\n  t <- time_start\n  \n  repeat {\n    t <- t + 1\n\n    cur_locations <- cur_locations |> \n      map(\\(start) map(moves, \\(move) start + move)) |> \n      flatten() |> \n      keep(in_bounds) |> \n      keep(partial(is_open, time = t)) |> \n      unique()\n    \n    if (list(target) %in% cur_locations) break\n  }\n  \n  t\n}\n```\n:::\n\n\n\nRun on puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt1 <- time_cross(0, init, target)\n\nt1\n```\n:::\n\n\n\n## Part 2\n\nRun the simulation again two more times, swapping the target and source locations, and starting where the last left off.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt2 <- time_cross(t1, target, init)\nt3 <- time_cross(t2, init, target)\n\nt3\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}