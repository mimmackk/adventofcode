{
  "hash": "a2a4fd46264975923414e588dcedd83d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 15\"\ndate: 2022-12-15\nauthor:\n  name: https://adventofcode.com/2022/day/15\n  url: https://adventofcode.com/2022/day/15\n---\n\n\n\n\n## Setup\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sf)\n\ntheme_set(theme_bw())\n\n# Read input from text and extract numeric values into a data frame\ninput <- read_lines(\"../input/day15.txt\") |> \n  unglue_data(\n    \"Sensor at x={s_x}, y={s_y}: closest beacon is at x={b_x}, y={b_y}\",\n    convert = TRUE\n  ) \n```\n:::\n\n\n\n\n\n## Part 1\n\nConvert input into a list of beacons, sensors, and total detection distances:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsensors <- input |> \n  distinct(\n    s_x, \n    s_y, \n    max_dist = abs(b_x - s_x) + abs(b_y - s_y)\n  )\n\nbeacons <- input |> \n  distinct(x = b_x, y = b_y)\n```\n:::\n\n\n\n\nGenerate a set of polygons that defines the regions detectible by each sensor:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert each sensor's detection distance into a region defined by a polygon\npoly <- sensors |> \n  mutate(\n    polygon = pmap(list(s_x, s_y, max_dist), function(x, y, dist) {\n      rbind(\n        c(x - dist, y),\n        c(x, y - dist),\n        c(x + dist, y),\n        c(x, y + dist),\n        c(x - dist, y)\n      ) |> \n        list() |> \n        st_polygon()\n    }),\n    geometry = st_sfc(polygon)\n  ) |> \n  transmute(idx = row_number(), geometry) |> \n  st_as_sf()\n\n# Merge all polygons into a single geometric shape\npoly_union <- st_union(poly)\n```\n:::\n\n\n\n\nVisualize:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Overlapping regions\nggplot() + \n  geom_sf(data = poly, aes(fill = factor(idx))) + \n  scale_fill_viridis_d(guide = \"none\")\n```\n\n::: {.cell-output-display}\n![](day15_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Merged region\nggplot() + \n  geom_sf(data = poly_union)\n```\n\n::: {.cell-output-display}\n![](day15_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n:::\n\n\n\n\nDefine a set of functions to count the number of integer points that cannot have a beacon within the detection region\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert a set of x/y boundaries to a spatial rectangle object\npoly_rect <- function(xmin, xmax, ymin, ymax) {\n  rbind(\n    c(xmin, ymax), \n    c(xmin, ymin), \n    c(xmax, ymin), \n    c(xmax, ymax), \n    c(xmin, ymax)\n  ) |> \n    list() |> \n    st_polygon() |> \n    st_sfc()\n}\n\n# Get the coordinates within a poly, optionally limited within x/y bounds\nsf_points_in_poly <- function(poly, xlim = NULL, ylim = NULL) {\n  \n  # Define a rectangular region within which to generate grid points\n  points_region <- poly_rect(\n    xmin = (if (is_null(xlim)) st_bbox(poly)$xmin else head(xlim, 1)) - 0.5, \n    xmax = (if (is_null(xlim)) st_bbox(poly)$xmax else tail(xlim, 1)) + 0.5, \n    ymin = (if (is_null(ylim)) st_bbox(poly)$ymin else head(ylim, 1)) - 0.5,\n    ymax = (if (is_null(ylim)) st_bbox(poly)$ymax else tail(ylim, 1)) + 0.5\n  )\n  \n  # Generate the grid points that sit within the polygon\n  points_region |> \n    st_make_grid(cellsize = 1, what = \"centers\") |> \n    st_intersection(poly) |> \n    \n    # Convert the set of points from spatial objects to x-y coordinates\n    st_coordinates() |> \n    as_tibble() |> \n    mutate(across(everything(), as.integer)) |> \n    rename_with(tolower)\n}\n\n# Count the points in a sf region (with optional x/y lims) that can't be a beacon\ncount_nonbeacon <- function(detection_region, known_beacons, x = NULL, y = NULL) {\n  \n  # Get the set of integer points within the polygon and x-y region specified\n  detection_region |> \n    sf_points_in_poly(xlim = x, ylim = y) |>\n  \n    # Remove known beacons from the list of points and count\n    anti_join(known_beacons, join_by(x, y)) |>\n    nrow()\n}\n```\n:::\n\n\n\n\nRun puzzle input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_nonbeacon(poly_union, beacons, y = 2000000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5367037\n```\n\n\n:::\n:::\n\n\n\n\n\n## Part 2\n\nDefine a function to get the location of an undetected beacon within a viewport:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfind_undetected_beacon <- function(detection_region, xlim, ylim) {\n  boundary <- poly_rect(xlim[1], xlim[2], ylim[1], ylim[2])\n  \n  # Find the polygon region where an undetected beacon could occur\n  undetected_region <- st_difference(boundary, detection_region)\n  \n  # Get all integer points in the region\n  points <- sf_points_in_poly(undetected_region)\n  \n  # Compute the region's boundary points to exclude\n  undetected_region_boundary <- undetected_region |>\n    st_bbox() |>\n    as.list() |>\n    pmap(\\(xmin, xmax, ymin, ymax) poly_rect(xmin, xmax, ymin, ymax)) |>\n    pluck(1) |> \n    st_difference(undetected_region) |> \n    sf_points_in_poly()\n  \n  # Exclude all boundary points from the region\n  anti_join(points, undetected_region_boundary, join_by(x, y))\n  \n}\n\ntuning_freq <- function(x, y) format(4000000 * x + y, scientific = FALSE)\n```\n:::\n\n\n\n\nRun on puzzle input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoint <- find_undetected_beacon(poly_union, c(0, 4000000), c(0, 4000000))\n\ntuning_freq(point$x, point$y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"11914583249288\"\n```\n\n\n:::\n:::\n",
    "supporting": [
      "day15_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}