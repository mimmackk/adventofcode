{
  "hash": "3c70b23e89b71095f3540820bdfdbe2b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 17\"\ndate: 2020-12-17\nauthor:\n  name: https://adventofcode.com/2020/day/17\n  url: https://adventofcode.com/2020/day/17\nexecute:\n  eval: true\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\nRead text input from file into a data frame of x & y coordinates with TRUE/FALSE values for active state:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day17.txt\") |> \n  map(~ str_split_1(.x, \"\") == \"#\") |> \n  enframe(name = \"x\", value = \"is_active\") |>   \n  unnest_longer(is_active, indices_to = \"y\") |>\n  mutate(z = 0L)\n```\n:::\n\n\n\n\n## Part 1\n\nCreate a data frame of x/y/z adjustments that can join on any coordinate to get its full set of neighbors:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnbr <- expand_grid(x = -1:1, y = -1:1, z = -1:1) |> \n  filter(!(x == 0 & y == 0 & z == 0))\n```\n:::\n\n\n\n\nDefine a function to cycles through the initiation process n times, iteratively comparing neighboring cubes to determine the next state with each cyle:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncycle <- function(grid, n = 6) {\n  \n  for (i in 1:n) {\n    grid <- grid |> \n      cross_join(nbr, suffix = c(\"\", \"_nbr\")) |> \n      mutate(\n        x = x + x_nbr,\n        y = y + y_nbr,\n        z = z + z_nbr\n      ) |> \n      summarize(nbrs = sum(is_active), .by = c(x, y, z)) |> \n      left_join(select(grid, x, y, z, is_active), join_by(x, y, z)) |>\n      mutate(is_active = replace_na(is_active, FALSE)) |> \n      transmute(x, y, z, is_active = (nbrs == 3) | (is_active & nbrs == 2))\n  }\n  \n  grid\n  \n}\n```\n:::\n\n\n\n\nRun on puzzle input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncycle(input) |> \n  pull(is_active) |> \n  sum()\n```\n:::\n\n\n\n\n\n## Part 2\n\nExtend the adjustment dataframe to accommodate a fourth dimension:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnbr <- expand_grid(x = -1:1, y = -1:1, z = -1:1, w = -1:1) |> \n  filter(!(x == 0 & y == 0 & z == 0 & w == 0))\n```\n:::\n\n\n\n\nExtend the cycle function to accommodate a fourth dimension:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncycle <- function(grid, n = 6) {\n  \n  for (i in 1:n) {\n    grid <- grid |> \n      cross_join(nbr, suffix = c(\"\", \"_nbr\")) |> \n      mutate(\n        x = x + x_nbr,\n        y = y + y_nbr,\n        z = z + z_nbr,\n        w = w + w_nbr\n      ) |> \n      summarize(nbrs = sum(is_active), .by = c(x, y, z, w)) |> \n      left_join(select(grid, x, y, z, w, is_active), join_by(x, y, z, w)) |>\n      mutate(is_active = replace_na(is_active, FALSE)) |> \n      transmute(x, y, z, w, is_active = (nbrs == 3) | (is_active & nbrs == 2))\n  }\n  \n  grid\n  \n}\n```\n:::\n\n\n\n\nRun on puzzle input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput |> \n  mutate(w = 0L) |> \n  cycle() |> \n  pull(is_active) |> \n  sum()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}