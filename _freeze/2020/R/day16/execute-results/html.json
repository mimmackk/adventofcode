{
  "hash": "fa9761c2304b5f4a08ea4ee13181dbc8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 16\"\ndate: 2020-12-16\nauthor:\n  name: https://adventofcode.com/2020/day/16\n  url: https://adventofcode.com/2020/day/16\nexecute:\n  eval: false\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(unglue)\n```\n:::\n\n\n\n\nRead text input from file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE)\n```\n:::\n\n\n\n\nParse raw text input into lists of rules, your ticket, and nearby tickets:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrules <- input |> \n  head_while(\\(x) x != \"your ticket:\") |> \n  unglue_data(\"{rule}: {min1}-{max1} or {min2}-{max2}\", convert = TRUE) |> \n  pivot_longer(\n    c(min1, max1, min2, max2), \n    names_pattern = \"(min|max)(1|2)\", \n    names_to = c(\".value\", \"option\"),\n    names_transform = list(option = as.integer)\n  )\n\ntickets <- input |> \n  tail_while(\\(x) x != \"your ticket:\") |> \n  discard(\\(x) x == \"nearby tickets:\") |> \n  enframe(name = \"ticket_id\", value = \"ticket\") |> \n  mutate(\n    owner = case_when(ticket_id == 1 ~ \"mine\", .default = \"nearby\"),\n    ticket = map(str_split(ticket, \",\"), parse_integer)\n  ) |> \n  unnest_longer(ticket, indices_to = \"field_id\", values_to = \"field_value\")\n```\n:::\n\n\n\n\n## Part 1\n\nDetermine which tickets have values that are not valid for any field:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nticket_validity <- tickets |> \n  filter(owner == \"nearby\") |> \n  cross_join(rules) |> \n  mutate(valid = between(field_value, min, max)) |> \n  summarize(valid = any(valid), .by = c(ticket_id, field_id, field_value))\n```\n:::\n\n\n\n\nCompute the ticket scanning error rate:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nticket_validity |> \n  filter(!valid) |> \n  pull(field_value) |> \n  sum()\n```\n:::\n\n\n\n\n## Part 2\n\nDiscard invalid tickets:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntickets_valid <- anti_join(\n  tickets,\n  ticket_validity |> \n    summarize(valid = all(valid), .by = ticket_id) |> \n    filter(!valid),\n  join_by(ticket_id)\n)\n```\n:::\n\n\n\n\nAmong the valid tickets, determine which rules are valid for the same fields across every ticket:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_max <- n_distinct(tickets_valid$ticket_id)\n\nfield_options <- tickets_valid |> \n  cross_join(rules) |> \n  filter(between(field_value, min, max)) |> \n  summarize(n_tickets = n_distinct(ticket_id), .by = c(field_id, rule)) |> \n  filter(n_tickets == n_max) |> \n  select(-n_tickets)\n```\n:::\n\n\n\n\nIf there's only one field that a certain rule is valid for, then that mapping must be the true mapping. Similarly, if there's only rule that a certain field can have, that must also be the true mapping. Iteratively pull out the valid mappings until all have been determined:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapping <- tibble(field_id = integer(), rule = character())\n\nwhile (nrow(field_options > 1)) {\n  \n  mapping <- field_options |> \n    mutate(valid1 = n() == 1, .by = field_id) |> \n    mutate(valid2 = n() == 1, .by = rule) |> \n    filter(valid1 | valid2) |> \n    select(field_id, rule) |> \n    bind_rows(mapping)\n  \n  field_options <- field_options |> \n    anti_join(mapping, join_by(field_id)) |> \n    anti_join(mapping, join_by(rule))\n}\n```\n:::\n\n\n\n\nNow that the mapping has been determined for each field, join back to the tickets and multiply the departure field values together:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntickets |> \n  filter(owner == \"mine\") |> \n  left_join(mapping, join_by(field_id)) |> \n  filter(str_detect(rule, \"departure\")) |> \n  pull(field_value) |> \n  prod()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}