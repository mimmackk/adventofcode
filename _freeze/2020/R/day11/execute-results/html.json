{
  "hash": "68bc47310eecc1809e20f3373a316c69",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 11\"\ndate: 2020-12-11\nauthor:\n  name: https://adventofcode.com/2020/day/11\n  url: https://adventofcode.com/2020/day/11\nexecute:\n  eval: true\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\nRead text input from file into a 1/0 matrix. \".\" values are read in as NA.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day11.txt\") |> \n  str_split(\"\") |> \n  map(\\(x) case_match(x, \"L\" ~ 0, \"#\" ~ 1)) |> \n  reduce(rbind) |> \n  unname()\n```\n:::\n\n\n\n\n## Part 1\n\nThe base R functions 'row' and 'col' generate a row/column index for every element of the supplied matrix. Create a helper function that generates an equivalent mapping for the diagonals of a matrix:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiag <- function(mtx, direction = c(\"up\", \"down\")) {\n  map2_int(\n    rep(1:nrow(mtx), times = ncol(mtx)), \n    rep(1:ncol(mtx), each  = nrow(mtx)), \n    \\(i, j) {\n      if (direction == \"up\")\n        i + j - 1\n      else if (direction == \"down\")\n        i - j + ncol(mtx)\n    }\n  ) |> \n    matrix(nrow(mtx), ncol(mtx))\n}\n```\n:::\n\n\n\n\nDefine a helper function which, for each element of our supplied matrix, counts how many adjacent seats are occupied in each direction:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounts <- function(mtx) {\n  lst(\n    input_rows  = row(mtx), \n    input_cols  = col(mtx), \n    input_diag1 = diag(mtx, \"up\"), \n    input_diag2 = diag(mtx, \"down\")\n  ) |> \n    map(\\(mapping) {\n      mtx |> \n        split(mapping) |> \n        map(\\(x) coalesce(x, 0)) |>\n        map(\\(x) lead(x, default = 0) + lag(x, default = 0)) |> \n        unsplit(mapping) |> \n        matrix(nrow(mtx), ncol(mtx))\n    }) |> \n    reduce(`+`)\n}\n```\n:::\n\n\n\n\nDefine a helper function to iteratively adjust the seating until now changes are found, then return the number of occupied seats:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshift_seating <- function(init, limit) {\n  neighbors <- counts(init)\n  init |> \n    replace(init == 0 & neighbors == 0, 1) |> \n    replace(init == 1 & neighbors >= limit, 0) \n}\n```\n:::\n\n\n\n\nLoop until equilibrium & count output:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncur <- input \nnxt <- input\n\nrepeat {\n  nxt <- shift_seating(cur, limit = 4)\n  if (all(nxt == cur | (is.na(cur) & is.na(nxt))))\n    break\n  cur <- nxt\n}\n\nsum(cur, na.rm = TRUE)\n```\n:::\n\n\n\n\n## Part 2\n\nAdjust the neighbor counting functions such that rather than just looking at the adjacent seats, it look at all seats in the line of sight:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounts <- function(mtx) {\n  lst(\n    input_rows  = row(mtx), \n    input_cols  = col(mtx), \n    input_diag1 = diag(mtx, \"up\"), \n    input_diag2 = diag(mtx, \"down\")\n  ) |> \n    map(\\(mapping) {\n      mtx |> \n        split(mapping) |> \n        map(\\(x) {\n          fwd <- x |>\n            accumulate(\\(x, y) coalesce(y, x), .dir = \"forward\") |>\n            lag(default = 0) |> \n            coalesce(0)\n          bwd <- x |>\n            accumulate(\\(x, y) coalesce(x, y), .dir = \"backward\") |>\n            lead(default = 0) |> \n            coalesce(0)\n          fwd + bwd\n        }) |> \n        unsplit(mapping) |> \n        matrix(nrow(mtx), ncol(mtx))\n    }) |> \n    reduce(`+`)\n}\n```\n:::\n\n\n\n\nLoop until equilibrium & count output:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncur <- input \nnxt <- input\n\nrepeat {\n  nxt <- shift_seating(cur, limit = 5)\n  if (all(nxt == cur | (is.na(cur) & is.na(nxt))))\n    break\n  cur <- nxt\n}\n\nsum(cur, na.rm = TRUE)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}