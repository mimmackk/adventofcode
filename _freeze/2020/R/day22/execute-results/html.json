{
  "hash": "fe20da9391389252071cd7fca4e19a09",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 22\"\ndate: 2020-12-22\nauthor:\n  name: https://adventofcode.com/2020/day/22\n  url: https://adventofcode.com/2020/day/22\nexecute:\n  eval: true\n---\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\nRead text input from file:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day22.txt\", skip_empty_rows = TRUE)\n```\n:::\n\n\n\nConvert text input to two lists of values, one for each player:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninit <- input |>\n  keep(~ str_detect(.x, \"^\\\\d+$\")) |>\n  as.integer() %>%\n  split(cut(seq_along(.), 2, labels = FALSE)) |> \n  unname()\n```\n:::\n\n\n\n## Part 1\n\nDefine a helper function to play a single round:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplay_round <- function(players) {\n  top_cards <- players |> \n    list_transpose() |> \n    pluck(1) |> \n    unname()\n  \n  winner <- which.max(top_cards)\n\n  players |> \n    map(~ tail(.x, -1)) |> \n    modify_in(winner, ~ c(.x, sort(top_cards, decreasing = TRUE)))\n}\n```\n:::\n\n\n\nDefine a helper function to score a winning hand:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscore <- function(x) {\n  map2_dbl(x, length(x):1, prod) |> \n    sum()\n}\n```\n:::\n\n\n\nPlay a game using the provided starting hand and score the winner:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncur <- init\n\nwhile (every(cur, ~ length(.x) > 0)) {\n  cur <- play_round(cur)\n}\n\ncur |> \n  unlist() |> \n  score()\n```\n:::\n\n\n\n## Part 2\n\nRedefine the helper function that plays a single round to adjust to the new rules:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplay_round <- function(players) {\n  \n  top_cards <- c(players[[1]][[1]], players[[2]][[1]])\n  \n  can_recurse <- players |> \n    map_lgl(~ length(.x) > pluck(.x, 1)) |> \n    all()\n  \n  if (!can_recurse) {\n    winner <- which.max(top_cards)\n  } else {\n    winner <- players |>\n      map(~ .x[seq(from = 2, length.out = pluck(.x, 1))]) |> \n      play_game() |> \n      map_int(length) |> \n      which.max()\n  }\n  \n  players |> \n    map(~ tail(.x, -1)) |> \n    modify_in(winner, ~ c(.x, top_cards[c(winner, setdiff(1:2, winner))]))\n}\n```\n:::\n\n\n\nDefine a helper function to play the game while the game state to avoid infinite recursion:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplay_game <- function(players) {\n  game_hist <- c()\n  \n  while (every(players, ~ length(.x) > 0)) {\n    cur_state <- players |> \n      map_chr(~ str_flatten(.x, \",\")) |> \n      str_flatten(\"|\")\n    \n    if (cur_state %in% game_hist) {\n      return(assign_in(players, 2, integer(0)))\n    } else {\n      game_hist <- c(\n        game_hist, \n        cur_state,\n        players |> \n          map_chr(~ str_flatten(.x, \",\")) |> \n          rev() |> \n          str_flatten(\"|\")\n      )\n      players <- play_round(players)\n    }\n  }\n  \n  players\n}\n```\n:::\n\n\n\nRun the game on the puzzle input and score the winning player:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninit |> \n  play_game() |> \n  unlist() |> \n  score()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}