{
  "hash": "cc662ff93fe9177c4dae365e6edd8985",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 14\"\ndate: 2020-12-14\nauthor:\n  name: https://adventofcode.com/2020/day/14\n  url: https://adventofcode.com/2020/day/14\nexecute:\n  eval: true\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(bit64)\n```\n:::\n\n\n\n\nDisable scientific formatting when displaying large numbers:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(scipen = 999)\n```\n:::\n\n\n\n\nRead text input from file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day14.txt\")\n```\n:::\n\n\n\n\nConvert text strings to a data frame of memory locations, values, and bit masks:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- input |> \n  unglue_data(c(\"mask = {mask}\", \"mem[{loc}] = {value}\"), convert = TRUE) |> \n  fill(mask, .direction = \"down\") |> \n  filter(!is.na(loc))\n```\n:::\n\n\n\n\n## Part 1\n\nCreate a helper function which takes an integer value and a 36-bit mask and applies the mask to the integer:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmask_int <- function(value, mask) {\n  \n  value |>\n    \n    # Convert to a 36-bit binary string\n    as.integer64() |>\n    as.bitstring() |>\n    str_sub(start = 29L) |> \n    str_split(\"\") |> \n  \n    # Apply the bitwise mask\n    map2(str_split(mask, \"\"), \\(bin, mask) {\n      case_match(mask, \"X\" ~ bin, c(\"0\", \"1\") ~ mask)\n    }) |> \n    \n    # Convert back from binary to integer format\n    map_vec(\\(x) {\n      c(rep(0, 28), x) |>\n        str_flatten() |>\n        structure(class = \"bitstring\") |>\n        as.integer64()\n    })\n}\n```\n:::\n\n\n\n\nApply the mask to each value. Then, for each memory location, pull the last saved value and sum the result:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  mutate(value_masked = mask_int(value, mask)) |> \n  summarize(value = last(value_masked), .by = loc) |> \n  pull(value) |> \n  sum()\n```\n:::\n\n\n\n\n## Part 2\n\nExtract all distinct masks from the dataset:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmasks <- df |> \n  distinct(mask) |> \n  mutate(\n    mask_id = row_number(),\n    floating_idx = str_locate_all(mask, \"X\"),\n    floating_idx = map(floating_idx, \\(mtx) mtx[, 1]),\n    floating_n = map_int(floating_idx, length)\n  )\n```\n:::\n\n\n\n\nEach mask has a certain number of possible variants based on how many floating values are in the mask string (1X = 1 variant, 2X = 4 variants, etc). Pre-compute the possible 1/0 combinations for each number of variants:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvariants <- map(1:max(masks$floating_n), \\(n) {\n  do.call(crossing, args = rep(list(c(\"0\", \"1\")), n)) |> \n    mutate(variant_num = row_number()) |> \n    pivot_longer(-variant_num, names_to = \"idx_order\") |> \n    mutate(idx_order = as.integer(factor(idx_order))) |> \n    arrange(variant_num, idx_order) |> \n    summarize(value = list(value), .by = variant_num)\n}) |> \n  enframe(name = \"floating_n\", value = \"substitutions\")\n```\n:::\n\n\n\n\nFor each mask, attach all possible digit variants and compute the new mask:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmask_new <- masks |> \n  mutate(mask = str_split(mask, \"\")) |> \n  left_join(variants, join_by(floating_n)) |> \n  unnest(substitutions) |> \n  mutate(\n    mask_new = pmap(lst(mask, floating_idx, value), ~ replace(..1, ..2, ..3)),\n    mask_new = map2(mask, mask_new, \\(orig, new) {\n      case_match(orig, \"0\" ~ \"X\", \"1\" ~ \"1\", \"X\" ~ new)\n    }),\n    across(c(mask, mask_new), \\(col) map_chr(col, str_flatten))\n  ) |> \n  distinct(mask, mask_new)\n```\n:::\n\n\n\n\nRe-attach the new location masks to the original dataset. Apply the mask to each location to get the new location values, then take the last value written to each location and sum.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  left_join(mask_new, join_by(mask)) |> \n  mutate(loc_masked = mask_int(loc, mask_new)) |> \n  summarize(value = last(value), .by = loc_masked) |> \n  pull(value) |> \n  sum()\n```\n:::\n",
    "supporting": [
      "day14_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}