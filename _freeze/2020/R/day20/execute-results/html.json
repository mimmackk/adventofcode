{
  "hash": "41c67231b2e22308a7c15a3357dadc3f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 20\"\ndate: 2020-12-20\nauthor:\n  name: https://adventofcode.com/2020/day/20\n  url: https://adventofcode.com/2020/day/20\nexecute:\n  eval: true\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(stringi)\n```\n:::\n\n\n\n\nDisable scientific notation:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(scipen = 999)\n```\n:::\n\n\n\n\nRead text input from file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day20.txt\", skip_empty_rows = TRUE)\n```\n:::\n\n\n\n\nConvert text input into a list of tiles represented as matrices:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntiles <- input |> \n  enframe(name = NULL) |> \n  mutate(tile_id = as.numeric(str_extract(value, \"\\\\d+\"))) |> \n  fill(tile_id, .direction = \"down\") |> \n  filter(!str_starts(value, \"Tile\")) |> \n  summarize(mtx = list(unlist(str_split(value, \"\"))), .by = tile_id) |> \n  mutate(mtx = map(mtx, ~ matrix(.x, byrow = TRUE, nrow = sqrt(length(.x)))))\n```\n:::\n\n\n\n\nDefine a helper function to flip a matrix horizontally:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflip_mtx <- \\(mtx) t(apply(mtx, MARGIN = 1, FUN = rev))\n```\n:::\n\n\n\n\nDefine a helper function to rotate a matrix counterclockwise in multiples of 90 degrees:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrotate_mtx <- \\(mtx, deg = 90) {\n  reduce(\n    .x = seq(length.out = (deg %% 360 / 90)), \n    .f = \\(x, y) apply(t(x), 2, rev), \n    .init = mtx\n  )\n}\n```\n:::\n\n\n\n\n## Part 1\n\nExtract each of the 4 borders from all tiles:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nborders <- tiles |> \n  mutate(\n    b1 = map_chr(mtx, ~ .x |>        head(1) |> str_flatten()),\n    b2 = map_chr(mtx, ~ .x |> t() |> tail(1) |> str_flatten()),\n    b3 = map_chr(mtx, ~ .x |>        tail(1) |> str_flatten()),\n    b4 = map_chr(mtx, ~ .x |> t() |> head(1) |> str_flatten()),\n  ) |> \n  pivot_longer(\n    c(b1, b2, b3, b4), \n    names_to = \"border_dir\", \n    names_prefix = \"b\",\n    names_transform = as.integer,\n    values_to = \"border\"\n  )\n```\n:::\n\n\n\n\nDetermine which borders match with one another:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnbrs <- cross_join(borders, borders, suffix = c(\"\", \"_nbr\")) |> \n  select(-c(mtx, mtx_nbr)) |> \n  filter(\n    tile_id != tile_id_nbr,\n    (border == border_nbr | border == stri_reverse(border_nbr))\n  )\n```\n:::\n\n\n\n\nConfirm that each tile border matched with at most one other:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnbrs |> \n  filter(n() > 1, .by = c(tile_id, border_dir)) |> \n  nrow() |> \n  case_match(0 ~ \"PASS\", .default = \"FAIL\")\n```\n:::\n\n\n\n\nPull the list of corner tiles (those with only two matched borders):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncorners <- nbrs |> \n  summarize(n_matches = n(), .by = tile_id) |> \n  filter(n_matches == 2) |> \n  pull(tile_id)\n```\n:::\n\n\n\n\nMultiply together the IDs of the corners:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprod(corners)\n```\n:::\n\n\n\n\n## Part 2\n\nPick one corner to place in the upper left of the grid (row 1, col 1) and set the common orientation for the rest of the tiles. Here, we choose the minimum corner index:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nopposite_dir <- (1:4 + 1) %% 4 + 1\n\ninit <- nbrs |> \n  filter(tile_id == min(corners)) |> \n  summarize(\n    row = 1,\n    col = 1,\n    dir_s = max(border_dir),\n    dir_e = min(border_dir),\n    dir_n = opposite_dir[dir_s],\n    dir_w = opposite_dir[dir_e],\n    .by = tile_id\n  ) |> \n  select(tile_id, row, col, dir_n, dir_e, dir_s, dir_w)\n```\n:::\n\n\n\n\nNow, we get the column order of the rest of the tiles in the first row by iteratively attaching them one-by-one and filling in their N/E/S/W directions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncur   <- init\nn_prv <- 0\n\nwhile(nrow(cur) != n_prv) {\n  \n  n_prv <- nrow(cur)\n  \n  cur <- cur |>\n    left_join(nbrs, join_by(tile_id)) |> \n    filter(!(tile_id_nbr %in% tile_id) & border_dir == dir_e) |> \n    transmute(\n      tile_id = tile_id_nbr,\n      row = row,\n      col = col + 1,\n      dir_w = border_dir_nbr,\n      dir_e = opposite_dir[border_dir_nbr]\n    ) |> \n    left_join(nbrs, join_by(tile_id)) |> \n    filter(border_dir != dir_w, border_dir != dir_e) |> \n    mutate(\n      dir_s = border_dir,\n      dir_n = opposite_dir[border_dir]\n    ) |> \n    distinct(tile_id, row, col, dir_n, dir_e, dir_s, dir_w) |> \n    bind_rows(cur)\n}\n\nfirst_row <- cur\n```\n:::\n\n\n\n\nNow that our first row is ordered and oriented, we attach and orient each of the following sets of rows, one full row at a time:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncur <- first_row\nn_prv <- 0\n\nwhile(nrow(cur) != n_prv) {\n  \n  n_prv <- nrow(cur)\n  \n  nxt <- cur |>\n    left_join(nbrs, join_by(tile_id)) |> \n    filter(!(tile_id_nbr %in% tile_id) & border_dir == dir_s) |> \n    transmute(\n      tile_id = tile_id_nbr,\n      row = row + 1,\n      col = col,\n      dir_n = border_dir_nbr,\n      dir_s = opposite_dir[border_dir_nbr]\n    ) \n  \n  cur <- nxt |> \n    left_join(nbrs, join_by(tile_id)) |> \n    filter(border_dir != dir_n, border_dir != dir_s) |> \n    \n    select(-c(border, border_nbr)) |> \n    left_join(\n      select(nxt, tile_id, col_nbr = col), \n      join_by(x$tile_id_nbr == y$tile_id)\n    ) |> \n    mutate(\n      dir_w = if_else(col_nbr == col - 1, border_dir, opposite_dir[border_dir]),\n      dir_e = opposite_dir[dir_w]\n    ) |> \n    distinct(tile_id, row, col, dir_n, dir_e, dir_s, dir_w) |> \n    bind_rows(cur)\n}\n\norientations <- cur\n```\n:::\n\n\n\n\nConvert the completed N/S/E/W alignment mapping into a set of flip & rotation instructions, then apply the transformation to each tile:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransformation <- orientations |> \n  left_join(tiles, join_by(tile_id)) |> \n  mutate(\n    flip = (dir_n == (dir_e %% 4 + 1)),\n    rotate = if_else(flip, ((5 - dir_n) %% 4) * 90, (dir_n - 1) * 90),\n    mtx = if_else(flip, map(mtx, flip_mtx), mtx),\n    mtx = map2(mtx, rotate, rotate_mtx)\n  ) \n```\n:::\n\n\n\n\nTrim the borders of each tile and merge into one large image:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimage <- transformation |> \n  arrange(row, col) |> \n  mutate(mtx = map(mtx, ~ .x[2:(nrow(.x) - 1), 2:(ncol(.x) - 1)])) |> \n  summarize(mtx = list(do.call(cbind, mtx)), .by = row) |> \n  summarize(mtx = list(do.call(rbind, mtx))) |> \n  pull(mtx) |> \n  pluck(1)\n```\n:::\n\n\n\n\nConvert the sea monster text into a set of matrix indices requiring a '\\#' character:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonster <- str_c(\n  \"                  # \",\n  \"#    ##    ##    ###\",\n  \" #  #  #  #  #  #   \"\n) |> \n  str_split_1(\"\") |> \n  matrix(byrow = TRUE, nrow = 3)\n\nmonster_idx <- which(monster == '#')\n```\n:::\n\n\n\n\nGenerate the coordinates for all `monster_width` by `monster_height` submatrices of the image:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubmatrix_coords <- expand_grid(\n  row = map(1:(nrow(image) - nrow(monster) + 1), ~ .x:(nrow(monster) + .x - 1)),\n  col = map(1:(ncol(image) - ncol(monster) + 1), ~ .x:(ncol(monster) + .x - 1))\n)\n```\n:::\n\n\n\n\nGenerate all rotated & flipped variants of the image:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvariants <- expand_grid(\n  flip = c(FALSE, TRUE),\n  rotate = c(0, 90, 180, 270)\n) |> \n  mutate(\n    variant_id = row_number(),\n    mtx = rep(list(image), max(variant_id)),\n    mtx = if_else(flip, map(mtx, flip_mtx), mtx),\n    mtx = map2(mtx, rotate, rotate_mtx)\n  )\n```\n:::\n\n\n\n\nScan all submatrices of all variants and locate the indices of the sea monsters:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonster_locn <- variants |> \n  cross_join(submatrix_coords) |> \n  mutate(\n    subimg = pmap(lst(mtx, row, col), ~ ..1[..2, ..3]),\n    idx = map(subimg, ~ which(.x == '#')),\n    is_monster = map_lgl(idx, ~ length(setdiff(monster_idx, .x)) == 0)\n  ) |> \n  filter(is_monster)\n```\n:::\n\n\n\n\nConvert the indicies of the monster '#' in the submatrix to the full image:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonster_idx_img <- monster_locn |> \n  mutate(\n    monster_idx = pmap(lst(mtx, row, col), \\(mtx, rows, cols) {\n      ((monster_idx - 1) %/% nrow(monster) + min(cols) - 1) * nrow(mtx) +\n      ((monster_idx - 1) %%  nrow(monster) + min(rows))\n    })\n  ) |> \n  pull(monster_idx) |> \n  unlist()\n```\n:::\n\n\n\n\nPull the indices of all '#' in the full image, minus those of the monsters, and count the remaining values:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimg_rotated <- monster_locn |> \n  pull(mtx) |> \n  pluck(1)\n\nwhich(img_rotated == '#') |> \n  setdiff(monster_idx_img) |> \n  length()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}