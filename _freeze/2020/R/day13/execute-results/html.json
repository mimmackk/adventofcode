{
  "hash": "30491157555da601927083cd49d459e0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 13\"\ndate: 2020-12-13\nauthor:\n  name: https://adventofcode.com/2020/day/13\n  url: https://adventofcode.com/2020/day/13\nexecute:\n  eval: true\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(numbers)\nlibrary(bit64)\n```\n:::\n\n\n\n\nDisable scientific formatting when displaying large numbers:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(scipen = 999)\n```\n:::\n\n\n\n\nRead text input from file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day13.txt\")\n```\n:::\n\n\n\n\nSeparate text input into the core timestamp and the bus list:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntimestamp <- input[[1]] |> as.numeric()\nbus <- input[[2]] |> str_split_1(\",\")\n```\n:::\n\n\n\n\n## Part 1\n\nUsing only the non-x values on the bus list, find the earliest departure of each bus on or after our estimated departure time:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbus_valid <- bus |> \n  discard(~ .x == \"x\") |> \n  as.numeric()\n\ndepartures <- ceiling(timestamp / bus_valid) * bus_valid\n```\n:::\n\n\n\n\nMultiply the wait time for the earliest bus by its ID:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(min(departures) - timestamp) * bus_valid[which.min(departures)]\n```\n:::\n\n\n\n\n## Part 2\n\nConvert the input into a bus schedule. This schedule can be expressed as a system of modular equations. Using the provided example:\n\n$$\n\\begin{cases}\nt + 0 = 7n_1  \\\\\nt + 1 = 13n_2 \\\\\nt + 4 = 59n_3 \\\\\nt + 6 = 31n_4 \\\\\nt + 7 = 19n_5\n\\end{cases} \n\\quad\\rightarrow\\quad\n\\begin{cases}\nt \\equiv  0 &\\pmod{7}  \\\\\nt \\equiv -1 &\\pmod{13} \\\\\nt \\equiv -4 &\\pmod{59} \\\\\nt \\equiv -6 &\\pmod{31} \\\\\nt \\equiv -7 &\\pmod{19}\n\\end{cases}\n$$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nschedule <- bus |>\n  enframe(name = NULL, value = \"bus\") |>\n  mutate(time = row_number() - 1) |>\n  filter(bus != \"x\") |>\n  mutate(\n    bus = as.integer(bus),\n    remainder = (bus - time) %% bus\n  )\n```\n:::\n\n\n\n\nWe can use the Chinese Remainder Theorem (CRT) to solve this system of equations. However, we must first confirm that all our bus numbers are relatively prime to one another:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrossing(bus1 = schedule$bus, bus2 = schedule$bus) |> \n  filter(bus1 < bus2) |> \n  mutate(is_coprime = map2_lgl(bus1, bus2, coprime)) |> \n  pull(is_coprime) |> \n  all()\n```\n:::\n\n\n\n\nOur bus numbers are relatively prime. Now, we leverage the CRT to compute $t$. The function `chinese` in the `numbers` package works on small examples, but it does not work for large integers, so we adjust this implementation to work with bigints (`integer64`).\n\nFirst, we define a multiplicative modular inverse function that will work with int64 inputs:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodinv64 <- function(a, n) {\n  \n  cur <- lst(t = 0, r = n)\n  nxt <- lst(t = 1, r = a)\n  \n  while (nxt$r != 0) {\n      prv <- cur\n      cur <- nxt\n      \n      quo <- prv$r %/% cur$r\n      nxt <- map2(prv, cur, \\(prv, cur) prv - quo * cur)\n  }\n  \n  r <- cur$r\n  t <- cur$t\n\n  if (r > 1)\n      NA\n  else if (t < 0)\n      t + n\n  else\n      t\n}\n```\n:::\n\n\n\n\nNext, we define a CRT function that converts its inputs to int64s and executes the CRT algorithm:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrt64 <- function(a, m) {\n  \n  a <- as.integer64(a)\n  m <- as.integer64(m)\n  \n  M <- prod(m)\n  x <- pmap_vec(lst(a, m, n = M / m), \\(a, m, n) {\n    a * n * modinv64(n, m)\n  })\n  \n  sum(x) %% M\n}\n```\n:::\n\n\n\n\nFinally, we run the CRT on our input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrt64(schedule$remainder, schedule$bus)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}