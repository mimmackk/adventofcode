{
  "hash": "07a64fef1673cd1a5aaf4df06732a976",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 12\"\ndate: 2024-12-12\nauthor:\n  name: https://adventofcode.com/2024/day/12\n  url: https://adventofcode.com/2024/day/12\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file into a data frame\ninput <- read_table(\"../input/day12.txt\", col_names = \"chr\") |> \n  mutate(\n    row = row_number(),\n    chr = str_split(chr, \"\")\n  ) |> \n  unnest(chr) |> \n  mutate(col = row_number(), .by = row) |> \n  mutate(idx = row_number(), .before = everything())\n```\n:::\n\n\n\n## Part 1\n\nFormat the input as a graph, with edges connecting neighbors of the same type:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Flag neighboring characters of the same value that border one other\nedges_wide <- input |> \n  mutate(v = case_when(row + 1 == lead(row) ~ lead(idx)), .by = c(chr, col)) |> \n  mutate(h = case_when(col + 1 == lead(col) ~ lead(idx)), .by = c(chr, row))\n\nedges_long <- edges_wide |> \n  pivot_longer(\n    c(v, h), \n    names_to = NULL, \n    values_to = \"target\", \n    values_drop_na = TRUE\n  )\n\n# Format neighbors as a list of edges and add to add a graph\ng <- edges_long |> \n  transmute(\n    edge_id = row_number(),\n    src = idx, \n    target\n  ) |> \n  pivot_longer(c(src, target)) |> \n  arrange(edge_id, value) |> \n  pull(value) |> \n  make_graph(n = nrow(input), directed = FALSE)\n\nV(g)$name <- 1:nrow(input)\n\n# Separate out the resulting graph into sub-graphs of innerconnected regions\ndg <- decompose(g)\n```\n:::\n\n\n\nCompute the perimeter, area, and cost of each subgraph then sum the total:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndg |> \n  map_int(\\(subgraph) {\n    perim <- sum(4 - degree(subgraph))\n    area  <- gorder(subgraph)\n    perim * area\n  }) |> \n  sum()\n```\n:::\n\n\n\n## Part 2\n\nUsed a hint from reddit: the number of corners is equal to the number of sides.\n\nA plot can have a convex corner or a concave corner.\n\n-   A cell has a convex corner for each pair of adjacent borders\n-   A cell has a concave corner if it has two adjacent cells of its same group, but its diagonal cell between the two has a different group.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get original row/column input and join on the group output from the graph\ngroups <- left_join(\n  input,\n  imap_dfr(dg, \\(g, grp_idx) tibble(grp = grp_idx, idx = V(g)$name)),\n  join_by(idx)\n) |> \n  select(idx, grp, row, col)\n\n# For each of a cell's neighbors, flag if they're in the same group\nneighbors <- groups |> \n  # Get group number of each adjacent cell (N/S/E/W)\n  left_join(transmute(groups, n = grp, row = row + 1, col), join_by(row, col)) |> \n  left_join(transmute(groups, w = grp, col = col + 1, row), join_by(row, col)) |> \n  left_join(transmute(groups, s = grp, row = row - 1, col), join_by(row, col)) |> \n  left_join(transmute(groups, e = grp, col = col - 1, row), join_by(row, col)) |> \n  # Get group number of each diagonal cell (NW/NE/SW/SE)\n  left_join(transmute(groups, nw = grp, row = row + 1, col = col + 1), join_by(row, col)) |> \n  left_join(transmute(groups, ne = grp, row = row + 1, col = col - 1), join_by(row, col)) |> \n  left_join(transmute(groups, sw = grp, row = row - 1, col = col + 1), join_by(row, col)) |> \n  left_join(transmute(groups, se = grp, row = row - 1, col = col - 1), join_by(row, col)) |> \n  select(-c(row, col)) |> \n  # Compare group numbers of adjacent/diagonal cells to the current cell\n  mutate(across(c(n, w, s, e, nw, ne, sw, se), ~ replace_na(.x == grp, FALSE)))\n\n# Compute total number of concave/convex corners for each cell\ncorners <- neighbors |> \n  mutate(\n    convex = (!n & !w) + (!s & !w) + (!s & !e) + (!n & !e),\n    concave = (n & w & !nw) + (s & w & !sw) + (s & e & !se) + (n & e & !ne)\n  )\n```\n:::\n\n\n\nTotal the number of corners per group and multiply by the group's area to get the total cost:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncorners |> \n  summarize(\n    area = n(),\n    num_sides = sum(convex + concave), \n    .by = grp\n  ) |> \n  mutate(cost = area * num_sides) |> \n  pull(cost) |> \n  sum()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}