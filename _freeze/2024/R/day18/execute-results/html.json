{
  "hash": "2639abcede9e2ac7b510077aaeec0d05",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 18\"\ndate: 2024-12-18\nauthor:\n  name: https://adventofcode.com/2024/day/18\n  url: https://adventofcode.com/2024/day/18\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(igraph)\n```\n:::\n\n\n\n\nRead input from file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day18.txt\") |> \n  unglue_data(patterns = \"{col},{row}\", convert = TRUE) |> \n  mutate(byte_num = row_number())\n```\n:::\n\n\n\n\nDefine paramaters -- coordinates can be no more than 70 in any direction:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaxdim <- 70\n```\n:::\n\n\n\n\n## Part 1\n\nFill out the full grid with the provided dimensions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid <- input |> \n  complete(col = 0:maxdim, row = 0:maxdim) |> \n  mutate(id = row_number(), .before = everything()) |> \n  \n  # Define the graph edges (cell borders) between vertices (cells)\n  mutate(edge_w = map2(id, lag(id), ~ c(.x, .y)), .by = row) |> \n  mutate(edge_n = map2(id, lag(id), ~ c(.x, .y)), .by = col)\n```\n:::\n\n\n\n\nDefine the IDs of the start and end vertices:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart <- grid |> \n  filter(row == 0 & col == 0) |> \n  pull(id)\n\nexit <- grid |> \n  filter(row == maxdim & col == maxdim) |> \n  pull(id)\n```\n:::\n\n\n\n\nConvert the grid to a graph and count the steps from the start to the exit:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompute_num_steps <- function(grid, start, exit, num_bytes) {\n\n  grid |> \n    \n    # Flag and remove any graph edges between corrupted cells\n    mutate(corrupted = replace_na(byte_num <= num_bytes, FALSE)) |> \n    mutate(\n      edge_w = case_when(!corrupted & !lag(corrupted) ~ edge_w), \n      .by = row\n    ) |> \n    mutate(\n      edge_n = case_when(!corrupted & !lag(corrupted) ~ edge_n), \n      .by = col\n    ) |> \n    \n    # Pull graph edges\n    select(edge_w, edge_n) |> \n    pivot_longer(everything()) |> \n    pull(value) |> \n    discard(is.null) |> \n    unlist() |> \n    \n    # Convert to a graph\n    make_graph(n = max(grid$id), directed = FALSE) |> \n    \n    # Count the steps from the start to the exit\n    distances(start, exit) |> \n    as.list() |> \n    unlist()\n  \n}\n```\n:::\n\n\n\n\nRun puzzle input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompute_num_steps(grid, start, exit, 1024)\n```\n:::\n\n\n\n\n## Part 2\n\nLoop through different byte values to find the first byte that blocks the path:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Initialize byte counts\nmax_bytes <- max(grid$byte_num, na.rm = TRUE)\nmax_walkable <- 1024\nmin_unwalkable <- max_bytes\nnum_bytes <- round(mean(c(max_walkable, min_unwalkable)))\n\n# Loop through bytes, a half at a time\nwhile (min_unwalkable - max_walkable > 1) {\n  num_steps <- compute_num_steps(grid, start, exit, num_bytes)\n  \n  if (is.infinite(num_steps))\n    min_unwalkable <- num_bytes\n  else \n    max_walkable <- num_bytes\n    \n  num_bytes <- round(mean(c(max_walkable, min_unwalkable)))\n}\n```\n:::\n\n\n\n\nGet the coordinates of the first byte that blocks the path:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid |> \n  filter(byte_num == min_unwalkable) |> \n  mutate(coord = str_c(col, row, sep = \",\")) |> \n  pull(coord)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}