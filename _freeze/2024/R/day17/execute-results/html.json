{
  "hash": "6daf45ec1cbf88c920653b54d57c20eb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 17\"\ndate: 2024-12-17\nauthor:\n  name: https://adventofcode.com/2024/day/17\n  url: https://adventofcode.com/2024/day/17\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(bit64)\n\n# Read input from file\ninput <- read_lines(\"../input/day17.txt\", skip_empty_rows = TRUE) |> \n  unglue_data(patterns = c(\n    \"{label}: {value}\"\n  ))\n```\n:::\n\n\n\n## Part 1\n\nInitialize the machine from the text input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprogram <- input |> \n  filter(label == \"Program\") |> \n  pull(value) |> \n  str_split_1(\",\") |> \n  as.integer()\n\nA <- input |> \n  filter(label == \"Register A\") |> \n  pull(value) |> \n  as.integer()\n\nB <- input |> \n  filter(label == \"Register B\") |> \n  pull(value) |> \n  as.integer()\n\nC <- input |> \n  filter(label == \"Register C\") |> \n  pull(value) |> \n  as.integer()\n\nmachine <- list(program = program, A = A, B = B, C = C, pointer = 0L, output = NULL)\n```\n:::\n\n\n\nDefine machine's helper functions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombo <- function(machine, operand) {\n  case_match(operand,\n    0 ~ 0,\n    1 ~ 1,\n    2 ~ 2,\n    3 ~ 3,\n    4 ~ machine$A,\n    5 ~ machine$B,\n    6 ~ machine$C\n   )\n}\n\nrun_opcode <- function(machine, opcode, operand) {\n  func <- case_match(opcode, \n    0 ~ \"adv\",\n    1 ~ \"bxl\",\n    2 ~ \"bst\",\n    3 ~ \"jnz\",\n    4 ~ \"bxc\",\n    5 ~ \"out\",\n    6 ~ \"bdv\",\n    7 ~ \"cdv\"\n  )\n  \n  get(func)(machine, operand)\n}\n\nrun_machine <- function(machine) {\n  while (machine$pointer < length(machine$program)) {\n    opcode  <- machine$program[machine$pointer + 1]\n    operand <- machine$program[machine$pointer + 2]\n    machine <- run_opcode(machine, opcode, operand)\n  }\n  return(machine$output)\n}\n```\n:::\n\n\n\nNeed to define custom bitwise XOR function to handle very large integers without error:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbitwXor64 <- function(x, y) {\n  x <- as.bitstring(as.integer64(x))\n  y <- as.bitstring(as.integer64(y))\n  \n  base::xor(\n    as.integer(str_split_1(x, \"\")), \n    as.integer(str_split_1(y, \"\"))\n  ) |> \n    as.integer() |> \n    str_c(collapse = \"\") |> \n    structure(class = \"bitstring\") |> \n    as.integer64() |> \n    as.numeric()\n}\n```\n:::\n\n\n\nDefine the opcode functions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadv <- function(machine, operand) {\n  machine$A <- floor(machine$A / 2^combo(machine, operand))\n  machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n\nbxl <- function(machine, operand) {\n  machine$B <- bitwXor64(machine$B, operand)\n  machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n\nbst <- function(machine, operand) {\n  machine$B <- combo(machine, operand) %% 8\n  machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n\njnz <- function(machine, operand) {\n  if (machine$A != 0) \n    machine$pointer <- operand\n  else \n    machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n\nbxc <- function(machine, operand) {\n  machine$B <- bitwXor64(machine$B, machine$C)\n  machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n\nout <- function(machine, operand) {\n  machine$output <- c(\n    machine$output, \n    combo(machine, operand) %% 8\n  )\n  machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n\nbdv <- function(machine, operand) {\n  machine$B <- floor(machine$A / 2^combo(machine, operand))\n  machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n\ncdv <- function(machine, operand) {\n  machine$C <- floor(machine$A / 2^combo(machine, operand))\n  machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n```\n:::\n\n\n\nRun on puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_machine(machine) |> \n  str_c(collapse = \",\")\n```\n:::\n\n\n\n## Part 2\n\nReverse engineer, testing sequences of 3 bits at a time. Thanks to hints from [Reddit](https://www.reddit.com/r/adventofcode/comments/1hg38ah/comment/m2odsfl/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_machine_a <- function(a) run_machine(list(\n  program = program, \n  A = a, \n  B = B, \n  C = C, \n  pointer = 0L, \n  output = NULL\n))\n\nreveng <- function(program, digit = 1, a = 0) {\n  if (digit > length(program))\n    return(a)\n  \n  df <- tibble(candidates = 8 * a + 0:7) |> \n    mutate(\n      output = map(candidates, run_machine_a),\n      output = map(output, head, n = 1)\n    ) |> \n    filter(output == rev(program)[digit]) |> \n    mutate(\n      res = map_dbl(candidates, ~ reveng(program, digit + 1, .x))\n    ) |> \n    filter(!is.na(res))\n  \n  if (nrow(df) == 0) return(Inf)\n  else return(min(df$res))\n}\n\nreveng(program) |> \n  format(scientific = FALSE)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}