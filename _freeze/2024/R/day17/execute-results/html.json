{
  "hash": "1189b9f3ffd6e66d870d14df1cad1b74",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 17\"\ndate: 2024-12-17\nauthor:\n  name: https://adventofcode.com/2024/day/17\n  url: https://adventofcode.com/2024/day/17\n---\n\n\n\n\n## Setup\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput <- read_lines(\"../input/day17.txt\", skip_empty_rows = TRUE) |> \n  unglue_data(patterns = c(\n    \"{label}: {value}\"\n  ))\n```\n:::\n\n\n\n\n## Part 1\n\nInitialize the machine from the text input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprogram <- input |> \n  filter(label == \"Program\") |> \n  pull(value) |> \n  str_split_1(\",\") |> \n  as.integer()\n\nA <- input |> \n  filter(label == \"Register A\") |> \n  pull(value) |> \n  as.integer()\n\nB <- input |> \n  filter(label == \"Register B\") |> \n  pull(value) |> \n  as.integer()\n\nC <- input |> \n  filter(label == \"Register C\") |> \n  pull(value) |> \n  as.integer()\n\nmachine <- list(program = program, A = A, B = B, C = C, pointer = 0L, output = NULL)\n```\n:::\n\n\n\n\nDefine machine's helper functions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombo <- function(machine, operand) {\n  case_match(operand,\n    0 ~ 0,\n    1 ~ 1,\n    2 ~ 2,\n    3 ~ 3,\n    4 ~ machine$A,\n    5 ~ machine$B,\n    6 ~ machine$C\n   )\n}\n\nrun_opcode <- function(machine, opcode, operand) {\n  func <- case_match(opcode, \n    0 ~ \"adv\",\n    1 ~ \"bxl\",\n    2 ~ \"bst\",\n    3 ~ \"jnz\",\n    4 ~ \"bxc\",\n    5 ~ \"out\",\n    6 ~ \"bdv\",\n    7 ~ \"cdv\"\n  )\n  \n  get(func)(machine, operand)\n}\n\nrun_machine <- function(machine) {\n  while (machine$pointer < length(machine$program)) {\n    opcode  <- machine$program[machine$pointer + 1]\n    operand <- machine$program[machine$pointer + 2]\n    machine <- run_opcode(machine, opcode, operand)\n  }\n  print(machine$output)\n}\n```\n:::\n\n\n\n\nDefine the opcode functions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadv <- function(machine, operand) {\n  machine$A <- floor(machine$A / 2^combo(machine, operand))\n  machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n\nbxl <- function(machine, operand) {\n  machine$B <- bitwXor(machine$B, operand)\n  machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n\nbst <- function(machine, operand) {\n  machine$B <- combo(machine, operand) %% 8\n  machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n\njnz <- function(machine, operand) {\n  if (machine$A != 0) \n    machine$pointer <- operand\n  else \n    machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n\nbxc <- function(machine, operand) {\n  machine$B <- bitwXor(machine$B, machine$C)\n  machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n\nout <- function(machine, operand) {\n  machine$output <- str_c(\n    machine$output, \n    combo(machine, operand) %% 8, \n    sep = \",\"\n  )\n  machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n\nbdv <- function(machine, operand) {\n  machine$B <- floor(machine$A / 2^combo(machine, operand))\n  machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n\ncdv <- function(machine, operand) {\n  machine$C <- floor(machine$A / 2^combo(machine, operand))\n  machine$pointer <- machine$pointer + 2\n  return(machine)\n}\n```\n:::\n\n\n\n\nRun on puzzle input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_machine(machine)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"3,1,4,3,1,7,1,6,3\"\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}