{
  "hash": "19510fa8e38225f5a697a633b0a99a8e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 10\"\ndate: 2024-12-10\nauthor:\n  name: https://adventofcode.com/2024/day/10\n  url: https://adventofcode.com/2024/day/10\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\nRead plaintext input from file: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day10.txt\")\n```\n:::\n\n\n\n\nConvert text input into a numeric matrix:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtx <- input |> \n  str_split(\"\") |>\n  unlist() |> \n  as.integer() |> \n  matrix(nrow = length(input), byrow = TRUE)\n```\n:::\n\n\n\n\n\n## Part 1\n\nDefine cardinal directions (N/S/E/W) as a list of 2D vectors:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndirs <- list(c(0, 1), c(0, -1), c(1, 0), c(-1, 0))\n```\n:::\n\n\n\n\nDefine a helper function to determine if a coordinate is within the map bounds:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nin_bounds <- \\(x, map) between(x[1], 1, nrow(map)) & between(x[2], 1, ncol(map))\n```\n:::\n\n\n\n\nDefine a function to find the trail ends given a map and a starting coordinate:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfind_trail_ends <- function(cur_coord, map) {\n  \n  # If the trailhead has been reached, return its coordinate.\n  if (map[cur_coord] == 9)\n    return(list(cur_coord))\n  \n  # Define the possible next steps within the map bounds\n  next_steps <- dirs |> \n    map(~ cur_coord + .x) |> \n    keep(~ in_bounds(.x, map))\n  \n  trail_ends <- list()\n  \n  # If the next step leads to a valid path, add its terminal to the list\n  for (next_coord in next_steps) {\n    if (map[next_coord] == map[cur_coord] + 1) \n      trail_ends <- c(trail_ends, find_trail_ends(next_coord, map))\n  }\n  \n  return(unique(trail_ends))\n}\n```\n:::\n\n\n\n\nDefine a function to score a trail given the map and trailhead:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscore_trail <- \\(trailhead, map) length(find_trail_ends(trailhead, map))\n```\n:::\n\n\n\n\nGet a list of coordinates of all of the trailheads:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrailheads <- which(mtx == 0, arr.ind = TRUE)\n\ntrailheads_list <- map(\n  1:nrow(trailheads), \n  ~ array(trailheads[.x,], dim = c(1, 2))\n)\n```\n:::\n\n\n\n\nScore each trailhead and sum the total:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrailheads_list |> \n  map_int(~ score_trail(.x, mtx)) |> \n  sum()\n```\n:::\n\n\n\n\n## Part 2\n\nModify the trail rating function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrate_trail <- function(cur_coord, map) {\n  # If the trailhead has been reached, increment the score and exit.\n  if (map[cur_coord] == 9)\n    return(1)\n  \n  # Define the possible next steps within the map bounds\n  next_steps <- dirs |> \n    map(~ cur_coord + .x) |> \n    keep(~ in_bounds(.x, map))\n  \n  # Sum the trail ratings of all valid next steps\n  map_int(\n    next_steps,\n    ~ if (map[.x] == map[cur_coord] + 1) rate_trail(.x, map) else 0\n  ) |> \n    sum()\n}\n```\n:::\n\n\n\n\nRe-run on the puzzle input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrailheads_list |> \n  map_int(~ rate_trail(.x, mtx)) |> \n  sum()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}