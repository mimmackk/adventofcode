{
  "hash": "5819b339c7abc24bbd0d01ad54c924f4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 10\"\ndate: 2024-12-10\nauthor:\n  name: https://adventofcode.com/2024/day/10\n  url: https://adventofcode.com/2024/day/10\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput <- read_lines(\"../input/day10.txt\", skip_empty_rows = TRUE)\n\n# Convert input to matrix format\nmtx <- input |> \n  str_split(\"\") |>\n  unlist() |> \n  as.integer() |> \n  matrix(nrow = length(input), byrow = TRUE)\n```\n:::\n\n\n\n## Part 1\n\nDefine custom functions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# North / South / East / West\ndirs <- list(c(0,  1), c(0, -1), c(1,  0), c(-1,  0))\n\n# Check if a coordinate is in the bounds of the map\nin_bounds <- function(x, map) {\n  between(x[1], 1, nrow(map)) & between(x[2], 1, ncol(map))\n}\n\nfind_trail_ends <- function(cur_coord, map) {\n  \n  # If the trailhead has been reached, return its coordinate.\n  if (map[cur_coord] == 9)\n    return(list(cur_coord))\n  \n  # Define the possible next steps within the map bounds\n  next_steps <- dirs |> \n    map(~ cur_coord + .x) |> \n    keep(~ in_bounds(.x, map))\n  \n  trail_ends <- list()\n  \n  # If the next step leads to a valid path, add its terminal to the list\n  for (next_coord in next_steps) {\n    if (map[next_coord] == map[cur_coord] + 1) \n      trail_ends <- c(trail_ends, find_trail_ends(next_coord, map))\n  }\n  \n  return(unique(trail_ends))\n}\n\nscore_trail <- function(trailhead, map) length(find_trail_ends(trailhead, map))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get a list of coordinates of all of the trailheads\ntrailheads <- which(mtx == 0, arr.ind = TRUE)\ntrailheads_list <- map(\n  1:nrow(trailheads), \n  ~ array(trailheads[.x,], dim = c(1, 2))\n)\n\n# Score each trailhead and sum the total\ntrailheads_list |> \n  map_int(~ score_trail(.x, mtx)) |> \n  sum()\n```\n:::\n\n\n\n## Part 2\n\nModify the trail rating function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrate_trail <- function(cur_coord, map) {\n  # If the trailhead has been reached, increment the score and exit.\n  if (map[cur_coord] == 9)\n    return(1)\n  \n  # Define the possible next steps within the map bounds\n  next_steps <- dirs |> \n    map(~ cur_coord + .x) |> \n    keep(~ in_bounds(.x, map))\n  \n  # Sum the trail ratings of all valid next steps\n  map_int(\n    next_steps,\n    ~ if (map[.x] == map[cur_coord] + 1) rate_trail(.x, map) else 0\n  ) |> \n    sum()\n}\n```\n:::\n\n\n\nRe-run the puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrailheads_list |> \n  map_int(~ rate_trail(.x, mtx)) |> \n  sum()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}