{
  "hash": "997466c5f3bf11d8430a2641dab2add4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 24\"\ndate: 2024-12-24\nauthor:\n  name: https://adventofcode.com/2024/day/24\n  url: https://adventofcode.com/2024/day/24\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(unglue)\n```\n:::\n\n\n\n\nDisable scientific formatting when displaying large numbers:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(scipen = 999)\n```\n:::\n\n\n\n\nRead input from file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day24.txt\", skip_empty_rows = TRUE)\n```\n:::\n\n\n\n\n## Part 1\n\nConvert input to lists of gates and wires:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninit <- input |> \n  unglue_data(\"{wire}: {value}\", convert = TRUE) |> \n  filter(!is.na(wire))\n\ngates <- input |> \n  unglue_data(\"{src1} {gate} {src2} -> {target}\") |> \n  filter(!is.na(gate)) |> \n  mutate(gate = case_match(gate, \"AND\" ~ \"&\", \"OR\" ~ \"|\", \"XOR\" ~ \"xor\"))\n\nwires <- init |> \n  complete(wire = unique(c(gates$src1, gates$src2, gates$target))) |> \n  deframe()\n```\n:::\n\n\n\n\nLoop through the lists of gates and wires, and whenever a new gate can be activated, get its resulting value. Repeat until all wires have a final output.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- wires |> \n  enframe(name = \"wire\") |>\n  left_join(gates, join_by(wire == target))\n\nrepeat {\n\n  cur_values <- df |> \n    select(wire, value) |> \n    deframe()\n  \n  df <- df |> \n    mutate(\n      val1 = cur_values[src1], \n      val2 = cur_values[src2],\n      value = coalesce(\n        value,\n        pmap_int(list(gate, val1, val2), \\(gate, val1, val2) {\n          if (!is.na(gate) & !is.na(val1) & !is.na(val2))\n            get(gate)(val1, val2)\n          else \n            NA_integer_\n        })\n      )\n    )\n  \n  if (all(!is.na(df$value))) break\n}\n```\n:::\n\n\n\n\nConvert the Z-coded wires to a binary number:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  filter(str_starts(wire, \"z\")) |> \n  arrange(wire) |> \n  pull(value) |> \n  imap_dbl(\\(x, i) x * 2^(i - 1)) |> \n  sum()\n```\n:::\n\n\n\n\n## Part 2\n\nThanks to hint from Reddit: this method of binary addition using only AND, OR, XOR gates without negation is a \"ripple-carry adder.\"\n\nThe gates follow a consistent algorithm, where \"Z\" digits are the final output digits, and \"C\" values are carried over to the next digit:\n\n```         \n\nSTEP 00: \n\nZ00 = X00 XOR Y00  (Final output: Z00)\n\nC01 = X00 AND Y00  (Carry forward to next step)\n\nSTEP 01: \n\nZ01A = X01  XOR Y01  (Intermediate step)\nZ01  = Z01A XOR C01  (Final output: Z01)\n\nC02A = X01  AND Y01  (Intermediate step)\nC02B = Z01A AND C01  (Intermediate step)\nC02  = C02A OR  C02B (Carry forward to next step)\n\n(...)\n\nC44  = C44A OR C44B  (Carry forward to next step)\n\nSTEP 44:\n\nZ44A = X44  XOR Y44  (Intermediate step)\nZ44  = Z44A XOR C44  (Final output: Z45)\n\nC45A = X44  AND Y44  (Intermediate step)\nC45B = Z44A AND C44  (Intermediate step)\nC45  = C45A OR  C45B (No further steps to carry over. Set as final output: Z45)\n```\n\nWe can compare the expected versus actual logic to find steps that don't match this algorithm.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pull lists of all wires of x, y, z, and other types for quick reference\nnlist <- discard(names(wires), ~ str_starts(.x, \"x|y|z\"))\nxlist <- keep(names(wires), ~ str_starts(.x, \"x\"))\nylist <- keep(names(wires), ~ str_starts(.x, \"y\"))\nzlist <- keep(names(wires), ~ str_starts(.x, \"z\"))\nxylist <- c(xlist, ylist)\nzmax  <- max(zlist)\n\n# Put source gates in alphabetical order for easier comparison\ngates <- gates |> \n  mutate(src = map2(src1, src2, ~ sort(c(.x, .y)))) |> \n  select(-c(src1, src2)) |> \n  unnest_wider(src, names_sep = \"\")\n```\n:::\n\n\n\n\nPull invalid outputs according to their gate type and inputs:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninvalid_by_gate <- gates |> \n  pmap_lgl(\\(gate, target, src1, src2) {\n    case_when(\n      # All z-target cases:\n      target == \"z00\"   ~ src1 == \"x00\" & src2 == \"y00\" & gate == \"xor\",\n      target == zmax    ~ src1 %in% nlist & src2 %in% nlist & gate == \"|\",\n      target %in% zlist ~ src1 %in% nlist & src2 %in% nlist & gate == \"xor\",\n      # N-target cases by gate type:\n      gate == \"xor\" ~ src1 %in% xylist & src2 %in% xylist,\n      gate == \"|\"   ~ src1 %in% nlist  & src2 %in% nlist\n    )\n  }) |> \n  set_names(gates$target) |> \n  keep(~ !is.na(.x) & .x == FALSE) |> \n  names()\n```\n:::\n\n\n\n\nIdentify invalid outputs by following their logic trail forward and checking the gate types of the logic they are used as later input for:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninvalid_by_path <- gates |> \n  left_join(\n    select(gates, src1, gate), \n    join_by(x$target == y$src1), \n    suffix = c(\"\", \"1\")\n  ) |> \n  left_join(\n    select(gates, src2, gate), \n    join_by(x$target == y$src2), \n    suffix = c(\"\", \"2\")\n  ) |> \n  nest(nxt = c(gate1, gate2), .by = -c(gate1, gate2)) |> \n  mutate(nxt = map(nxt, ~ .x |> unlist() |> discard(is.na) |> unname())) |> \n  unnest_wider(nxt, names_sep = \"_\") |> \n  mutate(\n    valid = case_when(\n      target %in% zlist \n        ~ NA,\n      gate == \"xor\" \n        ~ nxt_1 %in% c(\"xor\", \"&\") & \n          nxt_2 %in% c(\"xor\", \"&\") & \n          nxt_1 != nxt_2 & \n          !is.na(nxt_1) & \n          !is.na(nxt_2),\n      gate == \"|\" \n        ~ nxt_1 %in% c(\"xor\", \"&\") & \n          nxt_2 %in% c(\"xor\", \"&\") & \n          nxt_1 != nxt_2 & \n          !is.na(nxt_1) & \n          !is.na(nxt_2),\n      gate == \"&\" & !(src1 %in% c(\"x00\", \"y00\"))\n        ~ nxt_1 == \"|\" | nxt_2 == \"|\"\n    )\n  ) |> \n  filter(!valid) |> \n  pull(target)\n```\n:::\n\n\n\n\nConcatenate all invalid gates alphabetically:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(invalid_by_gate, invalid_by_path) |> \n  unique() |> \n  sort() |> \n  str_flatten(\",\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}