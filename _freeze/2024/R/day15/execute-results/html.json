{
  "hash": "da65cd066eedd1b1b4f857511ed7322e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 15\"\ndate: 2024-12-15\nauthor:\n  name: https://adventofcode.com/2024/day/15\n  url: https://adventofcode.com/2024/day/15\n---\n\n\n\n\n## Setup\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput <- read_lines(\"../input/day15.txt\")\ninput_wh <- keep(input, ~ str_detect(.x, \"#\"))\ninput_mv <- keep(input, ~ str_detect(.x, \"<|>|\\\\^|v\"))\n```\n:::\n\n\n\n\n## Part 1\n\n\n\n\n\n\n\n\n\nConvert warehouse input to a row/column indexed dataframe\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert WH input text to a matrix\nmtx <- input_wh |>\n  str_split(\"\") |> \n  matrix() |> \n  unlist() |> \n  matrix(byrow = TRUE, nrow = length(input_wh))\n\n\n# Convert movement sequence to a seq of characters\nmove_seq <- input_mv |> \n  str_c(collapse = \"\") |> \n  str_split_1(\"\")\n```\n:::\n\n\n\n\nDefine function to update the map based on a single movement of the robot::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmove_robot <- function(mtx, dir) {\n  # Get the current coordinates of the robot\n  robot <- which(mtx == \"@\", arr.ind = TRUE)\n  row <- robot[1, \"row\"]\n  col <- robot[1, \"col\"]\n  \n  # Define the range of matrix values to adjust according to the movement dir\n  row_end <- case_match(dir, c(\"<\", \">\") ~ row, \"^\" ~ 1, \"v\" ~ nrow(mtx))\n  col_end <- case_match(dir, c(\"^\", \"v\") ~ col, \"<\" ~ 1, \">\" ~ nrow(mtx))\n  \n  # Using obstacle logic, determine the set of new characters\n  new <- tibble(\n    orig = mtx[row:row_end, col:col_end],\n    lag = lag(orig)\n  ) |> \n    mutate(\n      is_empty = orig == \".\",\n      is_wall  = orig == \"#\",\n      is_blocked = accumulate(is_wall, `|`),\n      is_fillable = is_empty & !is_blocked,\n      first_fillable = is_fillable & !lag(accumulate(is_fillable, `|`)),\n      can_move = accumulate(first_fillable, `|`, .dir = \"backward\"),\n      new = if_else(can_move, coalesce(lag, \".\"), orig)\n    ) |> \n    pull(new)\n  \n  # Replace the affected characters in the matrix and return\n  mtx[row:row_end, col:col_end] <- new\n  return(mtx)\n}\n```\n:::\n\n\n\n\nDefine a function to iteratively run the set of movements\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_simulation <- function(mtx, move_seq) {\n  mtx_prv <- mtx\n  for (dir in move_seq) {\n    mtx_new <- move_robot(mtx_prv, dir)\n    mtx_prv <- mtx_new\n  }\n  return(mtx_new)\n}\n```\n:::\n\n\n\n\nDefine a function to determine the GPS coordinates of all boxes\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_boxes_gps <- function(mtx) {\n  which(mtx == \"O\", arr.ind = TRUE) |> \n    as_tibble() |> \n    mutate(\n      gps = 100 * (row - 1) + (col - 1)\n    ) |> \n    pull(gps)\n}\n```\n:::\n\n\n\n\nRun puzzle input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtx |> \n  run_simulation(move_seq) |> \n  get_boxes_gps() |>\n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1457740\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}