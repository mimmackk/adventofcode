{
  "hash": "c578aa95e3f71784a13de4cf642cfcbc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 15\"\ndate: 2024-12-15\nauthor:\n  name: https://adventofcode.com/2024/day/15\n  url: https://adventofcode.com/2024/day/15\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput <- read_lines(\"../input/day15.txt\")\ninput_wh <- keep(input, ~ str_detect(.x, \"#\"))\ninput_mv <- keep(input, ~ str_detect(.x, \"<|>|\\\\^|v\"))\n```\n:::\n\n\n\n## Part 1\n\n\n\n\n\n\n\nConvert warehouse input to a row/column indexed dataframe\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert WH input text to a matrix\nmtx <- input_wh |>\n  str_split(\"\") |> \n  matrix() |> \n  unlist() |> \n  matrix(byrow = TRUE, nrow = length(input_wh))\n\n\n# Convert movement sequence to a seq of characters\nmove_seq <- input_mv |> \n  str_c(collapse = \"\") |> \n  str_split_1(\"\")\n```\n:::\n\n\n\nDefine function to update the map based on a single movement of the robot::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmove_robot <- function(mtx, dir) {\n  # Get the current coordinates of the robot\n  robot <- which(mtx == \"@\", arr.ind = TRUE)\n  row <- robot[1, \"row\"]\n  col <- robot[1, \"col\"]\n  \n  # Define the range of matrix values to adjust according to the movement dir\n  row_end <- case_match(dir, c(\"<\", \">\") ~ row, \"^\" ~ 1, \"v\" ~ nrow(mtx))\n  col_end <- case_match(dir, c(\"^\", \"v\") ~ col, \"<\" ~ 1, \">\" ~ nrow(mtx))\n  \n  # Using obstacle logic, determine the set of new characters\n  new <- tibble(\n    orig = mtx[row:row_end, col:col_end],\n    lag = lag(orig)\n  ) |> \n    mutate(\n      is_empty = orig == \".\",\n      is_wall  = orig == \"#\",\n      is_blocked = accumulate(is_wall, `|`),\n      is_fillable = is_empty & !is_blocked,\n      first_fillable = is_fillable & !lag(accumulate(is_fillable, `|`)),\n      can_move = accumulate(first_fillable, `|`, .dir = \"backward\"),\n      new = if_else(can_move, coalesce(lag, \".\"), orig)\n    ) |> \n    pull(new)\n  \n  # Replace the affected characters in the matrix and return\n  mtx[row:row_end, col:col_end] <- new\n  return(mtx)\n}\n```\n:::\n\n\n\nDefine a function to iteratively run the set of movements\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_simulation <- function(mtx, move_seq) {\n  mtx_prv <- mtx\n  for (dir in move_seq) {\n    mtx_new <- move_robot(mtx_prv, dir)\n    mtx_prv <- mtx_new\n  }\n  return(mtx_new)\n}\n```\n:::\n\n\n\nDefine a function to determine the GPS coordinates of all boxes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_boxes_gps <- function(mtx) {\n  which(mtx == \"O\", arr.ind = TRUE) |> \n    as_tibble() |> \n    mutate(\n      gps = 100 * (row - 1) + (col - 1)\n    ) |> \n    pull(gps)\n}\n```\n:::\n\n\n\nRun puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtx |> \n  run_simulation(move_seq) |> \n  get_boxes_gps() |>\n  sum()\n```\n:::\n\n\n\n## Part 2\n\nWiden the map:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert WH input text to a matrix\nmtx <- input_wh |> \n  str_replace_all(\"#\", \"##\") |> \n  str_replace_all(\"O\", \"[]\") |> \n  str_replace_all(\"\\\\.\", \"..\") |> \n  str_replace_all(\"@\", \"@.\") |>\n  str_split(\"\") |> \n  matrix() |> \n  unlist() |> \n  matrix(byrow = TRUE, nrow = length(input_wh))\n```\n:::\n\n\n\nDefine functions to move boxes around the map:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_box_coords <- function(mtx, box_num) {\n  as_tibble(which(mtx == box_num, arr.ind = TRUE))\n}\n\nget_next_coords <- function(cur_coords, dir = c(\"<\", \"^\", \">\", \"v\")) {\n  cur_coords |>\n    mutate(\n      row = row + case_match(dir, \"^\" ~ -1, \"v\" ~ 1, .default = 0),\n      col = col + case_match(dir, \"<\" ~ -1, \">\" ~ 1, .default = 0),\n    )\n}\n\nget_next_chrs <- function(mtx, cur_coords, dir = c(\"<\", \"^\", \">\", \"v\")) {\n  # Pull the values of the next cells in the intended direction\n  cur_coords |>\n    get_next_coords(dir) |> \n    mutate(chr = map2_chr(row, col, ~ mtx[.x, .y])) |> \n    anti_join(cur_coords, join_by(row, col)) |> \n    pull(chr) |> \n    unique()\n}\n\nis_blocked <- function(mtx, box_num, dir = c(\"<\", \"^\", \">\", \"v\")) {\n  \n  cur <- get_box_coords(mtx, box_num)\n  nxt_chrs <- get_next_chrs(mtx, cur, dir)\n  \n  # Test if the current box is completely blocked or completely free\n  if (any(nxt_chrs == '#')) \n    return(TRUE)\n  else if (all(nxt_chrs == '.')) \n    return(FALSE)\n  \n  # Recurse across all later boxes \n  nxt_chrs |> \n    keep(~ str_detect(.x, \"^\\\\d+$\")) |> \n    map_lgl(~ is_blocked(mtx, .x, dir)) |> \n    any()\n}\n\nmove_box <- function(mtx, box_num, dir = c(\"<\", \"^\", \">\", \"v\")) {\n  # Get the coordinates of the current box and the place it'll move to\n  cur <- get_box_coords(mtx, box_num)\n  nxt <- get_next_coords(cur, dir)\n  \n  # Move all downstream boxes before moving self\n  next_boxes <- get_next_chrs(mtx, cur, dir) |> \n    keep(~ str_detect(.x, \"^\\\\d+$\"))\n  \n  for (box in next_boxes) {\n    mtx <- move_box(mtx, box, dir)\n  }\n  \n  # # Replace the current coords with \".\" and the next coords with the box\n  mtx[cur$row, cur$col] <- \".\"\n  mtx[nxt$row, nxt$col] <- box_num\n  \n  return(mtx)\n}\n```\n:::\n\n\n\nLoop through puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_simulation <- function(mtx, move_seq) {\n  # Convert boxes from format \"[]\" into ID numbers unique to each box:\n  coords <- list(l = which(mtx == \"[\"), r = which(mtx == \"]\"))\n  for (i in 1:length(coords$l)) {\n    mtx[coords$l[i]] <- i\n    mtx[coords$r[i]] <- i\n  }\n\n  # Loop through sequence of moves and apply to the map\n  mtx_prv <- mtx\n  for (dir in move_seq) {\n    if (!is_blocked(mtx_prv, box_num = \"@\", dir = dir)) {\n      mtx_new <- move_box(mtx_prv, box_num = \"@\", dir = dir)\n      mtx_prv <- mtx_new\n    } \n  }\n  \n  return(mtx_new)\n}\n\noutput <- run_simulation(mtx, move_seq)\n```\n:::\n\n\n\nConvert the result to GPS coordinates:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput |> \n  as_tibble() |> \n  mutate(row = row_number(), .before = everything()) |> \n  pivot_longer(\n    -row, \n    names_to = \"col\", \n    names_prefix = \"V\", \n    names_transform = as.integer\n  ) |> \n  # Select only the leftmost cell of each boxes\n  filter(str_detect(value, \"\\\\d+\")) |> \n  slice_min(col, by = value) |> \n  mutate(\n    dist_top = row - 1,\n    dist_left = col - 1,\n    gps = 100 * dist_top + dist_left\n  ) |> \n  pull(gps) |> \n  sum()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}