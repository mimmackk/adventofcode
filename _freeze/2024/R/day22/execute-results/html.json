{
  "hash": "232b0bfc32266424f67365963e2a708d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 22\"\ndate: 2024-12-22\nauthor:\n  name: https://adventofcode.com/2024/day/22\n  url: https://adventofcode.com/2024/day/22\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(bit64)\nlibrary(memoise)\n\n# Read input from file\ninput <- read_lines(\"../input/day22.txt\", skip_empty_rows = TRUE) |> \n  as.numeric()\n```\n:::\n\n\n\n## Part 1\n\nDefine custom bitwise XOR function, needed to handle large integers:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbitwXor64 <- function(x, y) {\n  x <- as.bitstring(as.integer64(x))\n  y <- as.bitstring(as.integer64(y))\n  \n  map2_chr(\n    x |> str_split(\"\") |> map(as.integer), \n    y |> str_split(\"\") |> map(as.integer),\n    ~ base::xor(.x, .y) |> \n      as.integer() |> \n      str_c(collapse = \"\")\n  ) |> \n    structure(class = \"bitstring\") |>\n    as.integer64() |>\n    as.numeric()\n}\n```\n:::\n\n\n\nDefine the algorithm for producing a sequence of \"secret\" numbers:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmix   <- memoise::memoise(\\(a, b) bitwXor64(a, b))\nprune <- \\(x) x %% 16777216\n\nsecret_alg <- function(x) {\n  x1 <- prune(mix(x, x * 64))\n  x2 <- prune(mix(x1, floor(x1 / 32)))\n  x3 <- prune(mix(x2, x2 * 2048))\n  return(x3)\n}\n\nsecret_seq <- function(init, len) {\n  out <- list(init)\n  for (i in 2:len) {\n    out[[i]] <- secret_alg(pluck(out, i - 1))\n  }\n  out\n}\n```\n:::\n\n\n\nRun puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsecret_nums <- secret_seq(input, len = 2001)\n\nsecret_nums |> \n  tail(n = 1) |> \n  unlist() |> \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20401393616\n```\n\n\n:::\n:::\n\n\n\n## Part 2\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert sequences to a data frame by buyer and time\ndiffs <- secret_nums |> \n  imap_dfr(\\(x, idx) tibble(time = idx, secret_number = x)) |> \n  mutate(\n    buyer_id = row_number(),\n    .by = time\n  ) |> \n  mutate(\n    # Get the price at each time by taking the ones digit of each secret number\n    price = secret_number %% 10L,\n    # Compute the difference in price at the current time vs the previous time\n    diff = price - lag(price),\n    # Compute the sequence of 4 price changes preceeding the current price\n    lag1 = lag(diff, n = 1L),\n    lag2 = lag(diff, n = 2L),\n    lag3 = lag(diff, n = 3L),\n    diff_seq = str_c(lag3, lag2, lag1, diff, sep = \",\"),\n    .by = buyer_id\n  ) |> \n  arrange(buyer_id, time)\n\n# For each price change seq, compute the bananas you will get from each buyer:\nbananas_by_seq <- diffs |> \n  filter(!is.na(diff_seq)) |> \n  summarize(\n    bananas = head(price, 1),\n    .by = c(buyer_id, diff_seq)\n  )\n\n# Find the most advantageous sequence:\nbananas_by_seq |> \n  summarize(bananas = sum(bananas), .by = diff_seq) |> \n  slice_max(bananas) |> \n  pull(bananas)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2272\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}