{
  "hash": "94a67baf33ec512d1617710f8caa03f2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 22\"\ndate: 2024-12-22\nauthor:\n  name: https://adventofcode.com/2024/day/22\n  url: https://adventofcode.com/2024/day/22\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\nRead input from txt file into a numeric vector:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- scan(\"../input/day22.txt\")\n```\n:::\n\n\n\n\n## Part 1\n\nR only has bitwise operations for integers up to 32 bits. First, we have to define functions to convert between large numeric values and 64-\"bit\" 1/0 vectors:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase64 <- 2^(63:0)  # (pre-compute this vector to reduce runtime)\n\nas_b64 <- \\(x) x %/% base64 %% 2\nas_num <- \\(x) sum(x * base64)\n```\n:::\n\n\n\n\nDefine a function to perform xor operations on large integers: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb64xor <- \\(x, y) as_num(base::xor(as_b64(x), as_b64(y)))\n```\n:::\n\n\n\n\nDefine the algorithm for producing a sequence of \"secret\" numbers:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprune <- \\(x) x %% 16777216\n\nsecret_alg <- function(x0) {\n  x1 <- prune(b64xor(x0, x0 * 64))\n  x2 <- prune(b64xor(x1, x1 %/% 32))\n  x3 <- prune(b64xor(x2, x2 * 2048))\n  \n  x3\n}\n\nsecret_seq <- function(init, n) {\n  map(init, \\(init) accumulate(1:n, \\(x, y) secret_alg(x), .init = init))\n}\n```\n:::\n\n\n\n\nGenerate 2000 \"secret numbers\" for each initial value in the puzzle input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsecret_nums <- secret_seq(input, n = 2000)\n```\n:::\n\n\n\n\nSum the 2000th \"secret number\" for each value in our input:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsecret_nums |> \n  map_dbl(~ tail(.x, n = 1)) |> \n  sum()\n```\n:::\n\n\n\n\n\n## Part 2\n\nConvert the set of secret number sequences to a dataframe organized by buyer and time:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiffs <- secret_nums |> \n  enframe(name = \"buyer_id\", value = \"secret_number\") |> \n  unnest_longer(secret_number, indices_to = \"time\") |> \n  mutate(\n    \n    # Get the price at each time by taking the ones digit of each secret number\n    price = secret_number %% 10L,\n    \n    # Compute the difference in price at the current time vs the previous time\n    diff = price - lag(price),\n    \n    # Compute the sequence of 4 price changes preceeding the current price\n    lag1 = lag(diff, n = 1L),\n    lag2 = lag(diff, n = 2L),\n    lag3 = lag(diff, n = 3L),\n    diff_seq = str_c(lag3, lag2, lag1, diff, sep = \",\"),\n    \n    .by = buyer_id\n  ) |> \n  arrange(buyer_id, time)\n```\n:::\n\n\n\n\nFor each price change sequence, compute the bananas you will get from each buyer:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbananas_by_seq <- diffs |> \n  filter(!is.na(diff_seq)) |> \n  summarize(\n    bananas = head(price, 1),\n    .by = c(buyer_id, diff_seq)\n  )\n```\n:::\n\n\n\n\nFind the most advantageous sequence:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbananas_by_seq |> \n  summarize(bananas = sum(bananas), .by = diff_seq) |> \n  slice_max(bananas) |> \n  pull(bananas)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}