{
  "hash": "949793a505cd9428ba393fb05661c48f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 6\"\ndate: 2024-12-06\nauthor:\n  name: https://adventofcode.com/2024/day/6\n  url: https://adventofcode.com/2024/day/6\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\nRead text input from file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day06.txt\")\n```\n:::\n\n\n\n\nConvert text input of the map into a 1/0 matrix (saving the guard's initial location):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtx <- input |> \n  str_split(\"\") |> \n  unlist() |> \n  case_match(\".\" ~ 0, \"#\" ~ 1, c(\"^\", \"v\", \"<\", \">\") ~ 2) |> \n  matrix(nrow = length(input), byrow = TRUE)\n\ninit <- as.vector(which(mtx == 2, arr.ind = TRUE))\n\nmtx <- replace(mtx, mtx == 2, 0)\n```\n:::\n\n\n\n\n## Part 1\n\nDefine a function that loops through guard positions until it leaves the map, returning a list of all positions where they turned:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaxdim <- c(1, ncol(mtx), nrow(mtx), 1)\nmtxdir <- c(-1, 1, 1, -1)\nmtxaxis <- c(1, 2, 1, 2)\n\nguard_path <- function(mtx, init) {\n  guard <- init\n  hist <- list(guard)\n  idx <- 1\n  \n  repeat {\n    dir <- mtxdir[idx]\n    dim <- maxdim[idx]\n    axis <- mtxaxis[idx]\n    \n    if (axis == 1) {\n      path <- mtx[(guard[1] + dir):dim, guard[2]]\n    } else {\n      path <- mtx[guard[1], (guard[2] + dir):dim]\n    }\n    \n    # Quit if we reach the edge of the map without an obstacle\n    if (all(path == 0)) {\n      guard[axis] <- dim\n      hist <- c(hist, list(guard))\n      return(hist)\n    }\n    \n    # Move the guard\n    guard[axis] <- guard[axis] + dir * head(which(path == 1) - 1, 1)\n    \n    # If we've entered a loop (same position + same direction), exit early\n    if (list(guard) %in% hist) {\n      # (we can't compare nested lists directly, so must compare str vers)\n      hist_str <- map_chr(hist, ~ str_flatten(.x, collapse = \"|\"))\n      guard_str <- str_flatten(guard, collapse = \"|\")\n      if (idx %in% ((which(guard_str == hist_str) - 2) %% 4 + 1))\n        return()\n    }\n    \n    # Update the guard's history and the indexing\n    hist <- c(hist, list(guard))\n    idx <- idx %% 4 + 1\n  }\n}\n```\n:::\n\n\n\n\nGet the guard's path for the puzzle input, then count the number of unique positions visited by the guard:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath <- guard_path(mtx, init)\n\npath_full <- map2(head(path, -1), tail(path, -1), \\(source, target) {\n  expand_grid(row = source[1]:target[1], col = source[2]:target[2])\n}) |> \n  bind_rows() |> \n  distinct()\n\nnrow(path_full)\n```\n:::\n\n\n\n\n# Part 2\n\nFor each location in the full path (except the starting location), add an obstacle to the matrix. Check the result for loops:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath_full |>\n  tail(-1) |>\n  pmap_lgl(\\(row, col) {\n    mtx[row, col] <- 1\n    is.null(guard_path(mtx, init))\n  }) |> \n  sum()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}