{
  "hash": "3c9926b3c5a8c59d4821178cc6c2157a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 6\"\ndate: 2024-12-06\nauthor:\n  name: https://adventofcode.com/2024/day/6\n  url: https://adventofcode.com/2024/day/6\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput <- read_lines(\"../input/day06.txt\", skip_empty_rows = TRUE)\n```\n:::\n\n\n\n## Part 1\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Guard functions --------------------------------------------------------------\nguards <- c(\"^\", \">\", \"v\", \"<\")\nguard_shift <- c(tail(guards, -1), head(guards, 1))\n\nrotate_guard <- function(cur) guard_shift[guards == cur]\n\nguard_dir <- function(char) {\n  case_match(char,\n    \"^\" ~ matrix(c(-1,  0), nrow = 1),\n    \">\" ~ matrix(c( 0,  1), nrow = 1),\n    \"v\" ~ matrix(c( 1,  0), nrow = 1),\n    \"<\" ~ matrix(c( 0, -1), nrow = 1)\n  )\n}\n\nin_bounds <- function(coord, mtx) {\n  between(coord[1], 1, nrow(mtx)) & between(coord[2], 1, ncol(mtx))\n}\n\nmap_path <- function(mtx) {\n\n  # Initiate guard's starting position and direction\n  cur_char  <- keep(mtx, ~ .x %in% guards)\n  cur_coord <- which(mtx == cur_char, arr.ind = TRUE)\n  cur_dir   <- guard_dir(cur_char)\n  \n  # As long as the guard is in bounds, iteratively update its coords and direction\n  repeat {\n    next_coord <- cur_coord + cur_dir\n    \n    # If next step is out-of-bounds, update matrix and exit\n    if (!in_bounds(next_coord, mtx)) {\n      mtx[cur_coord] <- \"X\"\n      break\n    }\n    # If next step is an obstacle, rotate the guard\n    else if (mtx[next_coord] == '#') {\n      cur_char <- rotate_guard(cur_char)\n      cur_dir  <- guard_dir(cur_char)\n    }\n    # Otherwise advance the guard forward\n    else {\n      mtx[cur_coord] <- \"X\"\n      cur_coord <- next_coord\n    }\n  }\n  \n  mtx\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert input into a matrix\nmtx <- input |> \n  str_split(\"\") |> \n  unlist() |> \n  matrix(nrow = length(input), byrow = TRUE)\n\n# Map the guard's path\nguard_path <- map_path(mtx)\n\n# Count distinct positions visited\nsum(guard_path == \"X\")\n```\n:::\n\n\n\n## Part 2\n\nChange the path mapping function to test for loops\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npath_loops <- function(mtx) {\n\n  # Initiate guard's starting position and direction\n  cur_char  <- keep(mtx, ~ .x %in% guards)\n  cur_coord <- which(mtx == cur_char, arr.ind = TRUE)\n  cur_dir   <- guard_dir(cur_char)\n  path_hist <- matrix(\"\", nrow(mtx), ncol(mtx))\n\n  # As long as the guard is in bounds, iteratively update its coords and direction\n  repeat {\n    next_coord <- cur_coord + cur_dir\n    \n    # Check if the guard is looping or if they have left the area\n    if (str_detect(path_hist[cur_coord], fixed(cur_char))) \n      return(TRUE)\n    else if (!in_bounds(next_coord, mtx)) \n      return(FALSE)\n    \n    # If next step is an obstacle, rotate the guard\n    else if (mtx[next_coord] == '#') {\n      # Update path history\n      path_hist[cur_coord] <- str_c(path_hist[cur_coord], cur_char)\n      # Update guard\n      cur_char <- rotate_guard(cur_char)\n      cur_dir  <- guard_dir(cur_char)\n    }\n    # Otherwise advance the guard forward\n    else {\n      # Update path history\n      path_hist[cur_coord] <- str_c(path_hist[cur_coord], cur_char)\n      # Update guard\n      cur_coord <- next_coord\n    }\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a variation of the map for each possible obstacle location\nobstacles <- which(guard_path == \"X\" & !(mtx %in% guards))\n\n# Test each obstacle location for loops and sum result\nobstacles |> \n  map(~ replace(mtx, .x, \"#\")) |> \n  map_lgl(path_loops) |> \n  sum()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}