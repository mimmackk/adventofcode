{
  "hash": "25db0a49c806acabd52033aacf67c159",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 19\"\ndate: 2024-12-19\nauthor:\n  name: https://adventofcode.com/2024/day/19\n  url: https://adventofcode.com/2024/day/19\n---\n\n\n\n\n## Setup\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput <- read_table(\"../input/day20.txt\", col_names = \"char\") |> \n  mutate(\n    row = row_number(),\n    char = str_split(char, \"\")\n  ) |> \n  unnest_longer(char, indices_to = \"col\")\n```\n:::\n\n\n\n\n## Part 1\n\nBuild the base-state graph:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove borders and define graph edges\ndf <- input |> \n  filter(row > 1 & row < max(row) & col > 1 & col < max(col)) |> \n  mutate(\n    id = row_number(),\n    row = row - 1, \n    col = col - 1\n  ) |> \n  mutate(is_wall = char == \"#\") |> \n  mutate(id_n = lag(id), is_wall_n = lag(is_wall), .by = col) |> \n  mutate(id_w = lag(id), is_wall_w = lag(is_wall), .by = row) |> \n  mutate(\n    edge_n = case_when(!is_wall & !is_wall_n ~ map2(id, id_n, ~ c(.x, .y))),\n    edge_w = case_when(!is_wall & !is_wall_w ~ map2(id, id_w, ~ c(.x, .y)))\n  )\n\n# Define graph\ng <- df |> \n  select(edge_n, edge_w) |> \n  pivot_longer(everything()) |> \n  pull(value) |> \n  unlist() |> \n  make_graph(n = max(df$id), directed = FALSE)\n\n# Define start and end positions\nid_start <- df |> filter(char == \"S\") |> pull(id)\nid_end   <- df |> filter(char == \"E\") |> pull(id)\n\n# Get the base number of steps to compare against\nbase_steps <- distances(g, id_start, id_end) |> as.list() |> unlist()\n```\n:::\n\n\n\n\nLoop through alternate states, removing one wall at a time, and count how many steps each saves:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwall_ids <- df |> \n  filter(char == \"#\") |> \n  pull(id)\n\nshortcuts <- NULL\n\nfor (x in wall_ids) {\n\n  new_edges_source <- df |> \n    filter(id == x) |> \n    mutate(\n      edge_n = case_when(!is_wall_n ~ map2(id, id_n, ~ c(.x, .y))),\n      edge_w = case_when(!is_wall_w ~ map2(id, id_w, ~ c(.x, .y)))\n    ) |> \n    select(edge_n, edge_w) |> \n    pivot_longer(everything()) |> \n    pull(value) |> \n    unlist()\n  \n  new_edges_target <- df |> \n    filter(!is_wall & (id_n == x | id_w == x)) |> \n    pull(id) |> \n    map(~c(.x, x)) |> \n    unlist()\n  \n  num_steps <- g |> \n    add_edges(c(new_edges_source, new_edges_target)) |> \n    distances(id_start, id_end) |> \n    as.list() |> \n    unlist()\n  \n  shortcuts <- c(shortcuts, num_steps)\n}\n```\n:::\n\n\n\n\nCount the number of shortcuts by steps saved:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_shortcuts <- tibble(steps_saved = base_steps - shortcuts) |> \n  filter(steps_saved > 0) |> \n  summarize(n = n(), .by = steps_saved) |> \n  arrange(desc(n), steps_saved)\n```\n:::\n\n\n\n\nCount the number of shortcuts that save at least 100 seconds:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_shortcuts |> \n  filter(steps_saved >= 100) |> \n  pull(n) |> \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1417\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}