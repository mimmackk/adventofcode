{
  "hash": "a677d72e1534e3c1251f28d518d0da30",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 20\"\ndate: 2024-12-20\nauthor:\n  name: https://adventofcode.com/2024/day/20\n  url: https://adventofcode.com/2024/day/20\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput <- read_table(\"../input/day20.txt\", col_names = \"char\") |> \n  mutate(\n    row = row_number(),\n    char = str_split(char, \"\")\n  ) |> \n  unnest_longer(char, indices_to = \"col\")\n```\n:::\n\n\n\n## Part 1\n\nExtract the sequence of tiles in the original path:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute coordinates of each tile and extract the path sequence, ignoring walls\ndf <- input |> \n  filter(row > 1 & row < max(row) & col > 1 & col < max(col)) |> \n  mutate(\n    id = row_number(),\n    row = row - 1, \n    col = col - 1\n  ) |> \n  filter(char %in% c(\"S\", \"E\", \".\")) |> \n  arrange(col, row)\n\n# Re-number the tiles on the path by their ordering from start to finish\npath_seq <- df |> \n  filter(char == \"S\") |> \n  pull(id)\n\nwhile (length(path_seq) < nrow(df)) {\n  path_seq <- c(\n    path_seq, \n    df |> \n      filter(id == tail(path_seq, 1)) |> \n      cross_join(df) |> \n      filter(\n        (abs(col.x - col.y) == 1 & abs(row.x - row.y) == 0) |\n        (abs(col.x - col.y) == 0 & abs(row.x - row.y) == 1)\n      ) |> \n      filter(!(id.y %in% path_seq)) |> \n      pull(id.y)\n  )\n}\n\n# Attach path order onto the list of path tiles with their coordinates\ndf_path <- left_join(\n  df, \n  enframe(path_seq, name = \"path_idx\", value = \"id\"), \n  join_by(id)\n) |> \n  select(path_idx, row, col) |> \n  arrange(path_idx)\n```\n:::\n\n\n\nCount the total seconds saved when collision is disabled for n seconds. Possible cheat end locations, and the time it takes to arrive there, can be calculated using Manhattan distance.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmanhattan_dist <- function(a_row, a_col, b_row, b_col) {\n  abs(a_row - b_row) + abs(a_col - b_col)\n}\n\ncount_cheats <- function(cheat_length) {\n\n  df_path |> \n    # Find all possible time-saving cheats if collision is disabled for n secs\n    left_join(df_path, join_by(x$path_idx < y$path_idx)) |> \n    mutate(dist = manhattan_dist(row.x, col.x, row.y, col.y)) |> \n    filter(dist <= cheat_length) |> \n    mutate(saved = path_idx.y - path_idx.x - dist) |> \n    summarize(n = n(), .by = saved) |> \n    arrange(saved) |> \n    \n    # Count the total number of cheats that save at least 100 seconds\n    filter(saved >= 100) |> \n    pull(n) |>\n    sum()\n  \n}\n```\n:::\n\n\n\nRun on puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_cheats(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1417\n```\n\n\n:::\n:::\n\n\n\n## Part 2\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_cheats(20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1014683\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}