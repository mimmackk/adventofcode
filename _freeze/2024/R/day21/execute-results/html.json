{
  "hash": "a889286be69fae4461abb7891c59adad",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 21\"\ndate: 2024-12-21\nauthor:\n  name: https://adventofcode.com/2024/day/21\n  url: https://adventofcode.com/2024/day/21\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput <- read_lines(\"../input/day21.txt\")\n```\n:::\n\n\n\n## Part 1\n\nDefine functions calculate minimum distances between keys on a keypad:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Helper function to convert pairs of adjacent keys to their directions\nkeypad_to_df <- function(keys, rows, cols) {\n  df <- tibble(key = keys, row = rows, col = cols)\n  \n  cross_join(df, df, suffix = c(\"_from\", \"_to\")) |> \n    filter(abs(row_to - row_from) + abs(col_to - col_from) == 1) |> \n    mutate(dir = case_when(\n      col_from < col_to ~ \">\",\n      col_from > col_to ~ \"<\",\n      row_from < row_to ~ \"^\",\n      row_from > row_to ~ \"v\"\n    ))\n}\n\n# Convert a keypad (set of keys and their coordinates) to a graph\nkeypad_to_graph <- function(keys, rows, cols) {\n  df <- keypad_to_df(keys, rows, cols)\n  g <- df |> \n    transmute(from = key_from, to = key_to) |> \n    graph_from_data_frame(vertices = keys)\n  f <- function(from, to) {\n    df |> \n    filter(key_from == from & key_to == to) |> \n    pull(dir)\n  }\n  list(\"df\" = df, \"g\" = g, \"f\" = f)\n}\n\n# Return all shortests paths between two keys on a keypad\nkeypad_paths <- function(keypad, key_from, key_to) {\n  all_shortest_paths(keypad$g, from = key_from, to = key_to)$vpaths |> \n    map_chr(\\(x) {\n      dirs <- map2_chr(\n        head(names(x), -1), \n        head(lead(names(x)), -1), \n        \\(dir_from, dir_to) keypad$f(dir_from, dir_to)\n      )\n      str_c(c(dirs, \"A\"), collapse = \"\")\n    })\n}\n\n# Define the numeric keypad\nkeys_num <- c(\"A\", 0:9)\nrows_num <- case_match(keys_num,\n  c(\"A\", \"0\")      ~ 1,\n  c(\"1\", \"2\", \"3\") ~ 2,\n  c(\"4\", \"5\", \"6\") ~ 3,\n  c(\"7\", \"8\", \"9\") ~ 4\n)\ncols_num <- case_match(keys_num,\n  c(\"1\", \"4\", \"7\")      ~ 1,\n  c(\"0\", \"2\", \"5\", \"8\") ~ 2,\n  c(\"A\", \"3\", \"6\", \"9\") ~ 3\n)\nkeypad_num <- keypad_to_graph(keys = keys_num, row = rows_num, col = cols_num)\n\n# Define the directional keypad\nkeys_dir <- c(\"<\", \"v\", \">\", \"^\", \"A\")\nrows_dir <- case_match(keys_dir,\n  c(\"<\", \"v\", \">\") ~ 1,\n  c(\"^\", \"A\")      ~ 2\n)\ncols_dir <- case_match(keys_dir,\n  c(\"<\")      ~ 1,\n  c(\"v\", \"^\") ~ 2,\n  c(\">\", \"A\") ~ 3\n)\nkeypad_dir <- keypad_to_graph(keys = keys_dir, row = rows_dir, col = cols_dir)\n\n# Recursively compute the minimum user input for a given input string\nmin_path <- function(input_str, level = 0, max_level = 3) {\n  if (level == max_level)\n    return(str_length(input_str))\n  \n  keypad <- if (level == 0) keypad_num else keypad_dir\n  \n  input_to <- str_split_1(input_str, \"\")\n  input_from <- lag(input_to, default = \"A\")\n  steps <- map2_int(\n    input_from, \n    input_to, \n    \\(from, to) keypad_paths(keypad, from, to) |> \n      map_int(min_path, level = level + 1, max_level = max_level) |> \n      min()\n  )\n  sum(steps)\n}\n```\n:::\n\n\n\nRun on puzzle input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(input) |> \n  mutate(\n    numeric_code = parse_number(input),\n    shortest_seq = map_int(input, min_path),\n    complexity = numeric_code * shortest_seq\n  ) |> \n  pull(complexity) |> \n  sum()\n```\n:::\n\n\n\n\n## Part 2\n\nModify the min_path function to condense all inputs wherever possible so needless computation isn't repeated:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin_path <- function(input_str, level = 0, max_level = 3) {\n  if (level == max_level)\n    return(str_length(input_str))\n  \n  keypad <- if (level == 0) keypad_num else keypad_dir\n  \n  df <- tibble(str = input_str) |> \n    mutate(\n      id = row_number(),\n      key = map(str, ~ tibble(\n        input_to = str_split_1(.x, \"\"),\n        input_from = lag(input_to, default = \"A\")\n      ))\n    ) |> \n      unnest(key)\n\n  steps <- df |> \n    distinct(input_from, input_to) |> \n    mutate(paths = map2(input_from, input_to, ~ keypad_paths(keypad, .x, .y))) |> \n    unnest(paths) |> \n    mutate(len = min_path(paths, level = level + 1, max_level = max_level)) |> \n    slice_min(len, by = c(input_from, input_to), with_ties = FALSE)\n  \n  df |> \n    left_join(steps, join_by(input_from, input_to)) |> \n    summarize(steps = sum(len), .by = c(id, str)) |> \n    pull(steps)\n}\n```\n:::\n\n\n\nRe-run puzzle input with a max level of 26:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(input) |> \n  mutate(\n    numeric_code = parse_number(input),\n    shortest_seq = map_dbl(input, min_path, max_level = 26),\n    complexity = numeric_code * shortest_seq\n  ) |> \n  pull(complexity) |> \n  sum() |> \n  format(scientific = FALSE)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}