{
  "hash": "e84728141f6bbc818304b0649be3cfb4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 16\"\ndate: 2024-12-16\nauthor:\n  name: https://adventofcode.com/2024/day/16\n  url: https://adventofcode.com/2024/day/16\n---\n\n\n\n## Setup\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput <- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE)\n```\n:::\n\n\n\n## Part 1\n\nConvert text input into a weighted, undirected graph\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert input to a data frame\ndf <- input |> \n  str_split(\"\") |> \n  unlist() |> \n  as_tibble_col(column_name = \"cell\") |> \n  mutate(\n    input_id  = row_number() - 1,\n    row = floor(input_id / length(input)),\n    col = floor(input_id %% length(input))\n  )\n\n# Convert borders between grid cells to graph vertices and map edges by cell\nborders <- df |> \n  mutate(border_e = (cell != \"#\" & lead(cell) != \"#\"), .by = row) |> \n  mutate(border_s = (cell != \"#\" & lead(cell) != \"#\"), .by = col) |> \n  mutate(\n    vtx_id_e = case_when(border_e ~ cumsum(border_e)),\n    vtx_id_s = case_when(border_s ~ cumsum(border_s) + max(vtx_id_e, na.rm = T))\n  ) |> \n  mutate(vtx_id_n = lag(vtx_id_s), .by = col) |> \n  mutate(vtx_id_w = lag(vtx_id_e), .by = row) |> \n  mutate(\n    conn_ns = map2(vtx_id_n, vtx_id_s, ~ na.omit(c(.x, .y))),\n    conn_ew = map2(vtx_id_e, vtx_id_w, ~ na.omit(c(.x, .y))),\n    conn_ne = map2(vtx_id_n, vtx_id_e, ~ na.omit(c(.x, .y))),\n    conn_nw = map2(vtx_id_n, vtx_id_w, ~ na.omit(c(.x, .y))),\n    conn_se = map2(vtx_id_s, vtx_id_e, ~ na.omit(c(.x, .y))),\n    conn_sw = map2(vtx_id_s, vtx_id_w, ~ na.omit(c(.x, .y))),\n  )\n\n# Extract the list of all vertices\nvertices <- c(borders$vtx_id_e, borders$vtx_id_s) |> \n  na.omit() |> \n  sort()\n\n# Convert vertices and edges to an adjacency matrix\nmtx <- borders |> \n  # Unnest lists of edge connections between vertices\n  select(starts_with(\"conn\")) |> \n  pivot_longer(everything(), names_to = \"conn\", names_prefix = \"conn_\") |> \n  unnest_wider(value, names_sep = \"_\") |> \n  drop_na(value_1, value_2) |> \n  # Rotations get an extra 1k added to the weight\n  mutate(weight = case_match(conn, c(\"ns\", \"ew\") ~ 1, .default = 1001)) |> \n  select(-conn) |> \n  # Convert to matrix format, where unconnected vertices have weight 0\n  complete(value_1 = vertices, value_2 = vertices, fill = list(weight = 0)) |> \n  arrange(value_1, value_2) |> \n  pivot_wider(names_from = value_2, values_from = weight) |> \n  column_to_rownames(var = \"value_1\") |> \n  as.matrix()\n\n# Make matrix symmetric (for an undirected graph)\nsym_mtx <- pmax(mtx, t(mtx))\n\n# Convert adjacency matrix to a graph\ng <- graph_from_adjacency_matrix(sym_mtx, mode = \"undirected\", weighted = TRUE)\n```\n:::\n\n\n\nDetermine possible starting and ending locations from the input\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecial_cells <- borders |> \n  filter(cell %in% c(\"S\", \"E\")) |> \n  select(cell, starts_with(\"vtx_id\")) |> \n  pivot_longer(\n    starts_with(\"vtx_id\"), \n    names_prefix = \"vtx_id_\",\n    names_to = \"dir\",\n    values_to = \"vertex\"\n  ) |> \n  drop_na(vertex)\n\n# Create all combinations of start & end cell borders\ncombos <- special_cells |> \n  filter(cell == \"S\") |> \n  mutate(\n    init_rotation = case_match(dir, \"e\" ~ 0, c(\"n\", \"s\") ~ 1, \"w\" ~ 2) * 1000\n  ) |>\n  select(start_vertex = vertex, init_rotation) |> \n  cross_join(\n    special_cells |> \n      filter(cell == \"E\") |> \n      select(end_vertex = vertex)\n  )\n```\n:::\n\n\n\nFind the minimum path distance for each start/end vertex combo:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin_dist <- combos |> \n  mutate(\n    dist = map2_int(\n      start_vertex, \n      end_vertex, \n      ~ distances(g, .x, .y)) + init_rotation + 1\n  ) |> \n  slice_min(dist)\n\nmin_dist |> \n  pull(dist)\n```\n:::\n\n\n\n## Part 2\n\nPull all paths that have the minimum distance from start to end:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshortest_paths <- min_dist |> \n  pmap(function(start_vertex, init_rotation, end_vertex, ...) {\n    all_shortest_paths(g, start_vertex, end_vertex)$vpaths\n  }) |> \n  flatten() |> \n  map(as.integer)\n\n\npath_vertices <- shortest_paths |> \n  unlist() |> \n  unique() |> \n  sort()\n```\n:::\n\n\n\nCount all non-wall cells with a border in the shortest path vertex list: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nborders |> \n  select(cell, input_id, starts_with(\"vtx_id\")) |> \n  pivot_longer(starts_with(\"vtx_id\")) |> \n  drop_na(value) |> \n  filter(map_lgl(value, ~ .x %in% path_vertices)) |> \n  filter(cell != \"#\") |> \n  distinct(input_id) |> \n  nrow()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}