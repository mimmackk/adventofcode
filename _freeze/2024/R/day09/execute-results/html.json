{
  "hash": "5227516c791c2fbbf67c9cecaeec3bd3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 9\"\ndate: 2024-12-09\nauthor:\n  name: https://adventofcode.com/2024/day/9\n  url: https://adventofcode.com/2024/day/9\n---\n\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\nDisable scientific formatting when displaying large numbers:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(scipen = 999)\n```\n:::\n\n\n\n\nRead input from file into a vector of integers:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day09.txt\") |> \n  str_split_1(\"\") |> \n  as.integer()\n```\n:::\n\n\n\n\n## Part 1\n\nDefine a function to move the file blocks:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmove_files <- function(filesys) {\n  repeat {\n    first_blank <- min(which(is.na(filesys)))\n    last_file   <- max(which(!is.na(filesys)))\n    \n    # If all files have been compressed, exit\n    if (first_blank > last_file) break\n    \n    # Otherwise, move the last file into the first blank location\n    filesys[first_blank] <- filesys[last_file]\n    filesys[last_file]   <- NA_integer_\n  }\n  filesys\n}\n```\n:::\n\n\n\n\nDefine a function to compute the checksum of the file system:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchecksum <- function(filesys) {\n  filesys |> \n    imap_int(\\(x, idx) if_else(is.na(x), 0, x * (idx - 1))) |> \n    sum()\n}\n```\n:::\n\n\n\n\nUncompress the given file layout, interpreting even entries as files and odd entries as spaces:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilesys <- input|> \n  imap(function(x, idx) {\n    file_id <- if_else(idx %% 2 == 1, floor(idx / 2), NA_integer_)\n    rep(file_id, x)\n  }) |> \n  unlist()\n```\n:::\n\n\n\n\nMove the files and compute the checksum:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilesys |> \n  move_files() |> \n  checksum()\n```\n:::\n\n\n\n\n## Part 2\n\nUpdate the compression function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmove_blocks <- function(filesys) {\n  for (file_id in max(na.omit(filesys)):1) {\n    \n    # Pull the location and length of the file block for the current ID\n    file_block <- which(filesys == file_id)\n    n <- length(file_block)\n    \n    # Pull indices of all empty values before the current file block\n    empty_idx <- which(is.na(filesys[1:min(file_block)]))\n    \n    # Pull all valid starting indices of empty blocks of the right length\n    if (n == 1) {\n      valid_idx <- empty_idx\n    } else {\n      valid_block <- replace_na(lead(empty_idx, n - 1) - empty_idx == n - 1, FALSE)\n      valid_idx <- empty_idx[valid_block]\n    }\n    \n    # If valid indices exist, move the file block to the first valid location\n    if (length(valid_idx) > 0) {\n      idx_start <- min(valid_idx)\n      filesys[idx_start:(idx_start + n - 1)] <- file_id\n      filesys[file_block] <- NA_integer_\n    }\n  }\n  \n  filesys\n}\n```\n:::\n\n\n\n\nRe-run input with new compression function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilesys |> \n  move_blocks() |> \n  checksum()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}