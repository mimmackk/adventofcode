{
  "hash": "2c3d3cce4b532d2d1e057ed09685d668",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 10\"\ndate: 2025-12-10\nauthor:\n  name: https://adventofcode.com/2025/day/10\n  url: https://adventofcode.com/2025/day/10\nexecute:\n  eval: true\n---\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(lpSolve)\nlibrary(combinat)\n```\n:::\n\n\n\nRead text input from file:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day10.txt\")\n```\n:::\n\n\n\nParse text into numeric and binary vectors:\n\n-   An indicator light diagram `[.##.]` becomes `0 1 1 0`.\n-   For the same diagram, a button `(3)` becomes `0 0 0 1`.\n-   A joltage requirement `{3,5,4,7}` becomes `3 5 4 7`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmanual <- input |> \n  str_split(\" \") |> \n  map(\\(x) {\n    lst(\n      output = pluck(x, 1) |> \n        str_remove_all(\"\\\\[|\\\\]\") |> \n        str_split_1(\"\") |> \n        case_match(\".\" ~ 0, \"#\" ~ 1), \n      joltage = pluck(x, -1) |> \n        str_remove_all(\"\\\\{|\\\\}\") |> \n        str_split_1(\",\") |> \n        as.numeric(),\n      buttons = x |> \n        head(-1) |> \n        tail(-1) |> \n        str_remove_all(\"\\\\(|\\\\)\") |> \n        str_split(\",\") |> \n        map(\\(btn) {\n          modify_at(rep(0, length(output)), as.numeric(btn) + 1, ~ 1)\n        })\n    )\n  })\n```\n:::\n\n\n\n## Part 1\n\nSince this is a modular equation, pressing a button once is equivalent to pressing it 3 times, 5 times, etc, and pressing it zero times is equivalent to pressing it 2 times, 4 times, etc. Since our goal is to minimize the number of button presses, each button can be pressed either once or never.\n\nWe define a function which iterates through all possible combinations of button presses, starting from all sets of 1 button, all sets of 2 buttons, etc., until we find a pair that produces a match with the output:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin_buttons <- function(man) {\n  \n  for (n in 1:length(man$buttons)) {\n    combos <- combn(1:length(man$buttons), n, simplify = FALSE)\n    \n    for (i in combos) {\n      pressed <- reduce(man$buttons[i], `+`) %% 2\n      if (identical(pressed, man$output))\n        return(n)\n    }\n  }\n  \n}\n```\n:::\n\n\n\nDetermine the minimum number of presses for each line of input, then sum the result:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmanual |> \n  map_dbl(min_buttons) |> \n  sum()\n```\n:::\n\n\n\n## Part 2\n\nUse linear programming with the package `lpSolve`. We create a system of linear equations for each line, then minimize for total presses:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(manual, \\(man) {\n  lp(\n    direction = \"min\",\n    objective.in = rep(1, length(man$buttons)),\n    const.mat = man$buttons |> \n      reduce(rbind) |> \n      t(),\n    const.dir = rep(\"==\", length(man$joltage)),\n    const.rhs = man$joltage,\n    all.int   = TRUE\n  ) |> \n    pluck(\"objval\")\n}) |> \n  sum()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}