{
  "hash": "ea82bd1948a7520c40e97e119b65e7b6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Day 12\"\ndate: 2025-12-12\nauthor:\n  name: https://adventofcode.com/2025/day/12\n  url: https://adventofcode.com/2025/day/12\nexecute:\n  eval: true\n---\n\n\n\n## Setup\n\nImport libraries:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(unglue)\n```\n:::\n\n\n\nRead text input from file:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- read_lines(\"../input/day12.txt\", skip_empty_rows = TRUE)\n```\n:::\n\n\n\nSeparate the text for the presents and the regions from the raw input:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- input |> \n  enframe(name = NULL, value = \"txt\") |> \n  mutate(\n    present_id = case_when(\n      str_detect(txt, \"^\\\\d+:$\") ~ parse_number(str_extract(txt, \"\\\\d+\"))\n    ),\n    is_present = str_detect(txt, \"^[#.]+$\"),\n    is_region  = str_detect(txt, \"^\\\\d+x\\\\d+\")\n  ) |> \n  fill(present_id, .direction = \"down\") |> \n  filter(is_present | is_region) |> \n  group_split(is_region) |> \n  set_names(c(\"presents\", \"regions\"))\n```\n:::\n\n\n\nConvert all presents to a list of binary T/F matrices, where `#` is coded as `TRUE` and `.` as `FALSE`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npresents <- input$presents |>\n  nest(mtx = txt, .by = present_id) |> \n  mutate(mtx = map(mtx, \\(x) {\n    x |> \n      unlist() |> \n      str_split(\"\") |> \n      reduce(rbind) |> \n      unname()\n  })) |> \n  pull(mtx) |> \n  map(\\(x) x == '#')\n```\n:::\n\n\n\nExtract numerical data from raw text input for regions (width, height, and vector of present counts by index):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregions <- input$regions |> \n  pull(txt) |> \n  unglue_data(\"{w}x{h}: {shapes}\", convert = TRUE) |> \n  mutate(shapes = map(shapes, \\(x) as.numeric(str_split_1(x, \" \"))))\n```\n:::\n\n\n\n## Part 1\n\nWith hint from Reddit user [u/vash3r](https://www.reddit.com/r/adventofcode/comments/1pkje0o/comment/ntlj4ug/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button), a naive solution is sufficient. The least efficient packing solution for each region is if each present fits inside a full 3x3 box. From the opposite side, boxes will never fit if their total occupied area is greater than the area of the available region. \n\nImposing these simple constraints, we see that all regions from the input are either sufficiently large or too small -- no packing solution is necessary.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npresent_area <- map_dbl(presents, sum)\n\nregions |> \n  mutate(\n    shapes_count = map_dbl(shapes, sum),\n    shapes_area  = map_dbl(shapes, \\(present) sum(present * present_area)),\n    fits = case_when(\n      w %/% 3 * h %/% 3 >= shapes_count ~ 'YES',\n      w * h <= shapes_area ~ 'NO',\n      .default = 'UNKNOWN'\n    )\n  ) |> \n  summarize(n_regions = n(), .by = fits)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}