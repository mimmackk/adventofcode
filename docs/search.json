[
  {
    "objectID": "2020/R/day09.html",
    "href": "2020/R/day09.html",
    "title": "Day 9",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file into a numeric vector:\n\ninput &lt;- scan(\"../input/day09.txt\")\n\nDefine the preamble length parameter:\n\npreamble &lt;- 25",
    "crumbs": [
      "2020",
      "Day 9"
    ]
  },
  {
    "objectID": "2020/R/day09.html#setup",
    "href": "2020/R/day09.html#setup",
    "title": "Day 9",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file into a numeric vector:\n\ninput &lt;- scan(\"../input/day09.txt\")\n\nDefine the preamble length parameter:\n\npreamble &lt;- 25",
    "crumbs": [
      "2020",
      "Day 9"
    ]
  },
  {
    "objectID": "2020/R/day09.html#part-1",
    "href": "2020/R/day09.html#part-1",
    "title": "Day 9",
    "section": "Part 1",
    "text": "Part 1\nFind the first number in the list (after the preamble) which is not the sum of two of the 25 numbers before it:\n\ninvalid_num &lt;- imap(\n  tail(input, n = -preamble),\n  ~ input[1:preamble - 1 + .y] |&gt; \n    combn(2, simplify = FALSE) |&gt; \n    map_dbl(sum) |&gt; \n    setdiff(x = .x, y = _)\n) |&gt; \n  compact() |&gt; \n  pluck(1)",
    "crumbs": [
      "2020",
      "Day 9"
    ]
  },
  {
    "objectID": "2020/R/day09.html#part-2",
    "href": "2020/R/day09.html#part-2",
    "title": "Day 9",
    "section": "Part 2",
    "text": "Part 2\nDefine a function that starts at the first index and examines all following subsequences until their sum either equals or exceeds the invalid number. If it’s found, then return the sum of the minimum and maximum index in that range. If it overshoots, start over from the second index (and so on):\n\nfind_weakness &lt;- function(vec, target) {\n  idx_start &lt;- 1\n  \n  while (idx_start &lt; length(vec)) {\n    idx_end &lt;- idx_start + 1\n    \n    while (idx_end &lt;= length(vec)) {\n      range &lt;- vec[idx_start:idx_end]\n      \n      if (sum(range) == target)\n        return(min(range) + max(range))\n      if (sum(range) &gt; target)\n        break\n      \n      idx_end &lt;- idx_end + 1\n    }\n    idx_start &lt;- idx_start + 1\n  }\n}\n\nRun on puzzle input:\n\nfind_weakness(input, invalid_num)",
    "crumbs": [
      "2020",
      "Day 9"
    ]
  },
  {
    "objectID": "2020/R/day20.html",
    "href": "2020/R/day20.html",
    "title": "Day 20",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(stringi)\n\nDisable scientific notation:\n\noptions(scipen = 999)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day20.txt\", skip_empty_rows = TRUE)\n\nConvert text input into a list of tiles represented as matrices:\n\ntiles &lt;- input |&gt; \n  enframe(name = NULL) |&gt; \n  mutate(tile_id = as.numeric(str_extract(value, \"\\\\d+\"))) |&gt; \n  fill(tile_id, .direction = \"down\") |&gt; \n  filter(!str_starts(value, \"Tile\")) |&gt; \n  summarize(mtx = list(unlist(str_split(value, \"\"))), .by = tile_id) |&gt; \n  mutate(mtx = map(mtx, ~ matrix(.x, byrow = TRUE, nrow = sqrt(length(.x)))))\n\nDefine a helper function to flip a matrix horizontally:\n\nflip_mtx &lt;- \\(mtx) t(apply(mtx, MARGIN = 1, FUN = rev))\n\nDefine a helper function to rotate a matrix counterclockwise in multiples of 90 degrees:\n\nrotate_mtx &lt;- \\(mtx, deg = 90) {\n  reduce(\n    .x = seq(length.out = (deg %% 360 / 90)), \n    .f = \\(x, y) apply(t(x), 2, rev), \n    .init = mtx\n  )\n}",
    "crumbs": [
      "2020",
      "Day 20"
    ]
  },
  {
    "objectID": "2020/R/day20.html#setup",
    "href": "2020/R/day20.html#setup",
    "title": "Day 20",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(stringi)\n\nDisable scientific notation:\n\noptions(scipen = 999)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day20.txt\", skip_empty_rows = TRUE)\n\nConvert text input into a list of tiles represented as matrices:\n\ntiles &lt;- input |&gt; \n  enframe(name = NULL) |&gt; \n  mutate(tile_id = as.numeric(str_extract(value, \"\\\\d+\"))) |&gt; \n  fill(tile_id, .direction = \"down\") |&gt; \n  filter(!str_starts(value, \"Tile\")) |&gt; \n  summarize(mtx = list(unlist(str_split(value, \"\"))), .by = tile_id) |&gt; \n  mutate(mtx = map(mtx, ~ matrix(.x, byrow = TRUE, nrow = sqrt(length(.x)))))\n\nDefine a helper function to flip a matrix horizontally:\n\nflip_mtx &lt;- \\(mtx) t(apply(mtx, MARGIN = 1, FUN = rev))\n\nDefine a helper function to rotate a matrix counterclockwise in multiples of 90 degrees:\n\nrotate_mtx &lt;- \\(mtx, deg = 90) {\n  reduce(\n    .x = seq(length.out = (deg %% 360 / 90)), \n    .f = \\(x, y) apply(t(x), 2, rev), \n    .init = mtx\n  )\n}",
    "crumbs": [
      "2020",
      "Day 20"
    ]
  },
  {
    "objectID": "2020/R/day20.html#part-1",
    "href": "2020/R/day20.html#part-1",
    "title": "Day 20",
    "section": "Part 1",
    "text": "Part 1\nExtract each of the 4 borders from all tiles:\n\nborders &lt;- tiles |&gt; \n  mutate(\n    b1 = map_chr(mtx, ~ .x |&gt;        head(1) |&gt; str_flatten()),\n    b2 = map_chr(mtx, ~ .x |&gt; t() |&gt; tail(1) |&gt; str_flatten()),\n    b3 = map_chr(mtx, ~ .x |&gt;        tail(1) |&gt; str_flatten()),\n    b4 = map_chr(mtx, ~ .x |&gt; t() |&gt; head(1) |&gt; str_flatten()),\n  ) |&gt; \n  pivot_longer(\n    c(b1, b2, b3, b4), \n    names_to = \"border_dir\", \n    names_prefix = \"b\",\n    names_transform = as.integer,\n    values_to = \"border\"\n  )\n\nDetermine which borders match with one another:\n\nnbrs &lt;- cross_join(borders, borders, suffix = c(\"\", \"_nbr\")) |&gt; \n  select(-c(mtx, mtx_nbr)) |&gt; \n  filter(\n    tile_id != tile_id_nbr,\n    (border == border_nbr | border == stri_reverse(border_nbr))\n  )\n\nConfirm that each tile border matched with at most one other:\n\nnbrs |&gt; \n  filter(n() &gt; 1, .by = c(tile_id, border_dir)) |&gt; \n  nrow() |&gt; \n  case_match(0 ~ \"PASS\", .default = \"FAIL\")\n\nPull the list of corner tiles (those with only two matched borders):\n\ncorners &lt;- nbrs |&gt; \n  summarize(n_matches = n(), .by = tile_id) |&gt; \n  filter(n_matches == 2) |&gt; \n  pull(tile_id)\n\nMultiply together the IDs of the corners:\n\nprod(corners)",
    "crumbs": [
      "2020",
      "Day 20"
    ]
  },
  {
    "objectID": "2020/R/day20.html#part-2",
    "href": "2020/R/day20.html#part-2",
    "title": "Day 20",
    "section": "Part 2",
    "text": "Part 2\nPick one corner to place in the upper left of the grid (row 1, col 1) and set the common orientation for the rest of the tiles. Here, we choose the minimum corner index:\n\nopposite_dir &lt;- (1:4 + 1) %% 4 + 1\n\ninit &lt;- nbrs |&gt; \n  filter(tile_id == min(corners)) |&gt; \n  summarize(\n    row = 1,\n    col = 1,\n    dir_s = max(border_dir),\n    dir_e = min(border_dir),\n    dir_n = opposite_dir[dir_s],\n    dir_w = opposite_dir[dir_e],\n    .by = tile_id\n  ) |&gt; \n  select(tile_id, row, col, dir_n, dir_e, dir_s, dir_w)\n\nNow, we get the column order of the rest of the tiles in the first row by iteratively attaching them one-by-one and filling in their N/E/S/W directions:\n\ncur   &lt;- init\nn_prv &lt;- 0\n\nwhile(nrow(cur) != n_prv) {\n  \n  n_prv &lt;- nrow(cur)\n  \n  cur &lt;- cur |&gt;\n    left_join(nbrs, join_by(tile_id)) |&gt; \n    filter(!(tile_id_nbr %in% tile_id) & border_dir == dir_e) |&gt; \n    transmute(\n      tile_id = tile_id_nbr,\n      row = row,\n      col = col + 1,\n      dir_w = border_dir_nbr,\n      dir_e = opposite_dir[border_dir_nbr]\n    ) |&gt; \n    left_join(nbrs, join_by(tile_id)) |&gt; \n    filter(border_dir != dir_w, border_dir != dir_e) |&gt; \n    mutate(\n      dir_s = border_dir,\n      dir_n = opposite_dir[border_dir]\n    ) |&gt; \n    distinct(tile_id, row, col, dir_n, dir_e, dir_s, dir_w) |&gt; \n    bind_rows(cur)\n}\n\nfirst_row &lt;- cur\n\nNow that our first row is ordered and oriented, we attach and orient each of the following sets of rows, one full row at a time:\n\ncur &lt;- first_row\nn_prv &lt;- 0\n\nwhile(nrow(cur) != n_prv) {\n  \n  n_prv &lt;- nrow(cur)\n  \n  nxt &lt;- cur |&gt;\n    left_join(nbrs, join_by(tile_id)) |&gt; \n    filter(!(tile_id_nbr %in% tile_id) & border_dir == dir_s) |&gt; \n    transmute(\n      tile_id = tile_id_nbr,\n      row = row + 1,\n      col = col,\n      dir_n = border_dir_nbr,\n      dir_s = opposite_dir[border_dir_nbr]\n    ) \n  \n  cur &lt;- nxt |&gt; \n    left_join(nbrs, join_by(tile_id)) |&gt; \n    filter(border_dir != dir_n, border_dir != dir_s) |&gt; \n    \n    select(-c(border, border_nbr)) |&gt; \n    left_join(\n      select(nxt, tile_id, col_nbr = col), \n      join_by(x$tile_id_nbr == y$tile_id)\n    ) |&gt; \n    mutate(\n      dir_w = if_else(col_nbr == col - 1, border_dir, opposite_dir[border_dir]),\n      dir_e = opposite_dir[dir_w]\n    ) |&gt; \n    distinct(tile_id, row, col, dir_n, dir_e, dir_s, dir_w) |&gt; \n    bind_rows(cur)\n}\n\norientations &lt;- cur\n\nConvert the completed N/S/E/W alignment mapping into a set of flip & rotation instructions, then apply the transformation to each tile:\n\ntransformation &lt;- orientations |&gt; \n  left_join(tiles, join_by(tile_id)) |&gt; \n  mutate(\n    flip = (dir_n == (dir_e %% 4 + 1)),\n    rotate = if_else(flip, ((5 - dir_n) %% 4) * 90, (dir_n - 1) * 90),\n    mtx = if_else(flip, map(mtx, flip_mtx), mtx),\n    mtx = map2(mtx, rotate, rotate_mtx)\n  ) \n\nTrim the borders of each tile and merge into one large image:\n\nimage &lt;- transformation |&gt; \n  arrange(row, col) |&gt; \n  mutate(mtx = map(mtx, ~ .x[2:(nrow(.x) - 1), 2:(ncol(.x) - 1)])) |&gt; \n  summarize(mtx = list(do.call(cbind, mtx)), .by = row) |&gt; \n  summarize(mtx = list(do.call(rbind, mtx))) |&gt; \n  pull(mtx) |&gt; \n  pluck(1)\n\nConvert the sea monster text into a set of matrix indices requiring a ‘#’ character:\n\nmonster &lt;- str_c(\n  \"                  # \",\n  \"#    ##    ##    ###\",\n  \" #  #  #  #  #  #   \"\n) |&gt; \n  str_split_1(\"\") |&gt; \n  matrix(byrow = TRUE, nrow = 3)\n\nmonster_idx &lt;- which(monster == '#')\n\nGenerate the coordinates for all monster_width by monster_height submatrices of the image:\n\nsubmatrix_coords &lt;- expand_grid(\n  row = map(1:(nrow(image) - nrow(monster) + 1), ~ .x:(nrow(monster) + .x - 1)),\n  col = map(1:(ncol(image) - ncol(monster) + 1), ~ .x:(ncol(monster) + .x - 1))\n)\n\nGenerate all rotated & flipped variants of the image:\n\nvariants &lt;- expand_grid(\n  flip = c(FALSE, TRUE),\n  rotate = c(0, 90, 180, 270)\n) |&gt; \n  mutate(\n    variant_id = row_number(),\n    mtx = rep(list(image), max(variant_id)),\n    mtx = if_else(flip, map(mtx, flip_mtx), mtx),\n    mtx = map2(mtx, rotate, rotate_mtx)\n  )\n\nScan all submatrices of all variants and locate the indices of the sea monsters:\n\nmonster_locn &lt;- variants |&gt; \n  cross_join(submatrix_coords) |&gt; \n  mutate(\n    subimg = pmap(lst(mtx, row, col), ~ ..1[..2, ..3]),\n    idx = map(subimg, ~ which(.x == '#')),\n    is_monster = map_lgl(idx, ~ length(setdiff(monster_idx, .x)) == 0)\n  ) |&gt; \n  filter(is_monster)\n\nConvert the indicies of the monster ‘#’ in the submatrix to the full image:\n\nmonster_idx_img &lt;- monster_locn |&gt; \n  mutate(\n    monster_idx = pmap(lst(mtx, row, col), \\(mtx, rows, cols) {\n      ((monster_idx - 1) %/% nrow(monster) + min(cols) - 1) * nrow(mtx) +\n      ((monster_idx - 1) %%  nrow(monster) + min(rows))\n    })\n  ) |&gt; \n  pull(monster_idx) |&gt; \n  unlist()\n\nPull the indices of all ‘#’ in the full image, minus those of the monsters, and count the remaining values:\n\nimg_rotated &lt;- monster_locn |&gt; \n  pull(mtx) |&gt; \n  pluck(1)\n\nwhich(img_rotated == '#') |&gt; \n  setdiff(monster_idx_img) |&gt; \n  length()",
    "crumbs": [
      "2020",
      "Day 20"
    ]
  },
  {
    "objectID": "2020/R/day22.html",
    "href": "2020/R/day22.html",
    "title": "Day 22",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day22.txt\", skip_empty_rows = TRUE)\n\nConvert text input to two lists of values, one for each player:\n\ninit &lt;- input |&gt;\n  keep(~ str_detect(.x, \"^\\\\d+$\")) |&gt;\n  as.integer() %&gt;%\n  split(cut(seq_along(.), 2, labels = FALSE)) |&gt; \n  unname()",
    "crumbs": [
      "2020",
      "Day 22"
    ]
  },
  {
    "objectID": "2020/R/day22.html#setup",
    "href": "2020/R/day22.html#setup",
    "title": "Day 22",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day22.txt\", skip_empty_rows = TRUE)\n\nConvert text input to two lists of values, one for each player:\n\ninit &lt;- input |&gt;\n  keep(~ str_detect(.x, \"^\\\\d+$\")) |&gt;\n  as.integer() %&gt;%\n  split(cut(seq_along(.), 2, labels = FALSE)) |&gt; \n  unname()",
    "crumbs": [
      "2020",
      "Day 22"
    ]
  },
  {
    "objectID": "2020/R/day22.html#part-1",
    "href": "2020/R/day22.html#part-1",
    "title": "Day 22",
    "section": "Part 1",
    "text": "Part 1\nDefine a helper function to play a single round:\n\nplay_round &lt;- function(players) {\n  top_cards &lt;- players |&gt; \n    list_transpose() |&gt; \n    pluck(1) |&gt; \n    unname()\n  \n  winner &lt;- which.max(top_cards)\n\n  players |&gt; \n    map(~ tail(.x, -1)) |&gt; \n    modify_in(winner, ~ c(.x, sort(top_cards, decreasing = TRUE)))\n}\n\nDefine a helper function to score a winning hand:\n\nscore &lt;- function(x) {\n  map2_dbl(x, length(x):1, prod) |&gt; \n    sum()\n}\n\nPlay a game using the provided starting hand and score the winner:\n\ncur &lt;- init\n\nwhile (every(cur, ~ length(.x) &gt; 0)) {\n  cur &lt;- play_round(cur)\n}\n\ncur |&gt; \n  unlist() |&gt; \n  score()",
    "crumbs": [
      "2020",
      "Day 22"
    ]
  },
  {
    "objectID": "2020/R/day22.html#part-2",
    "href": "2020/R/day22.html#part-2",
    "title": "Day 22",
    "section": "Part 2",
    "text": "Part 2\nRedefine the helper function that plays a single round to adjust to the new rules:\n\nplay_round &lt;- function(players) {\n  \n  top_cards &lt;- c(players[[1]][[1]], players[[2]][[1]])\n  \n  can_recurse &lt;- players |&gt; \n    map_lgl(~ length(.x) &gt; pluck(.x, 1)) |&gt; \n    all()\n  \n  if (!can_recurse) {\n    winner &lt;- which.max(top_cards)\n  } else {\n    winner &lt;- players |&gt;\n      map(~ .x[seq(from = 2, length.out = pluck(.x, 1))]) |&gt; \n      play_game() |&gt; \n      map_int(length) |&gt; \n      which.max()\n  }\n  \n  players |&gt; \n    map(~ tail(.x, -1)) |&gt; \n    modify_in(winner, ~ c(.x, top_cards[c(winner, setdiff(1:2, winner))]))\n}\n\nDefine a helper function to play the game while the game state to avoid infinite recursion:\n\nplay_game &lt;- function(players) {\n  game_hist &lt;- c()\n  \n  while (every(players, ~ length(.x) &gt; 0)) {\n    cur_state &lt;- players |&gt; \n      map_chr(~ str_flatten(.x, \",\")) |&gt; \n      str_flatten(\"|\")\n    \n    if (cur_state %in% game_hist) {\n      return(assign_in(players, 2, integer(0)))\n    } else {\n      game_hist &lt;- c(\n        game_hist, \n        cur_state,\n        players |&gt; \n          map_chr(~ str_flatten(.x, \",\")) |&gt; \n          rev() |&gt; \n          str_flatten(\"|\")\n      )\n      players &lt;- play_round(players)\n    }\n  }\n  \n  players\n}\n\nRun the game on the puzzle input and score the winning player:\n\ninit |&gt; \n  play_game() |&gt; \n  unlist() |&gt; \n  score()",
    "crumbs": [
      "2020",
      "Day 22"
    ]
  },
  {
    "objectID": "2020/R/day24.html",
    "href": "2020/R/day24.html",
    "title": "Day 24",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file and parse into E/W/NE/NW/SE/SW instructions:\n\ninput &lt;- read_lines(\"../input/day24.txt\") |&gt; \n  str_replace_all(\"([ns][ew]|(?&lt;![ns])[we])\", \" \\\\1 \") |&gt; \n  str_squish() |&gt; \n  str_split(\" \")",
    "crumbs": [
      "2020",
      "Day 24"
    ]
  },
  {
    "objectID": "2020/R/day24.html#setup",
    "href": "2020/R/day24.html#setup",
    "title": "Day 24",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file and parse into E/W/NE/NW/SE/SW instructions:\n\ninput &lt;- read_lines(\"../input/day24.txt\") |&gt; \n  str_replace_all(\"([ns][ew]|(?&lt;![ns])[we])\", \" \\\\1 \") |&gt; \n  str_squish() |&gt; \n  str_split(\" \")",
    "crumbs": [
      "2020",
      "Day 24"
    ]
  },
  {
    "objectID": "2020/R/day24.html#part-1",
    "href": "2020/R/day24.html#part-1",
    "title": "Day 24",
    "section": "Part 1",
    "text": "Part 1\nUsing a double-width coordinate system we convert each E/W/etc direction into a coordinate value (represented by complex numbers):\n\ndirs &lt;- c(\n  \"e\"  =  2 + 0i,\n  \"w\"  = -2 + 0i,\n  \"ne\" =  1 + 1i,\n  \"nw\" = -1 + 1i,\n  \"se\" =  1 - 1i,\n  \"sw\" = -1 - 1i\n)\n\nUsing a reference tile with coordinates (0, 0), we convert each of our directional instructions into a set of final tile coordinates:\n\ncoords &lt;- map_vec(input, \\(x) sum(dirs[x]))\n\nDetermine which tiles were flipped an odd number of times:\n\nblack &lt;- tibble(tile = coords) |&gt; \n  summarise(flips = n(), .by = tile) |&gt; \n  filter(flips %% 2 == 1) |&gt; \n  pull(tile)\n\nCount the black tiles:\n\nlength(black)",
    "crumbs": [
      "2020",
      "Day 24"
    ]
  },
  {
    "objectID": "2020/R/day24.html#part-2",
    "href": "2020/R/day24.html#part-2",
    "title": "Day 24",
    "section": "Part 2",
    "text": "Part 2\nDefine a function which, when given a list of black tiles, returns a new list of black tiles after the flipping has occurred:\n\nflip &lt;- function(init) {\n  \n  nbrs &lt;- tibble(tile = init) |&gt; \n    expand_grid(neighbor_dir = dirs) |&gt; \n    mutate(\n      neighbor_coord = tile + neighbor_dir,\n      neighbor_color = if_else(neighbor_coord %in% init, \"black\", \"white\")\n    )\n  \n  black_keep &lt;- nbrs |&gt;\n    summarize(\n      new_color = case_match(\n        sum(neighbor_color == \"black\"),\n        c(1, 2) ~ \"black\",\n        .default = \"white\"\n      ), \n      .by = tile\n    ) |&gt; \n    filter(new_color == \"black\") |&gt; \n    pull(tile)\n  \n  black_new &lt;- nbrs |&gt; \n    filter(neighbor_color == \"white\") |&gt; \n    filter(n() == 2, .by = neighbor_coord) |&gt; \n    pull(neighbor_coord) |&gt; \n    unique()\n  \n  c(black_keep, black_new)\n  \n}\n\nRun 100 days worth of flips:\n\nfinal &lt;- reduce(1:100, \\(x, y) flip(x), .init = black)\n\nCount how many black tiles remain at the end:\n\nlength(final)",
    "crumbs": [
      "2020",
      "Day 24"
    ]
  },
  {
    "objectID": "2020/R/day19.html",
    "href": "2020/R/day19.html",
    "title": "Day 19",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day19.txt\", skip_empty_rows = TRUE)\n\nSeparate input into rules & messages:\n\nmessages &lt;- discard(input, ~ str_starts(.x, \"^\\\\d\"))\n\nrules &lt;- input |&gt;\n  keep(~ str_starts(.x, \"^\\\\d\")) |&gt; \n  unglue_data(\n    c(\n      \"{rule_id}: {rule=[ |0-9]+}\", \n      \"{rule_id}: \\\"{rule}\\\"\"\n    ), \n    convert = FALSE\n  ) |&gt; \n  mutate(rule = str_split(rule, \" \\\\| \")) |&gt; \n  unnest_longer(rule, indices_to = \"alternate\") |&gt; \n  mutate(rule = str_split(rule, \" \")) |&gt; \n  unnest_longer(rule, indices_to = \"order\", values_to = \"rule_component\")",
    "crumbs": [
      "2020",
      "Day 19"
    ]
  },
  {
    "objectID": "2020/R/day19.html#setup",
    "href": "2020/R/day19.html#setup",
    "title": "Day 19",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day19.txt\", skip_empty_rows = TRUE)\n\nSeparate input into rules & messages:\n\nmessages &lt;- discard(input, ~ str_starts(.x, \"^\\\\d\"))\n\nrules &lt;- input |&gt;\n  keep(~ str_starts(.x, \"^\\\\d\")) |&gt; \n  unglue_data(\n    c(\n      \"{rule_id}: {rule=[ |0-9]+}\", \n      \"{rule_id}: \\\"{rule}\\\"\"\n    ), \n    convert = FALSE\n  ) |&gt; \n  mutate(rule = str_split(rule, \" \\\\| \")) |&gt; \n  unnest_longer(rule, indices_to = \"alternate\") |&gt; \n  mutate(rule = str_split(rule, \" \")) |&gt; \n  unnest_longer(rule, indices_to = \"order\", values_to = \"rule_component\")",
    "crumbs": [
      "2020",
      "Day 19"
    ]
  },
  {
    "objectID": "2020/R/day19.html#part-1",
    "href": "2020/R/day19.html#part-1",
    "title": "Day 19",
    "section": "Part 1",
    "text": "Part 1\nIteratively build rules using regex to represent ‘or’ statements:\n\nfinalized &lt;- rules |&gt; \n  filter(str_detect(rule_component, \"^(a|b)+$\")) |&gt; \n  transmute(\n    rule_id, \n    rule_value = rule_component,\n    len = 1,\n  )\n\nwhile (!(0 %in% finalized$rule_id)) {\n  finalized &lt;- rules |&gt; \n    anti_join(finalized, join_by(rule_id)) |&gt; \n    left_join(finalized, join_by(x$rule_component == y$rule_id)) |&gt; \n    filter(all(!is.na(rule_value)), .by = rule_id) |&gt; \n    summarize(\n      rule_value = str_flatten(rule_value), \n      len = sum(len),\n      .by = c(rule_id, alternate)\n    ) |&gt; \n    summarize(\n      rule_value = str_flatten(rule_value, collapse = \"|\"),\n      len = min(len),\n      .by = rule_id\n    ) |&gt; \n    mutate(\n      rule_value = case_when(\n        str_detect(rule_value, \"\\\\|\") ~ str_glue(\"({rule_value})\"),\n        .default = rule_value\n      )\n    ) |&gt; \n    bind_rows(finalized)\n}\n\nCount how many messages match the final row 0 regex:\n\nrule_zero &lt;- finalized |&gt; \n  filter(rule_id == 0) |&gt; \n  pull(rule_value)\n\nmessages |&gt; \n  keep(~ str_detect(.x, str_glue(\"^{rule_zero}$\"))) |&gt; \n  length()",
    "crumbs": [
      "2020",
      "Day 19"
    ]
  },
  {
    "objectID": "2020/R/day19.html#part-2",
    "href": "2020/R/day19.html#part-2",
    "title": "Day 19",
    "section": "Part 2",
    "text": "Part 2\nThe modified version of rule 8 could be interpreted as “1 or more copies of rule 42”.\nThe modified version of rule 11 can be interpreted as: “one or more copies of rule 42, followed by an equal number of copies of rule 31.”\nPutting these together, the new version of rule 0, which was orignally “8 11”, can now be read as “n &gt;= 1 copies of rule 31 proceeded by at least n + 1 copies of rule 42.”\nBased on the length of rule 31, rule 42, and the longest message in our input, we can construct all possible combinations of these rules that follow the above pattern:\n\nrule42 &lt;- finalized |&gt; filter(rule_id == 42) |&gt; pull(rule_value)\nrule31 &lt;- finalized |&gt; filter(rule_id == 31) |&gt; pull(rule_value)\nlen_42 &lt;- finalized |&gt; filter(rule_id == 42) |&gt; pull(len)\nlen_31 &lt;- finalized |&gt; filter(rule_id == 31) |&gt; pull(len)\nlen_max &lt;- max(str_length(messages))\n\nrule0 &lt;- expand_grid(n_42 = 1:len_max, n_31 = 1:len_max) |&gt; \n  filter(n_42 &gt;= n_31 + 1) |&gt; \n  filter(n_42 * len_42 + n_31 * len_31 &lt;= len_max) |&gt; \n  pmap_chr(~ str_c(\"^\", rule42, \"{\", ..1, \"}\", rule31, \"{\", ..2, \"}$\"))\n\nFor all legal variations of the rule 0 regex, check if any messages are valid. Count the total number of possible valid messages.\n\nrule0 |&gt; \n  map(~ str_detect(messages, .x)) |&gt; \n  transpose() |&gt; \n  map_lgl(~ any(unlist(.x))) |&gt; \n  sum()",
    "crumbs": [
      "2020",
      "Day 19"
    ]
  },
  {
    "objectID": "2020/R/day14.html",
    "href": "2020/R/day14.html",
    "title": "Day 14",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(bit64)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day14.txt\")\n\nConvert text strings to a data frame of memory locations, values, and bit masks:\n\ndf &lt;- input |&gt; \n  unglue_data(c(\"mask = {mask}\", \"mem[{loc}] = {value}\"), convert = TRUE) |&gt; \n  fill(mask, .direction = \"down\") |&gt; \n  filter(!is.na(loc))",
    "crumbs": [
      "2020",
      "Day 14"
    ]
  },
  {
    "objectID": "2020/R/day14.html#setup",
    "href": "2020/R/day14.html#setup",
    "title": "Day 14",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(bit64)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day14.txt\")\n\nConvert text strings to a data frame of memory locations, values, and bit masks:\n\ndf &lt;- input |&gt; \n  unglue_data(c(\"mask = {mask}\", \"mem[{loc}] = {value}\"), convert = TRUE) |&gt; \n  fill(mask, .direction = \"down\") |&gt; \n  filter(!is.na(loc))",
    "crumbs": [
      "2020",
      "Day 14"
    ]
  },
  {
    "objectID": "2020/R/day14.html#part-1",
    "href": "2020/R/day14.html#part-1",
    "title": "Day 14",
    "section": "Part 1",
    "text": "Part 1\nCreate a helper function which takes an integer value and a 36-bit mask and applies the mask to the integer:\n\nmask_int &lt;- function(value, mask) {\n  \n  value |&gt;\n    \n    # Convert to a 36-bit binary string\n    as.integer64() |&gt;\n    as.bitstring() |&gt;\n    str_sub(start = 29L) |&gt; \n    str_split(\"\") |&gt; \n  \n    # Apply the bitwise mask\n    map2(str_split(mask, \"\"), \\(bin, mask) {\n      case_match(mask, \"X\" ~ bin, c(\"0\", \"1\") ~ mask)\n    }) |&gt; \n    \n    # Convert back from binary to integer format\n    map_vec(\\(x) {\n      c(rep(0, 28), x) |&gt;\n        str_flatten() |&gt;\n        structure(class = \"bitstring\") |&gt;\n        as.integer64()\n    })\n}\n\nApply the mask to each value. Then, for each memory location, pull the last saved value and sum the result:\n\ndf |&gt; \n  mutate(value_masked = mask_int(value, mask)) |&gt; \n  summarize(value = last(value_masked), .by = loc) |&gt; \n  pull(value) |&gt; \n  sum()",
    "crumbs": [
      "2020",
      "Day 14"
    ]
  },
  {
    "objectID": "2020/R/day14.html#part-2",
    "href": "2020/R/day14.html#part-2",
    "title": "Day 14",
    "section": "Part 2",
    "text": "Part 2\nExtract all distinct masks from the dataset:\n\nmasks &lt;- df |&gt; \n  distinct(mask) |&gt; \n  mutate(\n    mask_id = row_number(),\n    floating_idx = str_locate_all(mask, \"X\"),\n    floating_idx = map(floating_idx, \\(mtx) mtx[, 1]),\n    floating_n = map_int(floating_idx, length)\n  )\n\nEach mask has a certain number of possible variants based on how many floating values are in the mask string (1X = 1 variant, 2X = 4 variants, etc). Pre-compute the possible 1/0 combinations for each number of variants:\n\nvariants &lt;- map(1:max(masks$floating_n), \\(n) {\n  do.call(crossing, args = rep(list(c(\"0\", \"1\")), n)) |&gt; \n    mutate(variant_num = row_number()) |&gt; \n    pivot_longer(-variant_num, names_to = \"idx_order\") |&gt; \n    mutate(idx_order = as.integer(factor(idx_order))) |&gt; \n    arrange(variant_num, idx_order) |&gt; \n    summarize(value = list(value), .by = variant_num)\n}) |&gt; \n  enframe(name = \"floating_n\", value = \"substitutions\")\n\nFor each mask, attach all possible digit variants and compute the new mask:\n\nmask_new &lt;- masks |&gt; \n  mutate(mask = str_split(mask, \"\")) |&gt; \n  left_join(variants, join_by(floating_n)) |&gt; \n  unnest(substitutions) |&gt; \n  mutate(\n    mask_new = pmap(lst(mask, floating_idx, value), ~ replace(..1, ..2, ..3)),\n    mask_new = map2(mask, mask_new, \\(orig, new) {\n      case_match(orig, \"0\" ~ \"X\", \"1\" ~ \"1\", \"X\" ~ new)\n    }),\n    across(c(mask, mask_new), \\(col) map_chr(col, str_flatten))\n  ) |&gt; \n  distinct(mask, mask_new)\n\nRe-attach the new location masks to the original dataset. Apply the mask to each location to get the new location values, then take the last value written to each location and sum.\n\ndf |&gt; \n  left_join(mask_new, join_by(mask)) |&gt; \n  mutate(loc_masked = mask_int(loc, mask_new)) |&gt; \n  summarize(value = last(value), .by = loc_masked) |&gt; \n  pull(value) |&gt; \n  sum()",
    "crumbs": [
      "2020",
      "Day 14"
    ]
  },
  {
    "objectID": "2020/R/day15.html",
    "href": "2020/R/day15.html",
    "title": "Day 15",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- scan(\"../input/day15.txt\", sep = \",\")",
    "crumbs": [
      "2020",
      "Day 15"
    ]
  },
  {
    "objectID": "2020/R/day15.html#setup",
    "href": "2020/R/day15.html#setup",
    "title": "Day 15",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- scan(\"../input/day15.txt\", sep = \",\")",
    "crumbs": [
      "2020",
      "Day 15"
    ]
  },
  {
    "objectID": "2020/R/day15.html#part-1",
    "href": "2020/R/day15.html#part-1",
    "title": "Day 15",
    "section": "Part 1",
    "text": "Part 1\nSimple, recursive implementation for small n:\n\nnth_num &lt;- function(x, n = 2020) {\n  if (length(x) == n)\n    head(x, 1)\n  else\n    match(head(x, 1), tail(x, -1)) |&gt; \n      replace_na(0) |&gt; \n      c(x) |&gt; \n      nth_num(n)\n}\n\nRun on puzzle input:\n\nnth_num(input, 2020)",
    "crumbs": [
      "2020",
      "Day 15"
    ]
  },
  {
    "objectID": "2020/R/day15.html#part-2",
    "href": "2020/R/day15.html#part-2",
    "title": "Day 15",
    "section": "Part 2",
    "text": "Part 2\nFor large n, we leverage a hash table for performance:\n\nnth_num &lt;- function(init, n) {\n\n  init &lt;- as.character(init)\n  last &lt;- tail(init,  1)\n  init &lt;- head(init, -1)\n  hash &lt;- new.env()\n  \n  for (i in 1:length(init)) {\n    hash[[init[[i]]]] &lt;- i\n  }\n  \n  i &lt;- length(init) + 1\n  \n  while (i &lt; n) {\n    if (exists(last, hash)) {\n      nxt &lt;- as.character(i - hash[[last]])\n    } else {\n      nxt &lt;- \"0\"\n    }\n  \n    hash[[last]] &lt;- i\n    last &lt;- nxt\n    i &lt;- i + 1\n  }\n  \n  nxt\n}\n\nRun on puzzle input:\n\nnth_num(input, 30000000)",
    "crumbs": [
      "2020",
      "Day 15"
    ]
  },
  {
    "objectID": "2020/R/day17.html",
    "href": "2020/R/day17.html",
    "title": "Day 17",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file into a data frame of x & y coordinates with TRUE/FALSE values for active state:\n\ninput &lt;- read_lines(\"../input/day17.txt\") |&gt; \n  map(~ str_split_1(.x, \"\") == \"#\") |&gt; \n  enframe(name = \"x\", value = \"is_active\") |&gt;   \n  unnest_longer(is_active, indices_to = \"y\") |&gt;\n  mutate(z = 0L)",
    "crumbs": [
      "2020",
      "Day 17"
    ]
  },
  {
    "objectID": "2020/R/day17.html#setup",
    "href": "2020/R/day17.html#setup",
    "title": "Day 17",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file into a data frame of x & y coordinates with TRUE/FALSE values for active state:\n\ninput &lt;- read_lines(\"../input/day17.txt\") |&gt; \n  map(~ str_split_1(.x, \"\") == \"#\") |&gt; \n  enframe(name = \"x\", value = \"is_active\") |&gt;   \n  unnest_longer(is_active, indices_to = \"y\") |&gt;\n  mutate(z = 0L)",
    "crumbs": [
      "2020",
      "Day 17"
    ]
  },
  {
    "objectID": "2020/R/day17.html#part-1",
    "href": "2020/R/day17.html#part-1",
    "title": "Day 17",
    "section": "Part 1",
    "text": "Part 1\nCreate a data frame of x/y/z adjustments that can join on any coordinate to get its full set of neighbors:\n\nnbr &lt;- expand_grid(x = -1:1, y = -1:1, z = -1:1) |&gt; \n  filter(!(x == 0 & y == 0 & z == 0))\n\nDefine a function to cycles through the initiation process n times, iteratively comparing neighboring cubes to determine the next state with each cyle:\n\ncycle &lt;- function(grid, n = 6) {\n  \n  for (i in 1:n) {\n    grid &lt;- grid |&gt; \n      cross_join(nbr, suffix = c(\"\", \"_nbr\")) |&gt; \n      mutate(\n        x = x + x_nbr,\n        y = y + y_nbr,\n        z = z + z_nbr\n      ) |&gt; \n      summarize(nbrs = sum(is_active), .by = c(x, y, z)) |&gt; \n      left_join(select(grid, x, y, z, is_active), join_by(x, y, z)) |&gt;\n      mutate(is_active = replace_na(is_active, FALSE)) |&gt; \n      transmute(x, y, z, is_active = (nbrs == 3) | (is_active & nbrs == 2))\n  }\n  \n  grid\n  \n}\n\nRun on puzzle input:\n\ncycle(input) |&gt; \n  pull(is_active) |&gt; \n  sum()",
    "crumbs": [
      "2020",
      "Day 17"
    ]
  },
  {
    "objectID": "2020/R/day17.html#part-2",
    "href": "2020/R/day17.html#part-2",
    "title": "Day 17",
    "section": "Part 2",
    "text": "Part 2\nExtend the adjustment dataframe to accommodate a fourth dimension:\n\nnbr &lt;- expand_grid(x = -1:1, y = -1:1, z = -1:1, w = -1:1) |&gt; \n  filter(!(x == 0 & y == 0 & z == 0 & w == 0))\n\nExtend the cycle function to accommodate a fourth dimension:\n\ncycle &lt;- function(grid, n = 6) {\n  \n  for (i in 1:n) {\n    grid &lt;- grid |&gt; \n      cross_join(nbr, suffix = c(\"\", \"_nbr\")) |&gt; \n      mutate(\n        x = x + x_nbr,\n        y = y + y_nbr,\n        z = z + z_nbr,\n        w = w + w_nbr\n      ) |&gt; \n      summarize(nbrs = sum(is_active), .by = c(x, y, z, w)) |&gt; \n      left_join(select(grid, x, y, z, w, is_active), join_by(x, y, z, w)) |&gt;\n      mutate(is_active = replace_na(is_active, FALSE)) |&gt; \n      transmute(x, y, z, w, is_active = (nbrs == 3) | (is_active & nbrs == 2))\n  }\n  \n  grid\n  \n}\n\nRun on puzzle input:\n\ninput |&gt; \n  mutate(w = 0L) |&gt; \n  cycle() |&gt; \n  pull(is_active) |&gt; \n  sum()",
    "crumbs": [
      "2020",
      "Day 17"
    ]
  },
  {
    "objectID": "2020/R/day02.html",
    "href": "2020/R/day02.html",
    "title": "Day 2",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead and parse text input from file:\n\ninput &lt;- read_lines(\"../input/day02.txt\") |&gt; \n  unglue_data(\"{min}-{max} {chr}: {pwd}\", convert = TRUE)",
    "crumbs": [
      "2020",
      "Day 2"
    ]
  },
  {
    "objectID": "2020/R/day02.html#setup",
    "href": "2020/R/day02.html#setup",
    "title": "Day 2",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead and parse text input from file:\n\ninput &lt;- read_lines(\"../input/day02.txt\") |&gt; \n  unglue_data(\"{min}-{max} {chr}: {pwd}\", convert = TRUE)",
    "crumbs": [
      "2020",
      "Day 2"
    ]
  },
  {
    "objectID": "2020/R/day02.html#part-1",
    "href": "2020/R/day02.html#part-1",
    "title": "Day 2",
    "section": "Part 1",
    "text": "Part 1\nCount the occurrences of the designated character in each password and determine whether it falls within the bounds. Count how many passwords are valid.\n\ninput |&gt; \n  mutate(count = str_count(pwd, chr)) |&gt; \n  filter(between(count, min, max)) |&gt; \n  nrow()",
    "crumbs": [
      "2020",
      "Day 2"
    ]
  },
  {
    "objectID": "2020/R/day02.html#part-2",
    "href": "2020/R/day02.html#part-2",
    "title": "Day 2",
    "section": "Part 2",
    "text": "Part 2\nExtract the characters at the indicated indices of each password, and count how many passwords have exactly 1 one of those positions equal to the desired character:\n\ninput |&gt; \n  mutate(\n    idx = map2(min, max, c),\n    str = str_sub_all(pwd, start = idx, end = idx),\n    is_valid = map2_int(str, chr, ~ sum(.x == .y)) == 1\n  ) |&gt; \n  filter(is_valid) |&gt; \n  nrow()",
    "crumbs": [
      "2020",
      "Day 2"
    ]
  },
  {
    "objectID": "2020/R/day12.html",
    "href": "2020/R/day12.html",
    "title": "Day 12",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file into a dataframe, reading actions & values into separate columns:\n\ninput &lt;- read_lines(\"../input/day12.txt\") |&gt; \n  unglue_data(\"{action=[A-Z]}{value=\\\\d+}\", convert = TRUE)",
    "crumbs": [
      "2020",
      "Day 12"
    ]
  },
  {
    "objectID": "2020/R/day12.html#setup",
    "href": "2020/R/day12.html#setup",
    "title": "Day 12",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file into a dataframe, reading actions & values into separate columns:\n\ninput &lt;- read_lines(\"../input/day12.txt\") |&gt; \n  unglue_data(\"{action=[A-Z]}{value=\\\\d+}\", convert = TRUE)",
    "crumbs": [
      "2020",
      "Day 12"
    ]
  },
  {
    "objectID": "2020/R/day12.html#part-1",
    "href": "2020/R/day12.html#part-1",
    "title": "Day 12",
    "section": "Part 1",
    "text": "Part 1\nDefine the cardinal directions in clockwise order, starting from E:\n\ncardinal_dirs &lt;- c(\"E\", \"S\", \"W\", \"N\")  \n\nConvert all forward/turn actions into N/S/E/W actions:\n\nsteps &lt;- input |&gt; \n  mutate(\n    turn = value / 90 * case_match(action, \"R\" ~ 1, \"L\" ~ -1, .default = 0),\n    fdir = cardinal_dirs[cumsum(turn) %% 4 + 1]\n  ) |&gt; \n  mutate(action = case_match(action, \"F\" ~ fdir, .default = action)) |&gt; \n  filter(action %in% cardinal_dirs) |&gt; \n  select(action, value)\n\nCompute the Manhattan distance from the starting point to the final end point:\n\nsteps |&gt; \n  mutate(\n    v = case_match(action, \"N\" ~ value, \"S\" ~ -value, .default = 0),\n    h = case_match(action, \"E\" ~ value, \"W\" ~ -value, .default = 0)\n  ) |&gt; \n  summarize(dist = abs(sum(v)) + abs(sum(h))) |&gt; \n  pull(dist)",
    "crumbs": [
      "2020",
      "Day 12"
    ]
  },
  {
    "objectID": "2020/R/day12.html#part-2",
    "href": "2020/R/day12.html#part-2",
    "title": "Day 12",
    "section": "Part 2",
    "text": "Part 2\nTreat each set of waypoint adjustments followed by a ship movement as a group:\n\ninput_grouped &lt;- input |&gt; \n  mutate(group_id = cumsum(lag(action, default = \"\") == \"F\"))\n\nFor each group of waypoint adjustments, apply all shifts and rotations to get a final vector that will determine the direction of the ship’s movement:\n\nwp_init &lt;- 1 + 10i\n\nwaypoint &lt;- input_grouped |&gt; \n  filter(action != \"F\") |&gt; \n  transmute(\n    group_id,\n    f = case_match(action, cardinal_dirs ~ \"+\", c(\"L\", \"R\") ~ \"*\"),\n    dir = case_match(action,\n      \"N\" ~  value,\n      \"S\" ~ -value,\n      \"E\" ~  value * 1i,\n      \"W\" ~ -value * 1i,\n      \"L\" ~ cos(-value / 90 * pi / 2) + 1i * sin(-value / 90 * pi / 2),\n      \"R\" ~ cos( value / 90 * pi / 2) + 1i * sin( value / 90 * pi / 2)\n    ),\n    wp = accumulate2(f, dir, .f = \\(x, f, y) get(f)(x, y), .init = wp_init) |&gt; \n      tail(-1)\n  ) |&gt; \n  summarize(wp = last(wp), .by = group_id)\n\nRejoin the waypoint’s relative coordinates at each step back with the ship movement instructions. Execute each pair of direction adjustments and advancements in order to get the final coordinates of the ship:\n\nend &lt;- input_grouped |&gt; \n  filter(action == \"F\") |&gt; \n  left_join(waypoint, join_by(group_id)) |&gt; \n  mutate(wp = case_when(group_id == 0 & is.na(wp) ~ wp_init, .default = wp)) |&gt; \n  fill(wp, .direction = \"down\") |&gt; \n  mutate(movement = value * wp) |&gt; \n  pull(movement) |&gt; \n  sum()\n\nCompute the Manhattan distance from the starting point to the final end point:\n\nabs(Re(end)) + abs(Im(end))",
    "crumbs": [
      "2020",
      "Day 12"
    ]
  },
  {
    "objectID": "2020/R/day07.html",
    "href": "2020/R/day07.html",
    "title": "Day 7",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(igraph)\nlibrary(tidygraph)\nlibrary(ggraph)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day07.txt\")\n\nConvert text input into an igraph/tidygraph object. Bags that contain other bags are represented as a directed edge between two vertices, where the weight of the edge is the number of contained bags.\n\ng &lt;- input |&gt; \n  unglue_data(\"{outer_color} bags contain {contains}.\") |&gt; \n  mutate(contains = str_split(contains, \", \")) |&gt; \n  unnest_longer(contains) |&gt; \n  unglue_unnest(\n    contains, \n    \"{num=\\\\d+} {inner_color} bag{=s?}\", \n    convert = TRUE\n  ) |&gt; \n  select(outer_color, inner_color, weight = num) |&gt; \n  drop_na() |&gt; \n  graph_from_data_frame() |&gt; \n  as_tbl_graph()\n\nPlot the graph of the example input:",
    "crumbs": [
      "2020",
      "Day 7"
    ]
  },
  {
    "objectID": "2020/R/day07.html#setup",
    "href": "2020/R/day07.html#setup",
    "title": "Day 7",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(igraph)\nlibrary(tidygraph)\nlibrary(ggraph)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day07.txt\")\n\nConvert text input into an igraph/tidygraph object. Bags that contain other bags are represented as a directed edge between two vertices, where the weight of the edge is the number of contained bags.\n\ng &lt;- input |&gt; \n  unglue_data(\"{outer_color} bags contain {contains}.\") |&gt; \n  mutate(contains = str_split(contains, \", \")) |&gt; \n  unnest_longer(contains) |&gt; \n  unglue_unnest(\n    contains, \n    \"{num=\\\\d+} {inner_color} bag{=s?}\", \n    convert = TRUE\n  ) |&gt; \n  select(outer_color, inner_color, weight = num) |&gt; \n  drop_na() |&gt; \n  graph_from_data_frame() |&gt; \n  as_tbl_graph()\n\nPlot the graph of the example input:",
    "crumbs": [
      "2020",
      "Day 7"
    ]
  },
  {
    "objectID": "2020/R/day07.html#part-1",
    "href": "2020/R/day07.html#part-1",
    "title": "Day 7",
    "section": "Part 1",
    "text": "Part 1\nIdentify how many bag colors can eventually contain a “shiny gold” bag by counting the upstream ancestors of that vertex:\n\ng |&gt; \n  activate(nodes) |&gt; \n  mutate(n_ancestors = local_size(order = graph_order(), mode = \"in\") - 1) |&gt; \n  as_tibble() |&gt;\n  deframe() |&gt; \n  pluck(\"shiny gold\")",
    "crumbs": [
      "2020",
      "Day 7"
    ]
  },
  {
    "objectID": "2020/R/day07.html#part-2",
    "href": "2020/R/day07.html#part-2",
    "title": "Day 7",
    "section": "Part 2",
    "text": "Part 2\nFirst, get the list of all vertices downstream from “shiny gold”:\n\nsrc &lt;- as.numeric(V(g)[\"shiny gold\"])\n\ndownstream &lt;- g |&gt; \n  activate(nodes) |&gt;\n  mutate(neighbors = local_members(order = Inf, mindist = 1, mode = \"out\")) |&gt;\n  as_tibble() |&gt; \n  deframe() |&gt; \n  pluck(\"shiny gold\")\n\nFor each vertex downstream from “shiny gold”, get the list of ALL paths from the “shiny gold” vertex to the downstream vertex, and convert to an order list of the weights:\n\npath_weights &lt;- map(downstream, ~ all_simple_paths(g, src, to = .x)) |&gt; \n  list_flatten() |&gt; \n  map(\\(path) {\n    map_int(2:length(path), \\(id) {\n      get_edge_ids(g, path[c(id - 1, id)])\n    })\n  }) |&gt; \n  map(\\(edge_set) E(g)$weight[edge_set]) \n\nCompute the product of the weights in each path, then sum up the result from all paths. For example: if bag A contains 2 of bag B, and bag B contains 3 of bag C, then the final count of bag B is 2 and bag C is 6 (= 2 * 3).\n\npath_weights |&gt; \n  map_int(prod) |&gt; \n  sum()",
    "crumbs": [
      "2020",
      "Day 7"
    ]
  },
  {
    "objectID": "2020/R/day05.html",
    "href": "2020/R/day05.html",
    "title": "Day 5",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file and separate the row segment of each string from the column seegment:\n\ninput &lt;- read_lines(\"../input/day05.txt\") |&gt; \n  unglue_data(\"{row=[FB]+}{col=[LR]+}\")",
    "crumbs": [
      "2020",
      "Day 5"
    ]
  },
  {
    "objectID": "2020/R/day05.html#setup",
    "href": "2020/R/day05.html#setup",
    "title": "Day 5",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file and separate the row segment of each string from the column seegment:\n\ninput &lt;- read_lines(\"../input/day05.txt\") |&gt; \n  unglue_data(\"{row=[FB]+}{col=[LR]+}\")",
    "crumbs": [
      "2020",
      "Day 5"
    ]
  },
  {
    "objectID": "2020/R/day05.html#part-1",
    "href": "2020/R/day05.html#part-1",
    "title": "Day 5",
    "section": "Part 1",
    "text": "Part 1\nEach F/B or R/L pair can be treated as a binary string. Replace F and L with 0, replace B and R with 1, and compute the result:\n\nbin &lt;- c(\"F\" = \"0\", \"B\" = \"1\", \"L\" = \"0\", \"R\" = \"1\")\n\ndf &lt;- input |&gt; \n  mutate(\n    across(everything(), ~ strtoi(str_replace_all(.x, bin), base = 2L)),\n    seat_id = row * 8 + col\n  )\n\nGet the maximum seat ID:\n\nmax(df$seat_id)",
    "crumbs": [
      "2020",
      "Day 5"
    ]
  },
  {
    "objectID": "2020/R/day05.html#part-2",
    "href": "2020/R/day05.html#part-2",
    "title": "Day 5",
    "section": "Part 2",
    "text": "Part 2\nFind the missing value within the range of all seat IDs:\n\nsetdiff(min(df$seat_id):max(df$seat_id), df$seat_id)",
    "crumbs": [
      "2020",
      "Day 5"
    ]
  },
  {
    "objectID": "2020/R/day10.html",
    "href": "2020/R/day10.html",
    "title": "Day 10",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(igraph)\nlibrary(tidygraph)\nlibrary(ggraph)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead text input from file into a numeric vector:\n\ninput &lt;- scan(\"../input/day10.txt\")",
    "crumbs": [
      "2020",
      "Day 10"
    ]
  },
  {
    "objectID": "2020/R/day10.html#setup",
    "href": "2020/R/day10.html#setup",
    "title": "Day 10",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(igraph)\nlibrary(tidygraph)\nlibrary(ggraph)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead text input from file into a numeric vector:\n\ninput &lt;- scan(\"../input/day10.txt\")",
    "crumbs": [
      "2020",
      "Day 10"
    ]
  },
  {
    "objectID": "2020/R/day10.html#part-1",
    "href": "2020/R/day10.html#part-1",
    "title": "Day 10",
    "section": "Part 1",
    "text": "Part 1\nDetermine the differences between each jolt value ranked in order so that all are used, manually including the “0” starting point and the output rating of max(input) + 3. Compute the total number of 1, 2, and 3-jolt differences:\n\ndist &lt;- c(0, input, max(input) + 3) |&gt; \n  sort() |&gt; \n  diff() |&gt; \n  sort() |&gt; \n  rle()\n\nMultiply the count of 1-jolt differences by the count of 3-jolt differences:\n\ndist$lengths |&gt; \n  keep(dist$values %in% c(1, 3)) |&gt; \n  prod()",
    "crumbs": [
      "2020",
      "Day 10"
    ]
  },
  {
    "objectID": "2020/R/day10.html#part-2",
    "href": "2020/R/day10.html#part-2",
    "title": "Day 10",
    "section": "Part 2",
    "text": "Part 2\nConvert the list of adapters (including the “0” input and final output) into a graph.\n\ng &lt;- expand_grid(\n  v1 = c(0, sort(input), max(input) + 3),\n  v2 = c(0, sort(input), max(input) + 3)\n) |&gt; \n  filter(between(v2 - v1, 1, 3)) |&gt; \n  graph_from_data_frame()\n\nGet the list of all separators from the grap (vertices which disconnect the graph if removed):\n\nsep &lt;- g |&gt; \n  as_undirected() |&gt; \n  min_separators() |&gt; \n  map_chr(names)\n\nThe graph of the “small example” in the problem description is shown below, with ends colored green, separators black, and non-separators (nodes which can be individually removed without disconnecting the graph) red:\n\n\n\n\n\n\n\n\n\nFor each pair of separators in order, determine the number of possible paths between them. To get the final total count of paths, multiply the result of all pairs together:\n\nsep &lt;- sort(as.numeric(sep))\n\nmap2(c(0, sep), c(sep, max(input) + 3), \\(v1, v2) {\n  g |&gt; \n    all_simple_paths(\n      as.character(v1), \n      as.character(v2), \n      mode = \"out\",\n      cutoff = v2 - v1\n    )\n}) |&gt; \n  map_int(length) |&gt; \n  prod()",
    "crumbs": [
      "2020",
      "Day 10"
    ]
  },
  {
    "objectID": "2021/R/day21.html",
    "href": "2021/R/day21.html",
    "title": "Day 21",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(memoise)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead and parse text input from file:\n\ninput &lt;- read_lines(\"../input/day21.txt\") |&gt; \n  unglue_vec(\"Player {x} starting position: {y}\", var = 2, convert = TRUE)",
    "crumbs": [
      "2021",
      "Day 21"
    ]
  },
  {
    "objectID": "2021/R/day21.html#setup",
    "href": "2021/R/day21.html#setup",
    "title": "Day 21",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(memoise)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead and parse text input from file:\n\ninput &lt;- read_lines(\"../input/day21.txt\") |&gt; \n  unglue_vec(\"Player {x} starting position: {y}\", var = 2, convert = TRUE)",
    "crumbs": [
      "2021",
      "Day 21"
    ]
  },
  {
    "objectID": "2021/R/day21.html#part-1",
    "href": "2021/R/day21.html#part-1",
    "title": "Day 21",
    "section": "Part 1",
    "text": "Part 1\nDefine a helper function to perform modulo operations using R’s start-at-one indexing:\n\nrmod &lt;- \\(x, n) rep_len(1:n, max(x))[x]\n\nSince all actions are deterministic, all scores can be determined with modulo arithmetic. If we assume a worst-case scenario where each player’s score increments by only 1 each round, we calculate the scores of the first 1000 rounds for each player, then determine which won.\n\n# Generate the scores for the first 1000 turns in the game for each player\ngame &lt;- tibble(roll = 1:(1000 * 3 * 2)) |&gt; \n  mutate(\n    dice = rmod(roll, 100),\n    turn = ceiling(roll / 3),\n    player = rmod(turn, 2)\n  ) |&gt; \n  summarize(move = sum(dice), .by = c(player, turn)) |&gt; \n  mutate(\n    space = rmod(cumsum(move) + input[player], 10), \n    score = cumsum(space),\n    nrolls = turn * 3,\n    won = score &gt;= 1000,\n    .by = player\n  ) |&gt; \n  \n  # Keep only the turns up until a player wins the game\n  filter(lag(cumsum(won) == 0, default = TRUE))\n\nMultiply the score of the losing player by total dice rolls until the game was won:\n\nrev(game$score)[2] * max(game$nrolls)",
    "crumbs": [
      "2021",
      "Day 21"
    ]
  },
  {
    "objectID": "2021/R/day21.html#part-2",
    "href": "2021/R/day21.html#part-2",
    "title": "Day 21",
    "section": "Part 2",
    "text": "Part 2\nThe sum of each set of 3 quantum rolls can be equivalently interpreted as moves 3-9 with a corresponding number of universes:\n\nnquant &lt;- expand_grid(r1 = 1:3, r2 = 1:3, r3 = 1:3) |&gt; \n  pmap_int(sum) |&gt; \n  table()\n\nDefine a function that simulates the set of all possible moves at each turn. Once any player reaches 21 points, the game ends and the total universes possible arrive at that state are summed.\nMemoization is leveraged for performance.\n\ndirac &lt;- function(player = 1, pos = input, score = c(0, 0)) {\n  if (any(score &gt;= 21))\n    return(modify_at(c(0, 0), rmod(player + 1, 2), ~ 1))\n\n  map2(3:9, nquant, \\(roll, universes) {\n    new_space &lt;- rmod(pos[player] + roll, 10)\n    universes * dirac(\n      player = rmod(player + 1, 2),\n      pos = modify_at(pos, player, ~ new_space),\n      score = modify_at(score, player, ~ .x + new_space)\n    )\n  }) |&gt; \n    reduce(`+`)\n}\n\ndirac &lt;- memoise(dirac)\n\nRun the simulation on the puzzle input and find the count of total universes associated with the winning player:\n\nmax(dirac())",
    "crumbs": [
      "2021",
      "Day 21"
    ]
  },
  {
    "objectID": "2021/R/day08.html",
    "href": "2021/R/day08.html",
    "title": "Day 8",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_delim(\n  file = \"../input/day08.txt\", \n  delim = \" | \",\n  col_names = c(\"signal\", \"output\"),\n  show_col_types = FALSE\n) |&gt; \n  mutate(across(everything(), ~ str_split(.x, \" \")))",
    "crumbs": [
      "2021",
      "Day 8"
    ]
  },
  {
    "objectID": "2021/R/day08.html#setup",
    "href": "2021/R/day08.html#setup",
    "title": "Day 8",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_delim(\n  file = \"../input/day08.txt\", \n  delim = \" | \",\n  col_names = c(\"signal\", \"output\"),\n  show_col_types = FALSE\n) |&gt; \n  mutate(across(everything(), ~ str_split(.x, \" \")))",
    "crumbs": [
      "2021",
      "Day 8"
    ]
  },
  {
    "objectID": "2021/R/day08.html#part-1",
    "href": "2021/R/day08.html#part-1",
    "title": "Day 8",
    "section": "Part 1",
    "text": "Part 1\nCount the total number of digits 1, 4, 7, and 8 in each output by counting the number of output values with length 2, 3, 4, or 7:\n\ninput |&gt; \n  pull(output) |&gt; \n  list_c() |&gt; \n  str_length() |&gt; \n  keep(~ .x %in% c(2, 3, 4, 7)) |&gt; \n  length()",
    "crumbs": [
      "2021",
      "Day 8"
    ]
  },
  {
    "objectID": "2021/R/day08.html#part-2",
    "href": "2021/R/day08.html#part-2",
    "title": "Day 8",
    "section": "Part 2",
    "text": "Part 2\nBy visual examination, we have the following rules:\n\nDigits 1, 4, 7, and 8 are identifiable by length alone.\nDigits 0, 6, 9 all have the same length:\n\n9 is the only superset of 4\nOnce 9 is identified, 0 is the only remaining superset of 1\n6 is the last remaining value.\n\nDigits 2, 3, 5 all have the same length.\n\n3 is the only superset of 1\n5 is the only subset of 6\n2 is the remainder\n\n\nUsing these rules, we can quickly identify which signals correspond to which digits. First, we define a helper function needed to fill null values in a single-value list:\n\nlst_fill &lt;- function(x) {\n  x |&gt; \n    discard(is.null) |&gt; \n    unique() |&gt; \n    rep(length(x))\n}\n\nNext, prepare our input by splitting and sorting the characters in each code:\n\ndf &lt;- input |&gt; \n  mutate(entry_id = row_number()) |&gt; \n  pivot_longer(c(signal, output), names_to = \"type\", values_to = \"code\") |&gt; \n  unnest_longer(code) |&gt; \n  mutate(\n    code = map(code, ~ sort(str_split_1(.x, \"\"))),\n    length = map_int(code, length)\n  )\n\nIdentify the digit corresponding to each code:\n\nresult &lt;- df |&gt; \n  mutate(\n    \n    # Identify digits 1, 4, 7, 8 by length only\n    digit = case_match(length, 2 ~ 1, 4 ~ 4, 3 ~ 7, 7 ~ 8),\n    \n    # Identify digits 0, 6, 9 by whether they have 1/4 as a subset\n    four = lst_fill(case_when(digit == 4 ~ code)),\n    one  = lst_fill(case_when(digit == 1 ~ code)),\n    digit = case_when(\n      length == 6 & map2_lgl(code, four, ~ all(.y %in% .x)) ~ 9,\n      length == 6 & map2_lgl(code, one,  ~ all(.y %in% .x)) ~ 0,\n      length == 6 ~ 6,\n      .default = digit\n    ),\n    \n    # Identify digits 2, 3, 5 by whether they have 1/6 as a subset/superset\n    six = lst_fill(case_when(digit == 6 ~ code)),\n    digit = case_when(\n      length == 5 & map2_lgl(code, one, ~ all(.y %in% .x)) ~ 3,\n      length == 5 & map2_lgl(code, six, ~ all(.x %in% .y)) ~ 5,\n      length == 5 ~ 2,\n      .default = digit\n    ),\n    \n    .by = entry_id\n  ) |&gt; \n  select(entry_id, type, digit, code)\n\nDetermine the output value for each entry and take the sum for the final result:\n\nresult |&gt; \n  filter(type == \"output\") |&gt; \n  summarize(\n    value = parse_number(str_c(digit, collapse = \"\")), \n    .by = entry_id\n  ) |&gt; \n  pull(value) |&gt; \n  sum()",
    "crumbs": [
      "2021",
      "Day 8"
    ]
  },
  {
    "objectID": "2021/R/day23.html",
    "href": "2021/R/day23.html",
    "title": "Day 23",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(igraph)\nlibrary(memoise)\n\nRead and parse text input from file:\n\ninput &lt;- read_lines(\"../input/day23.txt\", skip = 2, n_max = 2) |&gt; \n  str_extract_all(\"[A-Z]\") |&gt; \n  pmap(~ c(..1, ..2))",
    "crumbs": [
      "2021",
      "Day 23"
    ]
  },
  {
    "objectID": "2021/R/day23.html#setup",
    "href": "2021/R/day23.html#setup",
    "title": "Day 23",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(igraph)\nlibrary(memoise)\n\nRead and parse text input from file:\n\ninput &lt;- read_lines(\"../input/day23.txt\", skip = 2, n_max = 2) |&gt; \n  str_extract_all(\"[A-Z]\") |&gt; \n  pmap(~ c(..1, ..2))",
    "crumbs": [
      "2021",
      "Day 23"
    ]
  },
  {
    "objectID": "2021/R/day23.html#part-1",
    "href": "2021/R/day23.html#part-1",
    "title": "Day 23",
    "section": "Part 1",
    "text": "Part 1\nWe represent every state of the board as a string, which allows us to concisely store board and to leverage regex in our computations.\n\nhalls &lt;- str_flatten(c(' ', rep(c(' ', '#'), 4), '  '))\nrooms &lt;- map_chr(input, str_flatten)\nboard &lt;- str_c(halls, str_flatten(rooms, collapse = \",\"), sep = \":\")\n\nFor a given arrangement of free & blocked spaces in the hallway (irrelavant of the occupants of the blocked spaces and the status of the rooms), determine the set of legal moves from each room to a space in the hall:\n\n# Extract the free spaces around each room and convert to a list of indices:\n.room_moves &lt;- function(halls) {\n  halls |&gt; \n    str_locate_all('( *# *)+') |&gt; \n    pluck(1) |&gt; \n    as_tibble() |&gt; \n    transmute(\n      room_idx = map2(start, end, \\(start, end) {\n        keep(c(0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 0)[start:end], ~ .x &gt; 0)\n      }),\n      hall_idx = map2(start, end, \\(start, end) {\n        keep(c(1, 2, 0, 4, 0, 6, 0, 8, 0, 10, 11)[start:end], ~ .x &gt; 0)\n      })\n    ) |&gt; \n    unnest_longer(room_idx) |&gt; \n    pull(hall_idx)\n}\n\n# Memoize for performance: only 128 configurations in total (7 choose k)\n.room_moves &lt;- memoize(.room_moves)\nroom_moves &lt;- \\(x) .room_moves(str_replace_all(x, \"[A-Z]\", \"X\"))\n\nThe list of unblocked moves from the hall to a room is narrower, since an amphipod can only move into its final room:\n\nhall_moves &lt;- function(halls) {\n  map(1:4, \\(room_num) {\n    str_l &lt;- str_sub(halls, 1L, 2 * room_num)\n    str_r &lt;- str_sub(halls, 2 * room_num + 2, -1L)\n    \n    idx_l &lt;- str_locate(str_l, str_c(LETTERS[room_num], \"[# ]*$\"))[,\"start\"]\n    idx_r &lt;- str_locate(str_r, str_c(\"^[# ]*\", LETTERS[room_num]))[,\"end\"]\n    idx_r &lt;- idx_r + 2 * room_num + 1\n    \n    unname(discard(c(idx_l, idx_r), is.na))\n  })\n}\n\nhall_moves &lt;- memoize(hall_moves)\n\nDefine helper functions to compute the cost of moving between two locations on board:\n\nnum_spaces &lt;- function(hall, room, room_size) {\n  n &lt;- room_size + 1\n  \n  room_entry &lt;- ceiling((room - 12) / n) * 2 + 1\n  room_depth &lt;- (room - 13) %% n + 1\n  abs(hall - room_entry) + room_depth\n}\n\nnum_spaces &lt;- memoize(num_spaces)\n\ncost &lt;- function(from, to, chr, room_size) {\n  idx &lt;- match(chr, LETTERS) \n  10^(idx - 1) * num_spaces(min(from, to), max(from, to), room_size)\n}\n\ncost &lt;- memoize(cost)\n\nDefine a helper function to convert a nested list of room indices and hall indices along with information about the current board state into to a new board configuration (as a string):\n\nto_board &lt;- function(moves, spaces, vec, room_size, dir = c(\"in\", \"out\")) {\n  \n  n &lt;- which(c(\"in\", \"out\") == dir)\n  \n  map2(\n    moves,\n    (0:3 * (room_size + 1) + 11) + spaces + n,\n    \\(hall_set, room_idx) {\n      map_chr(hall_set, \\(hall_idx) {\n        to   &lt;- c(room_idx, hall_idx)[n]\n        from &lt;- c(room_idx, hall_idx)[-n]\n        str_c(\n          str_flatten(replace(vec, c(from, to), c(\" \", vec[from]))),\n          cost(from, to, vec[from], room_size),\n          sep = \";\"\n        )\n      })\n    }\n  ) |&gt; \n    unlist()\n  \n}\n\nFrom a given hall/room configuration, get a list of valid next moves:\n\nroom_spaces &lt;- \\(x) str_count(x, \" \")\nroom_has_invalid &lt;- \\(x) str_detect(x, c(\"[BCD]\", \"[ACD]\", \"[ABD]\", \"[ABC]\"))\n\nnext_moves &lt;- function(board, room_size) {\n  vec &lt;- str_split_1(board, \"\")\n  board &lt;- str_split_1(board, \":\")\n  halls &lt;- board[1]\n  rooms &lt;- board[2] |&gt; str_split_1(\",\")\n  \n  # Determine which amphipods can move OUT of their room in the next step:\n  room_spaces &lt;- room_spaces(rooms)\n  room_has_invalid &lt;- room_has_invalid(rooms)\n  \n  # Get all valid hall-to-room moves first, then room-to-hall if none available.\n  hall_to_room &lt;- hall_moves(halls)\n  hall_to_room[room_has_invalid] &lt;- list(numeric(0))\n  \n  # If there are any hall-to-room moves, that's the only path we should take.\n  if (any(map_int(hall_to_room, length) &gt; 0)) {\n    to_board(hall_to_room, room_spaces, vec, room_size, \"in\")\n  } else {\n    room_to_hall &lt;- room_moves(halls)\n    room_to_hall[!room_has_invalid] &lt;- list(numeric(0))\n    to_board(room_to_hall, room_spaces, vec, room_size, \"out\")\n  }\n}\n\nCreate a queue to explore every board state. Once the connections between all board states has been established, convert to a graph and find the shortest distance between the start and end, weighted by movement cost:\n\nget_dist &lt;- function(start, end) {\n  \n  room_size &lt;- start |&gt; \n    str_split_1(\":\") |&gt; \n    pluck(2) |&gt; \n    str_split_1(\",\") |&gt; \n    pluck(1) |&gt; \n    str_length()\n  \n  queue &lt;- start\n  steps &lt;- list()\n  \n  i &lt;- 1\n  \n  while(i &lt;= length(queue)) {\n    cur &lt;- queue[i]\n    nxt &lt;- next_moves(cur, room_size)\n    steps[cur] &lt;- list(nxt)\n    nxt &lt;- nxt |&gt; str_split(';') |&gt; map_chr(~ .x[1])\n    queue &lt;- c(queue, setdiff(nxt, queue))\n    i &lt;- i + 1\n  }\n  \n  g &lt;- steps |&gt;\n    enframe(name = \"V1\") |&gt; \n    unnest_longer(value) |&gt; \n    separate_wider_delim(value, delim = \";\", names = c(\"V2\", \"weight\")) |&gt; \n    mutate(weight = as.numeric(weight)) |&gt; \n    graph_from_data_frame(directed = TRUE)\n  \n  distances(g, v = start, to = end)[1, 1]\n}\n\nRun on puzzle input:\n\nget_dist(board, \"  # # # #  :AA,BB,CC,DD\")",
    "crumbs": [
      "2021",
      "Day 23"
    ]
  },
  {
    "objectID": "2021/R/day23.html#part-2",
    "href": "2021/R/day23.html#part-2",
    "title": "Day 23",
    "section": "Part 2",
    "text": "Part 2\nManually insert the new lines:\n#D#C#B#A#\n#D#B#A#C#\n\nrooms &lt;- map2(\n  rooms,\n  c(\"DD\", \"CB\", \"BA\", \"AC\"),\n  ~ str_split_1(.x, \"\") |&gt; \n    str_flatten(collapse = .y)\n)\n\nboard &lt;- str_c(halls, str_flatten(rooms, collapse = \",\"), sep = \":\")\n\nRe-run on the new input to get the new distance:\n\nget_dist(board, \"  # # # #  :AAAA,BBBB,CCCC,DDDD\")",
    "crumbs": [
      "2021",
      "Day 23"
    ]
  },
  {
    "objectID": "2021/R/day18.html",
    "href": "2021/R/day18.html",
    "title": "Day 18",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_lines(file = \"../input/day18.txt\")\n\nConvert JSON-like input to “snailfish number” format: a flat, named vector whose names give the depth of the nesting:\n\nnested_to_sn &lt;- function(nested, depth = 0) {\n  if (is.integer(nested))\n    set_names(nested, depth)\n  else\n    map(nested, \\(lst) nested_to_sn(lst, depth + 1)) |&gt; \n      list_c()\n}\n\nsn &lt;- input |&gt; \n  map(~ jsonlite::fromJSON(.x, simplifyVector = FALSE)) |&gt; \n  map(nested_to_sn)",
    "crumbs": [
      "2021",
      "Day 18"
    ]
  },
  {
    "objectID": "2021/R/day18.html#setup",
    "href": "2021/R/day18.html#setup",
    "title": "Day 18",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_lines(file = \"../input/day18.txt\")\n\nConvert JSON-like input to “snailfish number” format: a flat, named vector whose names give the depth of the nesting:\n\nnested_to_sn &lt;- function(nested, depth = 0) {\n  if (is.integer(nested))\n    set_names(nested, depth)\n  else\n    map(nested, \\(lst) nested_to_sn(lst, depth + 1)) |&gt; \n      list_c()\n}\n\nsn &lt;- input |&gt; \n  map(~ jsonlite::fromJSON(.x, simplifyVector = FALSE)) |&gt; \n  map(nested_to_sn)",
    "crumbs": [
      "2021",
      "Day 18"
    ]
  },
  {
    "objectID": "2021/R/day18.html#part-1",
    "href": "2021/R/day18.html#part-1",
    "title": "Day 18",
    "section": "Part 1",
    "text": "Part 1\nDefine a function to explode the first applicable pair in a snailfish number:\n\nexplode_sn &lt;- function(x) {\n  \n  idx &lt;- which((names(x) == lead(names(x))) & names(x) &gt; 4) |&gt; head(1)\n  \n  # Return as-is if there are no numbers to explode\n  if (length(idx) == 0) return(x)\n  \n  # Add the values of the exploding pair outward to the left and right\n  1:length(x) |&gt; \n    case_match(\n      idx - 1 ~ x + lead(x),\n      idx + 2 ~ x + lag(x),\n      .default = x\n    ) |&gt; \n    \n    # Replace the exploded pair with 0 and reduce its depth\n    discard_at(idx) |&gt; \n    modify_at(idx, ~ 0) |&gt; \n    set_names(\\(nm) {\n      case_match(\n        1:length(nm), \n        idx ~ as.character(as.numeric(nm) - 1), \n        .default = nm\n      )\n    })\n}\n\nDefine a function to split the first applicable pair in a snailfish number:\n\nsplit_sn &lt;- function(x) {\n  idx &lt;- detect_index(x, ~ .x &gt;= 10)\n  val &lt;- keep_at(x, idx)\n\n  # Return as-is if there are no numbers to split\n  if (idx == 0) return(x)\n  \n  # Convert the value to a new pair at 1 level greater depth\n  pair &lt;- c(floor(val / 2), ceiling(val / 2)) |&gt; \n    set_names(\\(nm) as.character(as.numeric(nm) + 1))\n  \n  # Replace the old value with the new pair\n  c(head(x, idx - 1), pair, tail(x, -idx))\n}\n\nDefine a function to reduce a snailfish number by iteravely exploding and splitting its contents:\n\nreduce_sn &lt;- function(x) {\n  prv &lt;- x\n\n  repeat {\n    x &lt;- explode_sn(x)\n    if (identical(x, prv)) {\n      x &lt;- split_sn(x)\n      if (identical(x, prv)) return(x)\n    }\n    prv &lt;- x\n  }\n}\n\nDefine a function that adds two snailfish numbers by combining them as a new pair and then reducing them:\n\nadd_sn &lt;- \\(x, y) {\n  c(x, y) |&gt; \n    set_names(\\(nm) as.character(as.numeric(nm) + 1)) |&gt; \n    reduce_sn()\n}\n\nDefine a function to compute the magnitude of a snailfish number:\n\nmagnitude &lt;- function(x) {\n  \n  # Iteratively replace the deepest pair with its magnitude\n  while (length(x) &gt; 1) {\n    idx &lt;- which(as.numeric(names(x)) == max(as.numeric(names(x)))) |&gt; head(1)\n    mag &lt;- (x[idx] * 3 + x[idx + 1] * 2) |&gt; \n      set_names(\\(nm) as.character(as.numeric(nm) - 1))\n    x &lt;- c(head(x, idx - 1), mag, tail(x, -(idx + 1)))\n  }\n  \n  unname(x)\n}\n\nAdd together all numbers from the input in order:\n\nfinal_sn &lt;- reduce(sn, add_sn)\n\nCompute the magnitude of the result:\n\nmagnitude(final_sn)",
    "crumbs": [
      "2021",
      "Day 18"
    ]
  },
  {
    "objectID": "2021/R/day18.html#part-2",
    "href": "2021/R/day18.html#part-2",
    "title": "Day 18",
    "section": "Part 2",
    "text": "Part 2\nProduce all pairs of values from the input:\n\ndf &lt;- sn |&gt;\n  as_tibble_col(column_name = \"sn1\") |&gt;\n  mutate(id1 = row_number())\n\npairs &lt;- df |&gt;\n  cross_join(rename(df, sn2 = sn1, id2 = id1)) |&gt;\n  filter(id2 != id1)\n\nCompute the maximum magnitude across all summed pairs:\n\npairs |&gt;\n  pmap_dbl(\\(sn1, sn2, ...) magnitude(add_sn(sn1, sn2))) |&gt;\n  max()",
    "crumbs": [
      "2021",
      "Day 18"
    ]
  },
  {
    "objectID": "2021/R/day25.html",
    "href": "2021/R/day25.html",
    "title": "Day 25",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead and parse text input from file:\n\ninput &lt;- read_lines(\"../input/day25.txt\")",
    "crumbs": [
      "2021",
      "Day 25"
    ]
  },
  {
    "objectID": "2021/R/day25.html#setup",
    "href": "2021/R/day25.html#setup",
    "title": "Day 25",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead and parse text input from file:\n\ninput &lt;- read_lines(\"../input/day25.txt\")",
    "crumbs": [
      "2021",
      "Day 25"
    ]
  },
  {
    "objectID": "2021/R/day25.html#part-1",
    "href": "2021/R/day25.html#part-1",
    "title": "Day 25",
    "section": "Part 1",
    "text": "Part 1\nConvert input to a matrix. Represent N/S-facing values as imaginary numbers and W/E-facing values as real numbers.\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  reduce(rbind) |&gt; \n  unname()\n\nh &lt;- nrow(mtx)\nw &lt;- ncol(mtx)\n\nDefine functions to check if the value ahead of the current one to the south or east are blocked:\n\nis_blocked_s &lt;- \\(x) unname(rbind(tail(x, -1), head(x, 1))) != \".\"\nis_blocked_e &lt;- \\(x) t(is_blocked_s(t(x)))\n\nDefine functions to shift the matrix values to the south or east\n\nmove_s &lt;- function(mtx) {\n  blocked &lt;- is_blocked_s(mtx)\n  active  &lt;- mtx == \"v\"\n  \n  old_pos &lt;- which(active & !blocked, arr.ind = TRUE)\n  \n  new_pos &lt;- old_pos\n  new_pos[, \"row\"] &lt;- (new_pos[, \"row\"] %% h) + 1\n  \n  mtx[new_pos] &lt;- \"v\"\n  mtx[old_pos] &lt;- \".\"\n  mtx\n}\n\nmove_e &lt;- function(mtx) {\n  blocked &lt;- is_blocked_e(mtx)\n  active  &lt;- mtx == \"&gt;\"\n  \n  old_pos &lt;- which(active & !blocked, arr.ind = TRUE)\n  \n  new_pos &lt;- old_pos\n  new_pos[, \"col\"] &lt;- (new_pos[, \"col\"] %% w) + 1\n  \n  mtx[new_pos] &lt;- \"&gt;\"\n  mtx[old_pos] &lt;- \".\"\n  mtx\n}\n\nmove &lt;- \\(x) move_s(move_e(x))\n\nLoop until we don’t see any difference between the previous and current steps:\n\nn_steps &lt;- function(mtx) {\n  n &lt;- 1\n  prv &lt;- mtx\n  \n  repeat {\n    cur &lt;- move(prv)\n    \n    if (all(cur == prv))\n      return(n)\n    \n    prv &lt;- cur\n    n &lt;- n + 1\n  }\n}\n\nn_steps(mtx)",
    "crumbs": [
      "2021",
      "Day 25"
    ]
  },
  {
    "objectID": "2021/R/day01.html",
    "href": "2021/R/day01.html",
    "title": "Day 1",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day01.txt\") |&gt; as.integer()",
    "crumbs": [
      "2021",
      "Day 1"
    ]
  },
  {
    "objectID": "2021/R/day01.html#setup",
    "href": "2021/R/day01.html#setup",
    "title": "Day 1",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day01.txt\") |&gt; as.integer()",
    "crumbs": [
      "2021",
      "Day 1"
    ]
  },
  {
    "objectID": "2021/R/day01.html#part-1",
    "href": "2021/R/day01.html#part-1",
    "title": "Day 1",
    "section": "Part 1",
    "text": "Part 1\nDefine a function to count the number of increasing values in a sequence:\n\ncount_incr &lt;- \\(x) sum(x - lag(x) &gt; 0, na.rm = TRUE)\n\nRun on input:\n\ncount_incr(input)",
    "crumbs": [
      "2021",
      "Day 1"
    ]
  },
  {
    "objectID": "2021/R/day01.html#part-2",
    "href": "2021/R/day01.html#part-2",
    "title": "Day 1",
    "section": "Part 2",
    "text": "Part 2\nCount increases for 3-measurement windows:\n\ncount_incr(input + lead(input) + lead(input, 2))",
    "crumbs": [
      "2021",
      "Day 1"
    ]
  },
  {
    "objectID": "2021/R/day03.html",
    "href": "2021/R/day03.html",
    "title": "Day 3",
    "section": "",
    "text": "Import libraries:\n\nlibrary(vctrs)\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day03.txt\")",
    "crumbs": [
      "2021",
      "Day 3"
    ]
  },
  {
    "objectID": "2021/R/day03.html#setup",
    "href": "2021/R/day03.html#setup",
    "title": "Day 3",
    "section": "",
    "text": "Import libraries:\n\nlibrary(vctrs)\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day03.txt\")",
    "crumbs": [
      "2021",
      "Day 3"
    ]
  },
  {
    "objectID": "2021/R/day03.html#part-1",
    "href": "2021/R/day03.html#part-1",
    "title": "Day 3",
    "section": "Part 1",
    "text": "Part 1\nDefine functions to compute the least and most common values in a vector (using greatest/least values as tiebreakers, as defined later in part 2):\n\nmost_common  &lt;- \\(x) vec_count(x) |&gt; slice_max(count) |&gt; pull(key) |&gt; max()\nleast_common &lt;- \\(x) vec_count(x) |&gt; slice_min(count) |&gt; pull(key) |&gt; min()\n\nDefine a function to convert a vector of binary integers to a decimal number:\n\nbin_to_num &lt;- \\(x) strtoi(str_flatten(x), base = 2)\n\nPrep the input by splitting binary numbers into separate digits by positions:\n\ndf &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  enframe(name = \"id\") |&gt; \n  unnest_longer(value, indices_to = \"pos\") |&gt;   \n  mutate(value = as.integer(value))\n\nCompute the most and least common values in each position to get the gamma and epsilon values, then multiply them together to get the power consumption:\n\ndf |&gt; \n  summarize(\n    gamma = most_common(value), \n    epsilon = least_common(value), \n    .by = pos\n  ) |&gt; \n  summarize(across(c(gamma, epsilon), bin_to_num)) |&gt; \n  prod()",
    "crumbs": [
      "2021",
      "Day 3"
    ]
  },
  {
    "objectID": "2021/R/day03.html#part-2",
    "href": "2021/R/day03.html#part-2",
    "title": "Day 3",
    "section": "Part 2",
    "text": "Part 2\nDefine a set of functions to compute the oxygen and co2 ratings:\n\nget_rating &lt;- function(data, f = c(\"most_common\", \"least_common\")) {\n  \n  for (i in unique(data$pos)) {\n    id_lst &lt;- data |&gt; \n      filter(pos == i) |&gt; \n      filter(value == get(f)(value)) |&gt; \n      pull(id)\n    \n    data &lt;- filter(data, id %in% id_lst)\n    \n    if (length(id_lst) == 1)\n      return(bin_to_num(data$value))\n  }\n}\n\noxygen_rating &lt;- partial(get_rating, f = \"most_common\")\nco2_rating    &lt;- partial(get_rating, f = \"least_common\")\n\nCompute the final life support rating:\n\noxygen_rating(df) * co2_rating(df)",
    "crumbs": [
      "2021",
      "Day 3"
    ]
  },
  {
    "objectID": "2021/R/day16.html",
    "href": "2021/R/day16.html",
    "title": "Day 16",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_lines(file = \"../input/day16.txt\")",
    "crumbs": [
      "2021",
      "Day 16"
    ]
  },
  {
    "objectID": "2021/R/day16.html#setup",
    "href": "2021/R/day16.html#setup",
    "title": "Day 16",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_lines(file = \"../input/day16.txt\")",
    "crumbs": [
      "2021",
      "Day 16"
    ]
  },
  {
    "objectID": "2021/R/day16.html#part-1",
    "href": "2021/R/day16.html#part-1",
    "title": "Day 16",
    "section": "Part 1",
    "text": "Part 1\nConvert hex input to a binary string:\n\nbin &lt;- input |&gt; \n  str_split_1(\"\") |&gt; \n  strtoi(base = 16L) |&gt; \n  map_chr(\n    ~ .x |&gt; \n      intToBits() |&gt; \n      as.integer() |&gt;       \n      rev() |&gt; \n      tail(4) |&gt; \n      str_flatten()\n  ) |&gt; \n  str_flatten()\n\nDefine a helper function to parse binary strings larger than 32 bits (which can’t be handled by the built-in strtoi function):\n\nstrtodbl &lt;- function(str) {\n  str |&gt; \n    str_split_1(\"\") |&gt; \n    rev() |&gt; \n    as.integer() |&gt; \n    imap_dbl(\\(x, idx) if_else(x == 1, 2^(idx - 1), 0)) |&gt; \n    sum()\n}\n\nDefine a function to convert a binary string into an integer following the designated decoding pattern, where values are grouped into sets of 5 bits:\n\nread_literal &lt;- function(bin) {\n  str &lt;- str_extract(bin, \"^(1....)*(0....)\")\n  bin &lt;- str_replace_all(str, \"(.(....))\", \"\\\\2\")\n  val &lt;- strtoi(bin, base = 2)\n  \n  # strtoi can only handle 32 bit integers. Use helper func for larger cases\n  if (is.na(val)) {\n    val &lt;- strtodbl(bin)\n  }\n  \n  lst(value = val, nbits = str_length(str))\n}\n\nDefine a function to read the header info from a packet and delagate the rest of the packet to the correct function to parse:\n\nread_packet &lt;- function(bin) {\n  \n  # Return early if the end is an artifact of decimal representation\n  if (str_length(bin) &lt; 4 | str_detect(bin, \"^0+$\")) \n    return(lst(ver = NULL, type = NULL, nbits = str_length(bin), value = NULL))\n  \n  # Read in packet header/metadata\n  ver  &lt;- str_sub(bin, start = 1L, end =  3L) |&gt; strtoi(base = 2)\n  type &lt;- str_sub(bin, start = 4L, end =  6L) |&gt; strtoi(base = 2)\n  bin  &lt;- str_sub(bin, start = 7L, end = -1L)\n  \n  # Choose the correct function to read in the packet based on type ID\n  fn &lt;- get(case_match(type, 4 ~ \"read_literal\", .default = \"read_subpackets\"))\n  output &lt;- fn(bin)\n  \n  lst(ver = ver, type = type, nbits = output$nbits + 6L, value = output$value)\n}\n\nDefine a function to read and merge sub-packets from within an operator packet:\n\nread_subpackets &lt;- function(bin) {\n  \n  # Determine whether the length is in terms of bits or # of subpackets\n  type &lt;- str_sub(bin, end = 1L) |&gt; as.integer()\n  \n  # Pull length value as an integer and assign the max packet number if applcbl\n  bits &lt;- case_match(type, 0 ~ 15L, 1 ~ 11L)\n  len  &lt;- str_sub(bin, start = 2L, end = bits + 1L) |&gt; strtoi(base = 2)\n  nmax &lt;- case_match(type, 0 ~ Inf, 1 ~ len)\n  \n  # Trim the binary str to begin after the header and end at designated length\n  bin &lt;- str_sub(\n    bin, \n    start = bits + 2L,\n    end = case_match(type, 0 ~ bits + 1L + len, 1 ~ -1L)\n  )\n\n  # Initialize the loop\n  packets &lt;- list()\n  nbits   &lt;- bits + 1L\n  \n  # Parse subpackets until the end of the binary value or max count is reached\n  while (str_length(bin) &gt; 0 & length(packets) &lt; nmax) {\n    output  &lt;- read_packet(bin)\n    nbits   &lt;- nbits + output$nbits\n    packets &lt;- c(packets, list(output))\n    bin     &lt;- str_sub(bin, start = output$nbits + 1L)\n  }\n  \n  return(lst(nbits = nbits, value = packets))\n}\n\nParse puzzle input into a set of nested packets of integers:\n\nparsed &lt;- read_packet(bin)\n\nSum the version numbers from each packet:\n\nparsed |&gt;\n  unlist() |&gt;\n  keep_at(~ str_detect(.x, \"ver\")) |&gt;\n  sum()",
    "crumbs": [
      "2021",
      "Day 16"
    ]
  },
  {
    "objectID": "2021/R/day16.html#part-2",
    "href": "2021/R/day16.html#part-2",
    "title": "Day 16",
    "section": "Part 2",
    "text": "Part 2\nType IDs (other than 4) now represent operations. Map these IDs to their operation:\n\nop_lst   &lt;- c(\"+\", \"*\", \"min\", \"max\", \"I\", \"&gt;\", \"&lt;\", \"==\")\nid_to_op &lt;- \\(id) get(op_lst[id + 1])\n\nDefine a function that parses the nested packet structure and calculates the appropriate output:\n\ncalc_packet &lt;- function(packet) {\n  if (packet$type == 4) return(packet$value)\n  \n  packet$value |&gt; \n    map_dbl(calc_packet) |&gt; \n    reduce(id_to_op(packet$type)) |&gt; \n    as.numeric()\n}\n\nCalculate the output:\n\ncalc_packet(parsed)",
    "crumbs": [
      "2021",
      "Day 16"
    ]
  },
  {
    "objectID": "2021/R/day06.html",
    "href": "2021/R/day06.html",
    "title": "Day 6",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file:\n\ninput &lt;- scan(\"../input/day06.txt\", sep = \",\", quiet = TRUE)",
    "crumbs": [
      "2021",
      "Day 6"
    ]
  },
  {
    "objectID": "2021/R/day06.html#setup",
    "href": "2021/R/day06.html#setup",
    "title": "Day 6",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file:\n\ninput &lt;- scan(\"../input/day06.txt\", sep = \",\", quiet = TRUE)",
    "crumbs": [
      "2021",
      "Day 6"
    ]
  },
  {
    "objectID": "2021/R/day06.html#part-1",
    "href": "2021/R/day06.html#part-1",
    "title": "Day 6",
    "section": "Part 1",
    "text": "Part 1\nAt any given point in time, we can only have fish with ages 0-8. We track the state of our system by logging counts of how many fish exist in each age bucket. To begin, we construct the initial state as a vector of counts for each age, filling with zeroes for ages not present:\n\ninit &lt;- input |&gt; \n  enframe(name = NULL, value = \"age\") |&gt; \n  summarize(n = n(), .by = age) |&gt; \n  complete(age = 0:8, fill = lst(n = 0)) |&gt; \n  pull(n) |&gt; \n  as.numeric()\n\nDefine a function to compute the count of fish on the next day given a fish count on the current day. All counts shift down one unit in age. Fish at age 0 all move to age 6 and create a new age-8 fish.\n\nage_up &lt;- \\(x) c(x[2:7], x[8] + x[1], x[9], x[1])\n\nDefine a function to run the simulation for n days and count the total fish at the end:\n\ncount_fish &lt;- function(init, n_days) {\n  reduce(1:n_days, \\(acc, nxt) age_up(acc), .init = init) |&gt; \n    sum()\n}\n\nCount the total fish after 80 days:\n\ncount_fish(init, 80)",
    "crumbs": [
      "2021",
      "Day 6"
    ]
  },
  {
    "objectID": "2021/R/day06.html#part-2",
    "href": "2021/R/day06.html#part-2",
    "title": "Day 6",
    "section": "Part 2",
    "text": "Part 2\nCount the total fish after 256 days:\n\ncount_fish(init, 256)",
    "crumbs": [
      "2021",
      "Day 6"
    ]
  },
  {
    "objectID": "2021/R/day13.html",
    "href": "2021/R/day13.html",
    "title": "Day 13",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day13.txt\", skip_empty_rows = TRUE)\n\nSplit input from plain-text strings into (1) x/y dot coordinates, and (2) a set of fold instructions.\n\ndots &lt;- input |&gt; \n  unglue_data(\"{x},{y}\", convert = TRUE) |&gt; \n  drop_na()\n\nfolds &lt;- input |&gt; \n  unglue_data(\"fold along {axis}={value}\", convert = TRUE) |&gt; \n  drop_na()",
    "crumbs": [
      "2021",
      "Day 13"
    ]
  },
  {
    "objectID": "2021/R/day13.html#setup",
    "href": "2021/R/day13.html#setup",
    "title": "Day 13",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day13.txt\", skip_empty_rows = TRUE)\n\nSplit input from plain-text strings into (1) x/y dot coordinates, and (2) a set of fold instructions.\n\ndots &lt;- input |&gt; \n  unglue_data(\"{x},{y}\", convert = TRUE) |&gt; \n  drop_na()\n\nfolds &lt;- input |&gt; \n  unglue_data(\"fold along {axis}={value}\", convert = TRUE) |&gt; \n  drop_na()",
    "crumbs": [
      "2021",
      "Day 13"
    ]
  },
  {
    "objectID": "2021/R/day13.html#part-1",
    "href": "2021/R/day13.html#part-1",
    "title": "Day 13",
    "section": "Part 1",
    "text": "Part 1\nDefine a function to fold the paper with the list of dots over a given line:\n\nfold_paper &lt;- function(df, axis, value) {\n  df |&gt; \n    mutate(across(all_of(axis), ~ case_when(\n      .x &gt; value ~ value - (.x - value),\n      .default = .x\n    ))) |&gt; \n    distinct()\n}\n\nCount the dots after the first fold is complete:\n\nfold_paper(dots, folds$axis[[1]], folds$value[[1]]) |&gt; \n  nrow()",
    "crumbs": [
      "2021",
      "Day 13"
    ]
  },
  {
    "objectID": "2021/R/day13.html#part-2",
    "href": "2021/R/day13.html#part-2",
    "title": "Day 13",
    "section": "Part 2",
    "text": "Part 2\nFold the paper completely:\n\nfolded &lt;- reduce2(\n  .x = folds$axis, \n  .y = folds$value, \n  .f = \\(acc, axis, value) fold_paper(acc, axis, value), \n  .init = dots\n)\n\nPrint the output:\n\nfolded |&gt; \n  mutate(chr = '#') |&gt; \n  complete(x = full_seq(x, 1), y = full_seq(y, 1), fill = list(\"chr\" = \" \")) |&gt; \n  arrange(y, x) |&gt; \n  summarize(chr = str_flatten(chr), .by = y) |&gt; \n  pull(chr) |&gt; \n  cat(sep = \"\\n\")",
    "crumbs": [
      "2021",
      "Day 13"
    ]
  },
  {
    "objectID": "2021/R/day11.html",
    "href": "2021/R/day11.html",
    "title": "Day 11",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from plain-text file into a matrix:\n\ninput &lt;- read_fwf(\n  file = \"../input/day11.txt\", \n  col_positions = fwf_widths(rep(1, 10)), \n  col_types = \"i\",\n  show_col_types = FALSE\n) |&gt; \n  as.matrix() |&gt; \n  unname()\n\nwidth  &lt;- ncol(input)\nheight &lt;- nrow(input)",
    "crumbs": [
      "2021",
      "Day 11"
    ]
  },
  {
    "objectID": "2021/R/day11.html#setup",
    "href": "2021/R/day11.html#setup",
    "title": "Day 11",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from plain-text file into a matrix:\n\ninput &lt;- read_fwf(\n  file = \"../input/day11.txt\", \n  col_positions = fwf_widths(rep(1, 10)), \n  col_types = \"i\",\n  show_col_types = FALSE\n) |&gt; \n  as.matrix() |&gt; \n  unname()\n\nwidth  &lt;- ncol(input)\nheight &lt;- nrow(input)",
    "crumbs": [
      "2021",
      "Day 11"
    ]
  },
  {
    "objectID": "2021/R/day11.html#part-1",
    "href": "2021/R/day11.html#part-1",
    "title": "Day 11",
    "section": "Part 1",
    "text": "Part 1\nDefine a function to compute the energy boost from a single flash:\n\nn &lt;- \\(x) lag(x, default = 0)\ns &lt;- \\(x) lead(x, default = 0)\nw &lt;- \\(x) t(lag(t(x), default = 0))\ne &lt;- \\(x) t(lead(t(x), default = 0))\n\nadd_energy &lt;- function(x) {\n  n(x) + s(x) + e(x) + w(x) + n(w(x)) + n(e(x)) + s(w(x)) + s(e(x))\n}\n\nDefine a function to run a single step, which may consist of many flashes until a stable state is reached:\n\nstep &lt;- function(mtx) {\n  \n  # Initialize\n  mtx &lt;- mtx + 1\n  has_flashed &lt;- matrix(FALSE, nrow = height, ncol = width)\n  \n  # Repeat until done flashing\n  repeat {\n    cur_flash &lt;- mtx &gt; 9 & !has_flashed\n    \n    if (all(cur_flash == FALSE)) break\n    \n    has_flashed &lt;- has_flashed | cur_flash\n    mtx &lt;- mtx + add_energy(cur_flash)\n  }\n  \n  # Replace all flashed values with 0\n  replace(mtx, has_flashed, 0)\n}\n\nDefine a function to count the total individual flashes that occur over a defined number of steps:\n\ncount_flashes &lt;- function(mtx, n_steps) {\n  \n  flashes &lt;- 0\n  for (i in 1:n_steps) {\n    mtx &lt;- step(mtx)\n    flashes &lt;- flashes + sum(mtx == 0)\n  }\n  \n  flashes\n}\n\nRun on puzzle input. Count the flashes over 100 steps:\n\ncount_flashes(input, 100)",
    "crumbs": [
      "2021",
      "Day 11"
    ]
  },
  {
    "objectID": "2021/R/day11.html#part-2",
    "href": "2021/R/day11.html#part-2",
    "title": "Day 11",
    "section": "Part 2",
    "text": "Part 2\nDefine a function to find the first step when all cells flash in unison:\n\nfirst_in_unison &lt;- function(mtx) {\n  i &lt;- 0\n  \n  while (any(mtx != 0)) {\n     mtx &lt;- step(mtx)\n     i &lt;- i + 1\n  }\n  \n  i\n}\n\nRun on input:\n\nfirst_in_unison(input)",
    "crumbs": [
      "2021",
      "Day 11"
    ]
  },
  {
    "objectID": "2021/R/day04.html",
    "href": "2021/R/day04.html",
    "title": "Day 4",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\n# List of drawn numbers\ndrawn &lt;- scan(\"../input/day04.txt\", nlines = 1, sep = \",\", quiet = TRUE)\n\n# Set of bingo boards\nboards &lt;- read_table(\"../input/day04.txt\", skip = 2, col_names = FALSE) |&gt; \n  group_split(cumsum(row_number() %% 5 == 1), .keep = FALSE) |&gt; \n  map(~ unname(as.matrix(.x)))",
    "crumbs": [
      "2021",
      "Day 4"
    ]
  },
  {
    "objectID": "2021/R/day04.html#setup",
    "href": "2021/R/day04.html#setup",
    "title": "Day 4",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\n# List of drawn numbers\ndrawn &lt;- scan(\"../input/day04.txt\", nlines = 1, sep = \",\", quiet = TRUE)\n\n# Set of bingo boards\nboards &lt;- read_table(\"../input/day04.txt\", skip = 2, col_names = FALSE) |&gt; \n  group_split(cumsum(row_number() %% 5 == 1), .keep = FALSE) |&gt; \n  map(~ unname(as.matrix(.x)))",
    "crumbs": [
      "2021",
      "Day 4"
    ]
  },
  {
    "objectID": "2021/R/day04.html#part-1",
    "href": "2021/R/day04.html#part-1",
    "title": "Day 4",
    "section": "Part 1",
    "text": "Part 1\nFor all bingo boards, determine the time at which each number on their card is drawn.\n\nfilled &lt;- imap_dfr(boards, \\(board, board_id) {\n  imap_dfr(drawn, \\(num, idx) {\n    which(board == num, arr.ind = TRUE) |&gt; \n      as_tibble() |&gt; \n      mutate(\n        time = idx, \n        board_id = board_id\n      )\n  })\n})\n\nFor each board, determine the time at which each “wins” by achieving a full row or column:\n\nwins &lt;- map_dfr(c(\"row\", \"col\"), \\(dim) {\n  filled |&gt; \n    summarize(n = n(), time = max(time), .by = all_of(c(\"board_id\", dim))) |&gt; \n    rename(dim_value = {{ dim }}) |&gt; \n    mutate(dim_name = dim) |&gt; \n    filter(n == 5)\n}) |&gt; \n  summarize(time = min(time), .by = board_id)\n\nDefine a function to score a board at the time of its win:\n\nscore &lt;- function(board_id, time_win) {\n  \n  board      &lt;- boards[[board_id]]\n  nums_drawn &lt;- drawn[1:time_win]\n  unmarked   &lt;- board[!(board %in% nums_drawn)]\n  score      &lt;- sum(unmarked) * tail(nums_drawn, 1)\n\n  return(score)\n}\n\nCompute the final score of the first board to win:\n\nfirst_winner &lt;- slice_min(wins, time)\n\nscore(first_winner$board_id, first_winner$time)",
    "crumbs": [
      "2021",
      "Day 4"
    ]
  },
  {
    "objectID": "2021/R/day04.html#part-2",
    "href": "2021/R/day04.html#part-2",
    "title": "Day 4",
    "section": "Part 2",
    "text": "Part 2\nCompute the final score of the last board to win:\n\nlast_winner &lt;- slice_max(wins, time)\n\nscore(last_winner$board_id, last_winner$time)",
    "crumbs": [
      "2021",
      "Day 4"
    ]
  },
  {
    "objectID": "helpers.html",
    "href": "helpers.html",
    "title": "Useful Packages & Functions",
    "section": "",
    "text": "This page offers a quick reference for R packages, built-in functions, and custom helper functions that I regularly use in AOC challenges.",
    "crumbs": [
      "Packages & Functions"
    ]
  },
  {
    "objectID": "helpers.html#packages",
    "href": "helpers.html#packages",
    "title": "Useful Packages & Functions",
    "section": "Packages",
    "text": "Packages\n\n\n\nConcept\nPackage Name\nExample\n\n\n\n\nInput Text Parsing\nunglue\n2020 Day 2\n\n\nGraphs\nigraph, tidygraph, ggraph\n2020 Day 10\n\n\nMemoization\nmemoise\n2021 Day 21\n\n\n64-Bit Integers\nbit64\n2024 Day 17\n\n\nSets & Intervals\nsets\n2021 Day 22\n\n\nGeometry\nsf\n2022 Day 15\n\n\nPrimes, GCD, LCM\nnumbers\n2020 Day 13",
    "crumbs": [
      "Packages & Functions"
    ]
  },
  {
    "objectID": "helpers.html#built-in",
    "href": "helpers.html#built-in",
    "title": "Useful Packages & Functions",
    "section": "Built-In",
    "text": "Built-In\n\nScientific Notation\nDisable scientific notation to display all digits of large numbers:\n\noptions(scipen = 999)\n\n\n\nPolar Coordinates\n2D coordinates can be represented as complex numbers, easing common calculations such as addition, subtraction, distances, and angles:\n\nz = complex(real = x, imaginary = y)\n\n\n\nPipes\nColumns of a data frame can be passed through a pipe into a function that takes vector input by using the with function:\n\niris |&gt; \n  with(cor(Sepal.Length, Sepal.Width))\n\n\n\nBase N\nConvert string representations of numbers in any base to integers using the strtoi function:\n\nstrtoi(\"0xff\", base = 16L)\nstrtoi(\"1010\", base = 2L)\n\n\n\nBinary\nConvert 32-bit integers to binary representation using intToBits:\n\nintToBits(5)\n\n\n\nRun Length\nCalculate the length of continuous runs using rle. Convert a list of values and run lengths back to a single vector using inverse.rle.\n\nx &lt;- c(10, 10, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 7, 7, 6)\nrle(x)\ninverse.rle(rle(x))",
    "crumbs": [
      "Packages & Functions"
    ]
  },
  {
    "objectID": "helpers.html#snippets-custom-functions",
    "href": "helpers.html#snippets-custom-functions",
    "title": "Useful Packages & Functions",
    "section": "Snippets & Custom Functions",
    "text": "Snippets & Custom Functions\n\nRead Matrix\nRead text input directly into a matrix by using a combination of read.table and as.matrix:\n\ninput &lt;- read.table(filepath) |&gt; \n  as.matrix() |&gt; \n  unname()\n\n\n\nPrint Compact Matrix\nDisplay fixed-width matrices in a compact format, with no spaces between cells:\n\nmtx_compact &lt;- function(mtx) { \n  mtx |&gt; \n    apply(1, str_flatten) |&gt; \n    cat(sep = \"\\n\")\n}\n\nExample:\n\nc(\"#\", \"#\", \"#\", \"#\", \".\", '#', '#', '.', '#', \"#\", \"#\", \"#\") |&gt; \n  matrix(nrow = 3) |&gt; \n  mtx_compact()\n\n####\n#..#\n####\n\n\n\n\nVisualize Matrix as Image\nPrint matrices as a colored pixel image:\n\nmtx_image &lt;- function(mtx, palette = NULL, palette_fun = viridis::mako) {\n  \n  # If a color palette is not supplied, generate one\n  if (is.null(palette)) {\n    palette &lt;- switch(typeof(mtx),\n      \"integer\"   = palette_fun(max(mtx) - min(mtx) + 1),\n      \"double\"    = palette_fun(100),\n      \"character\" = palette_fun(length(unique(c(input))))\n    )\n  }\n  \n  # Convert character matrix to integers\n  if (is.character(mtx)) {\n    mtx &lt;- mtx |&gt; \n      match(factor(mtx)) |&gt; \n      matrix(ncol = ncol(mtx))\n  }\n  \n  # Transpose & flip matrix so that pixels are displayed in intended order\n  image(\n    t(mtx)[, nrow(mtx):1], \n    col = palette,\n    asp = nrow(mtx) / ncol(mtx), \n    axes = FALSE\n  ) \n}\n\nExample:\n\nround(runif(12, max = 100)) |&gt; \n  matrix(nrow = 3) |&gt; \n  mtx_image()",
    "crumbs": [
      "Packages & Functions"
    ]
  },
  {
    "objectID": "2023/R/day09.html",
    "href": "2023/R/day09.html",
    "title": "Day 9",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day09.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 9"
    ]
  },
  {
    "objectID": "2023/R/day09.html#setup",
    "href": "2023/R/day09.html#setup",
    "title": "Day 9",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day09.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 9"
    ]
  },
  {
    "objectID": "2023/R/day09.html#part-1",
    "href": "2023/R/day09.html#part-1",
    "title": "Day 9",
    "section": "Part 1",
    "text": "Part 1\nConvert text input into a series of numeric sequences:\n\nseqs &lt;- input |&gt; \n  str_split(\"\\\\s+\") |&gt; \n  map(as.numeric)\n\nDefine a function to get the next value in a sequence:\n\nextrapolate_next &lt;- function(x) {\n  if (all(x == 0))\n    return(0)\n  else\n    return(tail(x, 1) + extrapolate_next(diff(x)))\n}\n\nCompute next value of every sequence in the input, then sum the result:\n\nseqs |&gt; \n  map_dbl(extrapolate_next) |&gt; \n  sum()",
    "crumbs": [
      "2023",
      "Day 9"
    ]
  },
  {
    "objectID": "2023/R/day09.html#part-2",
    "href": "2023/R/day09.html#part-2",
    "title": "Day 9",
    "section": "Part 2",
    "text": "Part 2\nModify the function to get the preceeding sequence value, rather than the next:\n\nextrapolate_prev &lt;- function(x) {\n  if (all(x == 0))\n    return(0)\n  else\n    return(head(x, 1) - extrapolate_prev(diff(x)))\n}\n\nRun on puzzle input:\n\nseqs |&gt; \n  map_dbl(extrapolate_prev) |&gt; \n  sum()",
    "crumbs": [
      "2023",
      "Day 9"
    ]
  },
  {
    "objectID": "2023/R/day20.html",
    "href": "2023/R/day20.html",
    "title": "Day 20",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day20.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 20"
    ]
  },
  {
    "objectID": "2023/R/day20.html#setup",
    "href": "2023/R/day20.html#setup",
    "title": "Day 20",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day20.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 20"
    ]
  },
  {
    "objectID": "2023/R/day20.html#part-1",
    "href": "2023/R/day20.html#part-1",
    "title": "Day 20",
    "section": "Part 1",
    "text": "Part 1\nConvert text input into a nested list of modules:\n\ndf &lt;- input |&gt; \n  unglue_data(\"{prefix=(%|&)?}{name} -&gt; {destinations}\") |&gt; \n  mutate(destinations = str_split(destinations, \",\\\\s*\"))\n\nsources &lt;- df |&gt; \n  unnest_longer(destinations) |&gt; \n  summarize(sources = list(name), .by = destinations)\n\nblank_add &lt;- sources |&gt; \n  anti_join(df, join_by(x$destinations == y$name)) |&gt; \n  transmute(name = destinations, prefix = '')\n\nmodules &lt;- df |&gt; \n  left_join(sources, join_by(x$name == y$destinations)) |&gt; \n  add_row(name = \"button\", prefix = '', destinations = list(\"broadcaster\")) |&gt; \n  bind_rows(blank_add) |&gt; \n  mutate(\n    state = case_when(prefix == '%' ~ FALSE),\n    memories = case_when(\n      prefix == '&' ~ map(sources, ~ set_names(rep(FALSE, length(.x)), .x))\n    ),\n    n_lo = 0,\n    n_hi = 0\n  ) |&gt; \n  transmute(\n    name,\n    value = pmap(lst(prefix, destinations, state, memories, n_lo, n_hi), lst)\n  ) |&gt; \n  deframe()\n\nDefine a function that modifies a set of modules when the button is pushed:\n\npush_button &lt;- function(modules) {\n  queue &lt;- list(list(source = \"button\", target = \"broadcaster\", pulse = FALSE))\n  modules$button$n_lo &lt;- modules$button$n_lo + 1\n  \n  while (length(queue) &gt; 0) {\n    signal &lt;- queue[[1]]\n    queue  &lt;- queue[-1]\n    module &lt;- modules[[signal$target]]\n    output &lt;- NULL\n    \n    if (signal$target == \"broadcaster\") {\n      output &lt;- signal$pulse\n    } else if (module$prefix == '%' & signal$pulse == FALSE) {\n      modules[[signal$target]]$state &lt;- !module$state\n      output &lt;- !module$state\n    } else if (module$prefix == '&') {\n      modules[[signal$target]]$memories[[signal$source]] &lt;- signal$pulse\n      output &lt;- !all(modules[[signal$target]]$memories == TRUE)\n    }\n    \n    if (!is.null(output)) {\n      queue_add &lt;- module$destinations |&gt; \n        map(~ list(source = signal$target, target = .x, pulse = output))\n      queue &lt;- c(queue, queue_add)\n      \n      n &lt;- length(module$destinations)\n      \n      if (output == TRUE)\n        modules[[signal$target]]$n_hi &lt;- modules[[signal$target]]$n_hi + n\n      else\n        modules[[signal$target]]$n_lo &lt;- modules[[signal$target]]$n_lo + n \n    }\n  }\n  \n  modules\n}\n\nDefine a function that sums the total low vs high buttons sent at a given state of the modules:\n\ncount_pulses &lt;- function(modules) {\n  c(\n    lo = sum(map_int(modules, ~ .x$n_lo)),\n    hi = sum(map_int(modules, ~ .x$n_hi))\n  )\n}\n\nRun on puzzle input:\n\noutput &lt;- modules\n\nfor (i in 1:1000) {\n  output &lt;- push_button(output)\n}\n\ncount_pulses(output) |&gt; \n  prod()",
    "crumbs": [
      "2023",
      "Day 20"
    ]
  },
  {
    "objectID": "2023/R/day20.html#part-2",
    "href": "2023/R/day20.html#part-2",
    "title": "Day 20",
    "section": "Part 2",
    "text": "Part 2\nExamining the input, tj sends a low pulse to rx if its last memories (kk, xc, sk, vt) are all high pulses. For each of those memories, we just check when it first sends a high pulse to compute its cycle length, then take the LCM:\n\npushes_until_sent &lt;- function(modules, name, pulse = c(\"hi\", \"lo\")) {\n  pulse &lt;- c(\"n_\", pulse)\n  i &lt;- 0\n  \n  while (pluck(modules, name, \"n_hi\") == 0) {\n    modules &lt;- push_button(modules)\n    i &lt;- i + 1\n  }\n  \n  return(i)\n}\n\nc(\"kk\", \"xc\", \"sk\", \"vt\") |&gt; \n  map_dbl(~ pushes_until_sent(modules, .x, \"hi\")) |&gt; \n  numbers::mLCM() |&gt; \n  format(scientific = FALSE)",
    "crumbs": [
      "2023",
      "Day 20"
    ]
  },
  {
    "objectID": "2023/R/day22.html",
    "href": "2023/R/day22.html",
    "title": "Day 22",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day22.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 22"
    ]
  },
  {
    "objectID": "2023/R/day22.html#setup",
    "href": "2023/R/day22.html#setup",
    "title": "Day 22",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day22.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 22"
    ]
  },
  {
    "objectID": "2023/R/day22.html#part-1",
    "href": "2023/R/day22.html#part-1",
    "title": "Day 22",
    "section": "Part 1",
    "text": "Part 1\nConvert text input to a list of bricks with x/y/z coordinates:\n\nbricks &lt;- input |&gt; \n  unglue_data(\"{x1},{y1},{z1}~{x2},{y2},{z2}\", convert = TRUE) |&gt; \n  transmute(\n    id = row_number(),\n    x = map2(x1, x2, seq),\n    y = map2(y1, y2, seq),\n    z = map2(z1, z2, seq)\n  ) |&gt; \n  transmute(\n    name = id,\n    value = pmap(lst(x, y, z), ~ lst(x = ..1, y = ..2, z = ..3))\n  ) |&gt; \n  deframe()\n\nFor performance, gather a list of dependencies between bricks, so that the full list doesn’t need to be searched each time.\n\ngrid &lt;- input |&gt; \n  unglue_data(\"{x1},{y1},{z1}~{x2},{y2},{z2}\", convert = TRUE) |&gt; \n  transmute(\n    id = row_number(),\n    x  = map2(x1, x2, seq),\n    y  = map2(y1, y2, seq),\n    z  = map2(z1, z2, seq),\n  ) |&gt; \n  unnest_longer(x) |&gt; \n  unnest_longer(y) |&gt; \n  unnest_longer(z)\n\ndepends_on &lt;- bricks |&gt; \n  map(\\(cur) {\n    inner_join(\n      grid,\n      expand_grid(x = cur$x, y = cur$y, z = min(cur$z)),\n      join_by(x, y, x$z &lt; y$z),\n      suffix = c(\"_dep\", \"_cur\")\n    ) |&gt; \n      pull(id) |&gt; \n      unique() |&gt; \n      as.character()\n  })\n\ndependents &lt;- depends_on |&gt; \n  enframe() |&gt; \n  unnest_longer(value) |&gt; \n  summarize(name = list(name), .by = value) |&gt; \n  arrange(as.numeric(value)) |&gt; \n  deframe()\n\nDefine a function to check if a given brick will fall at a given snapshot in time:\n\nfall_dist &lt;- function(bricks, id) {\n  active &lt;- bricks[[id]]\n  others &lt;- bricks[depends_on[[id]]] |&gt; discard(~ is.null(.x))\n  \n  # Initialize the current max z dist that the brick could drop\n  z_drop &lt;- min(active$z) - 1\n  \n  # Check if brick is already on the ground\n  if (z_drop == 0) return(0)\n  \n  # Check if blocked by any other bricks\n  for (other in others) {\n    z_dist &lt;- min(active$z) - max(other$z) - 1\n    if (z_dist == 0) \n      return(0)\n    else if (z_dist &lt; z_drop) \n      z_drop &lt;- z_dist\n  }\n  \n  z_drop\n}\n\nSort the bricks using a DAG to avoid needless looping:\n\ng &lt;- dependents |&gt; \n  imap(\\(children, parent) map(children, \\(child) c(parent, child))) |&gt; \n  unlist() |&gt; \n  unname() |&gt; \n  as.numeric() |&gt; \n  make_graph(n = length(bricks))\n\nis_dag(g)\nordering &lt;- as.character(as.numeric(topo_sort(g)))\n\nDefine a function to make all bricks fall into place:\n\ndrop_bricks &lt;- function(bricks) {\n  new_stack &lt;- bricks[ordering]\n  \n  for (i in names(new_stack))\n    new_stack[[i]]$z &lt;- new_stack[[i]]$z - fall_dist(new_stack, i)\n\n  new_stack\n}\n\nDrop all bricks down and determine which can be safely disentegrated. If a single brick is removed, does re-dropping the bricks change the result? If not, then it can be disintegrated.\n\nsettled &lt;- drop_bricks(bricks)\n\nnames(bricks) |&gt; \n  \n  # For each brick, determine whether it can be safely disintegrated.\n  map_lgl(\\(brick_id) {\n    disintegrated &lt;- discard_at(settled, brick_id)\n    disintegrated &lt;- disintegrated[ordering]\n    for (i in dependents[[brick_id]]) {\n      if (fall_dist(disintegrated, i) &gt; 0) return(FALSE)\n    }\n    return(TRUE)\n  }) |&gt; \n  \n  # Sum the total number of safely disintegratable bricks\n  sum()",
    "crumbs": [
      "2023",
      "Day 22"
    ]
  },
  {
    "objectID": "2023/R/day22.html#part-2",
    "href": "2023/R/day22.html#part-2",
    "title": "Day 22",
    "section": "Part 2",
    "text": "Part 2\nFor each brick, determine the number of cascading bricks that will fall if this one is disintegrated:\n\nnum_affected_bricks &lt;- function(bricks, id) {\n  new_stack &lt;- bricks[ordering] |&gt; \n    discard_at(id)\n  \n  to_examine &lt;- tail(ordering[as.logical(cumsum(ordering == id))], -1)\n  \n  total_moved &lt;- 0\n  \n  for (i in to_examine) {\n    move &lt;- fall_dist(new_stack, i)\n    if (move &gt; 0) {\n      new_stack[[i]]$z &lt;- new_stack[[i]]$z - move\n      total_moved &lt;- total_moved + 1\n    }\n  }\n  total_moved\n}\n\nRun on puzzle input:\n\nnames(settled) |&gt; \n  map_dbl(num_affected_bricks, bricks = settled) |&gt; \n  sum()",
    "crumbs": [
      "2023",
      "Day 22"
    ]
  },
  {
    "objectID": "2023/R/day24.html",
    "href": "2023/R/day24.html",
    "title": "Day 24",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day24.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 24"
    ]
  },
  {
    "objectID": "2023/R/day24.html#setup",
    "href": "2023/R/day24.html#setup",
    "title": "Day 24",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day24.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 24"
    ]
  },
  {
    "objectID": "2023/R/day24.html#part-1",
    "href": "2023/R/day24.html#part-1",
    "title": "Day 24",
    "section": "Part 1",
    "text": "Part 1\nConvert text input to structured data:\n\nbound_min &lt;- 200000000000000\nbound_max &lt;- 400000000000000\n\ndf &lt;- input |&gt; \n  unglue_data(\"{px}, {py}, {pz} @ {vx}, {vy}, {vz}\", convert = TRUE) |&gt; \n  mutate(id = row_number(), .before = everything())\n\nvecs_2d &lt;- df |&gt; \n  transmute(\n    id,\n    p = pmap(lst(px, py), ~ matrix(c(..1, ..2), ncol = 1)),\n    v = pmap(lst(vx, vy), ~ matrix(c(..1, ..2), ncol = 1))\n  )\n\nvecs_3d &lt;- df |&gt; \n  transmute(\n    id,\n    p = pmap(lst(px, py, pz), ~ matrix(c(..1, ..2, ..3), ncol = 1)),\n    v = pmap(lst(vx, vy, vz), ~ matrix(c(..1, ..2, ..3), ncol = 1))\n  )\n\nThe position \\(\\vec a\\) of a hailstone at any given time \\(t\\) can be written in the format:\n\\[\\vec vt + \\vec p\\]\nThe intersection of the paths of any two given hailstones is therefore the point \\(\\vec a\\) where:\n\\[\n\\vec a = \\vec v_1t_1 + \\vec p_1 = \\vec v_2t_2 = \\vec p_2\n\\]\nThis can be re-written as the system of equations:\n\\[\n\\begin{bmatrix}\\vec v_1 &-\\vec v_2\\end{bmatrix}\\begin{bmatrix}t_1\\\\t_2\\end{bmatrix} = \\vec p_2 - \\vec p_1\n\\]\nSolving this system of equations for each pair of hailstones will give us the values of \\(t_1\\) and \\(t_2\\) that can then be used to compute the coordinates of their intersection, \\(\\vec a\\).\n\n# Combine all hailstones' paths pairwise and solve the system of equations\npairs &lt;- inner_join(\n  vecs_2d, \n  vecs_2d, \n  join_by(x$id &lt; y$id), \n  suffix = c(\"1\", \"2\")\n) |&gt; \n  mutate(\n    A = map2(v1, v2, ~ cbind(..1, -..2)),\n    b = map2(p1, p2, ~ ..2 - ..1),\n    det = map_dbl(A, det),\n    t = pmap(lst(A, b, det), \\(A, b, det) if (det != 0) as.vector(solve(A, b)))\n  ) |&gt; \n  unnest_wider(t, names_sep = \"\") |&gt; \n  \n  # Check if each path cross is within the bounding box and forward in time\n  mutate(\n    intersection = pmap(lst(t1, v1, p1), ~ ..1 * ..2 + ..3),\n    in_bounds = map_lgl(intersection, ~ all(between(.x, bound_min, bound_max))),\n    future_time = t1 &gt;= 0 & t2 &gt;= 0,\n    flag = replace_na(in_bounds & future_time, FALSE)\n  )\n\n# Count the number of future-crossing paths:\npairs |&gt; \n  pull(flag) |&gt; \n  sum()",
    "crumbs": [
      "2023",
      "Day 24"
    ]
  },
  {
    "objectID": "2023/R/day24.html#part-2",
    "href": "2023/R/day24.html#part-2",
    "title": "Day 24",
    "section": "Part 2",
    "text": "Part 2\nNow our equation has changed. For each hailstone \\(i\\), and for our initial position \\(\\vec p_*\\) and velocity \\(\\vec v_*\\), we have the following relationship, where \\(t_i\\) is the nonzero collision time of our rock and the given hailstone:\n\\[\n(\\vec v_* - \\vec v_i)t_i = \\vec p_* - \\vec p_i\n\\]\nSince \\(t_i\\) is a scalar for each \\(i\\), then \\(\\vec v_i - \\vec v_*\\) and \\(\\vec p_i - \\vec p_*\\) are scalar multiples of each other. Thanks to a hint from Reddit user u/evouga, as these vectors are parallel, their cross product is zero, meaning that for all \\(i\\):\n\\[\n(\\vec p_* - \\vec p_i) \\times (\\vec v_* - \\vec v_i) = 0\n\\]\nExpanding this equation by the distributive property of the vector cross product, we get:\n\\[\n(\\vec p_* \\times \\vec v_*) - (\\vec p_* \\times \\vec v_i) - (\\vec p_i \\times \\vec v_*) + (\\vec p_i \\times \\vec v_i) = 0\n\\]\nVia properties of the cross product, we can then represent this as:\n\\[\n(\\vec p_* \\times \\vec v_*) - [\\vec v_i]_\\times^\\intercal \\vec p_* - [\\vec p_i]_\\times \\vec v_* + (\\vec p_i \\times \\vec v_i) = 0\n\\]\nwhere \\([\\vec a]_\\times\\) is defined as:\n\\[\n[\\vec a]_\\times = \\begin{bmatrix}0 & -a_3 & a_2 \\\\ a_3 & 0 & -a_1 \\\\ -a_2 & a_1 & 0\\end{bmatrix}\n\\]\nWe can now (nearly) re-write this as a system of linear equations:\n\\[\nA_i\\vec x = \\vec b_i + (\\vec p_* \\times \\vec v_*)\n\\]\nwhere\n\\[\nA_i = \\begin{bmatrix}[\\vec v_i]_\\times^\\intercal & [\\vec p_i]_\\times\\end{bmatrix}, \\quad \\vec x = \\begin{bmatrix}\\vec p_* \\\\ \\vec v_*\\end{bmatrix}, \\quad b_i = (\\vec p_i \\times \\vec v_i)\n\\]\nSince this equation holds for all \\(i\\), we can remove the needless term \\((\\vec p_* \\times \\vec v_*)\\) and solve for \\(\\vec x\\) by subtracting two of these linear systems of equations from each other (using \\(i = 1,2\\) as below, or any other two values of \\(i\\) whose vectors from part 1 are not parallel):\n\\[\n(A_1 - A_2)\\vec x = \\vec b_1 - \\vec b_2\n\\]\nFinally, since we’ve arrived at a system of 3 equations and 6 unknowns, we append \\(A\\) and \\(\\vec b\\) with an additional pair of equations (using \\(i = 2,3\\), for example) to solve for a final unique result:\n\\[\n\\begin{bmatrix}A_1 - A_2\\\\A_2 - A_3\\end{bmatrix}\\vec x = \\begin{bmatrix}\\vec b_1 - \\vec b_2\\\\ \\vec b_2 - \\vec b_3\\end{bmatrix}\n\\]\n\n# Define a function to compute the skeq symmetric matrix [a]_x\nskewsym &lt;- function(x) {\n  matrix(c(0, x[[3]], -x[[2]], -x[[3]], 0, x[[1]], x[[2]], -x[[1]], 0), ncol = 3)\n}\n\n# For the first three vectors in our list, compute their A and b values\nlineqs &lt;- vecs_3d |&gt; \n  slice_head(n = 3) |&gt; \n  mutate(\n    A = map2(p, v, \\(p, v) cbind(t(skewsym(v)), skewsym(p))),\n    b = map2(p, v, \\(p, v) pracma::cross(p, v))\n  )\n\n# Combine the 3 linear equations into a single system & solve\nA &lt;- rbind(lineqs$A[[1]] - lineqs$A[[2]], lineqs$A[[2]] - lineqs$A[[3]])\nb &lt;- rbind(lineqs$b[[1]] - lineqs$b[[2]], lineqs$b[[2]] - lineqs$b[[3]])\nx &lt;- solve(A, b)\n\nFinally, add together the three px, py, and pz coordinates for the initial position:\n\nsum(x[1:3]) |&gt; \n  format(scientific = FALSE)",
    "crumbs": [
      "2023",
      "Day 24"
    ]
  },
  {
    "objectID": "2023/R/day19.html",
    "href": "2023/R/day19.html",
    "title": "Day 19",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sets)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day19.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 19"
    ]
  },
  {
    "objectID": "2023/R/day19.html#setup",
    "href": "2023/R/day19.html#setup",
    "title": "Day 19",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sets)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day19.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 19"
    ]
  },
  {
    "objectID": "2023/R/day19.html#part-1",
    "href": "2023/R/day19.html#part-1",
    "title": "Day 19",
    "section": "Part 1",
    "text": "Part 1\nSeparate the input into rules and parts:\n\nparts &lt;- input |&gt; \n  keep(~ str_starts(.x, \"\\\\{\")) |&gt; \n  unglue_data(\n    \"{x=[x],m=[m],a=[a],s=[s]}\", \n    open = \"[\", \n    close = \"]\", \n    convert = TRUE\n  ) |&gt; \n  pmap(\\(x, m, a, s) lst(x, m, a, s))\n\nrules &lt;- input |&gt; \n  keep(~ str_starts(.x, \"\\\\w\")) |&gt; \n  unglue_data(\"[name]{[rules]}\", open = \"[\", close = \"]\") |&gt; \n  mutate(rules = str_split(rules, \",\")) |&gt; \n  unnest_longer(rules, values_to = \"condition\", indices_to = \"cond_num\") |&gt; \n  unglue_unnest(\n    condition, \n    c(\"{var}{eq=[&lt;&gt;]}{val}:{goto}\", \"{goto}\"), \n    convert = TRUE\n  ) |&gt; \n  mutate(value = pmap(\n    lst(var, eq, val, goto), \n    ~ lst(var = ..1, eq = ..2, val = ..3, goto = ..4)\n  )) |&gt; \n  summarize(value = list(value), .by = name) |&gt; \n  deframe()\n\nDefine a function that rates a part according to the rule list for each workflow:\n\nrate &lt;- function(part, workflow = \"in\") {\n  if (workflow %in% c('A', 'R')) \n    return(workflow == 'A')\n  \n  workflow &lt;- rules[[workflow]]\n  \n  for (rule in workflow) {\n    if (is.na(rule$var))\n      return(rate(part, rule$goto))\n    if (get(rule$eq)(part[[rule$var]], rule$val))\n      return(rate(part, rule$goto))\n  }\n}\n\nRate the list of parts, then for the accepted parts, add all ratings:\n\nkeep(parts, map_lgl(parts, rate)) |&gt; \n  unlist() |&gt; \n  sum()",
    "crumbs": [
      "2023",
      "Day 19"
    ]
  },
  {
    "objectID": "2023/R/day19.html#part-2",
    "href": "2023/R/day19.html#part-2",
    "title": "Day 19",
    "section": "Part 2",
    "text": "Part 2\nDefine a function to cut the valid set of inputs into a set of intervals. Looping through our rules, trim down the intervals for x, m, a, and s until we have the final set of valid inputs:\n\nkeys  &lt;- set_names(c(\"x\", \"m\", \"a\", \"s\"))\nempty &lt;- map(keys, ~ interval(domain = 'Z'))\ninit  &lt;- map(keys, ~ interval(l = 1, r = 4000, domain = 'Z'))\n\nrate_range &lt;- function(cur_range, workflow = \"in\") {\n  \n  if (workflow == 'A') \n    return(list(cur_range))\n  if (workflow == 'R')\n    return(list())\n  \n  workflow &lt;- rules[[workflow]]\n  accepted &lt;- list()\n\n  for (rule in workflow) {\n    if (is.na(rule$var)) {\n      accepted &lt;- c(accepted, rate_range(cur_range, rule$goto))\n      return(accepted)\n    }\n\n    rule_range &lt;- sets::interval(\n      l = case_match(rule$eq, '&lt;' ~ 1,            '&gt;' ~ rule$val + 1),\n      r = case_match(rule$eq, '&lt;' ~ rule$val - 1, '&gt;' ~ 4000),\n      domain = 'Z'\n    )\n\n    rule_pass &lt;- cur_range |&gt;\n      modify_at(rule$var, ~ interval_intersection(.x, rule_range))\n    rule_fail &lt;- cur_range |&gt;\n      modify_at(rule$var, ~ interval_complement(rule_range, .x))\n\n    accepted &lt;- c(accepted, rate_range(rule_pass, rule$goto))\n    cur_range &lt;- rule_fail\n  }\n}\n\nRun and compute the number of total valid combinations:\n\nrate_range(init) |&gt; \n  map(\\(intrvl) map_dbl(intrvl, ~ length(as.set(.x)))) |&gt; \n  map_dbl(prod) |&gt;\n  sum() |&gt; \n  format(scientific = FALSE)",
    "crumbs": [
      "2023",
      "Day 19"
    ]
  },
  {
    "objectID": "2023/R/day14.html",
    "href": "2023/R/day14.html",
    "title": "Day 14",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day14.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 14"
    ]
  },
  {
    "objectID": "2023/R/day14.html#setup",
    "href": "2023/R/day14.html#setup",
    "title": "Day 14",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day14.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 14"
    ]
  },
  {
    "objectID": "2023/R/day14.html#part-1",
    "href": "2023/R/day14.html#part-1",
    "title": "Day 14",
    "section": "Part 1",
    "text": "Part 1\nConvert the input text into a matrix:\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  unlist() |&gt; \n  matrix(nrow = length(input), byrow = TRUE)\n\nFrom Reddit hints: can use matrix transforms and regex to make the tilting computations more efficient.\n\n# For a set of string vectors, shift all rocks in them to the left. \nshift &lt;- function(str) {\n  repeat {\n    new &lt;- str_replace_all(str, \"\\\\.O\", \"O\\\\.\")\n\n    if (all(str == new))\n      return(str)\n    else\n      str &lt;- new\n  }\n}\n\n# Tilt the entire matrix in a given direction (N/S/W/E)\ntilt &lt;- function(mtx, dir = 'N') {\n  \n  if (dir %in% c('W', 'E'))\n    mtx &lt;- t(mtx)\n  if (dir %in% c('S', 'E'))\n    mtx &lt;- apply(mtx, 2, rev)\n  \n  # Split the matrix into columns, shift the rocks, and recombine\n  mtx &lt;- split(mtx, col(mtx)) |&gt; \n    map(str_flatten) |&gt; \n    shift() |&gt; \n    str_split(\"\") |&gt; \n    do.call(args = _, what = cbind)\n  \n  if (dir %in% c('S', 'E'))\n    mtx &lt;- apply(mtx, 2, rev)\n  if (dir %in% c('W', 'E'))\n    mtx &lt;- t(mtx)\n  \n  mtx\n}\n\nTilt the matrix and sum up the load:\n\ncompute_load &lt;- function(mtx) {\n  split(mtx, col(mtx)) |&gt; \n    map(~ which(rev(.x) == \"O\")) |&gt; \n    unlist() |&gt; \n    sum()\n}\n\nmtx |&gt; \n  tilt() |&gt; \n  compute_load()",
    "crumbs": [
      "2023",
      "Day 14"
    ]
  },
  {
    "objectID": "2023/R/day14.html#part-2",
    "href": "2023/R/day14.html#part-2",
    "title": "Day 14",
    "section": "Part 2",
    "text": "Part 2\nLook for a cycle, then jump ahead to the 1000000000th state\n\ncycle &lt;- \\(mtx) reduce(c('N', 'W', 'S', 'E'), tilt, .init = mtx)\n\n# Initialize\ncur  &lt;- mtx\nloop &lt;- list()\ni &lt;- 0\n\n# Loop through cycles until a repeating loop is found\nrepeat {\n  i &lt;- i + 1\n  cur &lt;- cycle(cur)\n  loop[[i]] &lt;- cur\n  \n  if (any(duplicated(loop)))\n    break\n}\n\n# Compute the length of the cycle and its starting point\ncycle_rep   &lt;- which(duplicated(loop) | duplicated(loop, fromLast = TRUE))\ncycle_len   &lt;- max(cycle_rep) - min(cycle_rep)\ncycle_start &lt;- min(cycle_rep)\n\n# Compute an equivalent index to find the state at the 1000000000th cycle\nidx &lt;- (1000000000 - cycle_start) %% cycle_len + cycle_start\n\nloop[[idx]] |&gt; \n  compute_load()",
    "crumbs": [
      "2023",
      "Day 14"
    ]
  },
  {
    "objectID": "2023/R/day15.html",
    "href": "2023/R/day15.html",
    "title": "Day 15",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day15.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split_1(\",\")",
    "crumbs": [
      "2023",
      "Day 15"
    ]
  },
  {
    "objectID": "2023/R/day15.html#setup",
    "href": "2023/R/day15.html#setup",
    "title": "Day 15",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day15.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split_1(\",\")",
    "crumbs": [
      "2023",
      "Day 15"
    ]
  },
  {
    "objectID": "2023/R/day15.html#part-1",
    "href": "2023/R/day15.html#part-1",
    "title": "Day 15",
    "section": "Part 1",
    "text": "Part 1\nDefine a function that converts a character string into a hash value as defined by the specs:\n\nascii_hash &lt;- function(str) {\n  reduce(\n    .x = utf8ToInt(str),\n    .f = ~ ((.x + .y) * 17) %% 256, \n    .init = 0\n  )\n}\n\nSeparate the input at the commas, run the ASCII hash on each item, and sum the result:\n\ninput |&gt; \n  map_int(ascii_hash) |&gt; \n  sum()",
    "crumbs": [
      "2023",
      "Day 15"
    ]
  },
  {
    "objectID": "2023/R/day15.html#part-2",
    "href": "2023/R/day15.html#part-2",
    "title": "Day 15",
    "section": "Part 2",
    "text": "Part 2\nDefine a function to place lenses in the appropriate boxes as defined by the input sequence:\n\nhashmap &lt;- function(boxes, str) {\n  label     &lt;- str_extract(str, \"[a-z]+\")\n  box_num   &lt;- ascii_hash(label) + 1\n  operation &lt;- str_extract(str, \"-|=\")\n\n  if (operation == \"=\") \n    boxes[[box_num]][[label]] &lt;- parse_number(str)\n  if (operation == \"-\")\n    boxes[[box_num]] &lt;- discard_at(boxes[[box_num]], label)\n\n  boxes\n}\n\nDefine a function to compute the focusing power of the lenses in the final box arrangement:\n\nfocusing_power &lt;- function(boxes) {\n  boxes |&gt; \n    imap(\\(box, box_num) {\n      imap(unname(box), \\(lens, lens_num) {\n        (as.integer(box_num) + 1) * lens_num * lens\n      })\n    }) |&gt; \n    unlist() |&gt; \n    sum()\n}\n\nRun on puzzle input:\n\ninit_boxes &lt;- map(set_names(0:255), ~ list())\n\ninput |&gt; \n  reduce(hashmap, .init = init_boxes) |&gt; \n  focusing_power()",
    "crumbs": [
      "2023",
      "Day 15"
    ]
  },
  {
    "objectID": "2023/R/day17.html",
    "href": "2023/R/day17.html",
    "title": "Day 17",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day17.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 17"
    ]
  },
  {
    "objectID": "2023/R/day17.html#setup",
    "href": "2023/R/day17.html#setup",
    "title": "Day 17",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day17.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 17"
    ]
  },
  {
    "objectID": "2023/R/day17.html#part-1",
    "href": "2023/R/day17.html#part-1",
    "title": "Day 17",
    "section": "Part 1",
    "text": "Part 1\nConvert text input to a set of 2D coordinates (stored as complex numbers) and their costs:\n\nvtx &lt;- input |&gt; \n  enframe(name = \"row\") |&gt; \n  mutate(value = str_split(value, \"\")) |&gt; \n  unnest_longer(value, indices_to = \"col\") |&gt; \n  transmute(\n    id = row_number(),\n    z = complex(real = col, imaginary = row),\n    cost = as.integer(value)\n  )\n\nz    &lt;- pull(vtx, z)\ncost &lt;- pull(vtx, cost)\n\nnmax &lt;- length(z)\n\nDefine a set of helper functions needed for the pathfinding algorithm:\n\n# Sort a list of lists by the value at the given/named index of the inner lists\nnested_sort &lt;- \\(x, idx) x[order(sapply(x, '[[', idx))]\npsort &lt;- partial(nested_sort, idx = \"priority\")\n\n# Compute the manhattan distance between any two vertices\nmanhattan_dist &lt;- \\(a, b) abs(Re(a - b)) + abs(Im(a - b))\n\n# Pull a vertex's neighbors along the given axis (Re/Im) within a set dist range\nneighbors &lt;- function(vtx, axis = c(\"Re\", \"Im\"), dmin, dmax) {\n  rng &lt;- c(-dmax:-dmin, dmin:dmax) \n  nbr &lt;- vtx + (rng * complex(real = axis == \"Re\", imaginary = axis == \"Im\"))\n  keep(nbr, ~ .x %in% z)\n}\n\n# Compute the cost of moving in a straight line between two vertices\nmove_cost &lt;- function(source, target) {\n  path_indices &lt;- complex(\n    real      = seq(Re(source), Re(target)),\n    imaginary = seq(Im(source), Im(target))\n  ) |&gt; \n    discard(~ .x == source) |&gt; \n    match(z)\n  \n  sum(cost[path_indices])\n}\n\nA* pathfinding implementation (with much help from Reddit on use of complex numbers and storing the turns as part of the state):\n\nhttps://en.wikipedia.org/wiki/A*_search_algorithm\nhttps://www.redblobgames.com/pathfinding/a-star/introduction.html\nhttps://www.reddit.com/r/adventofcode/comments/18khohi/comment/kdrkivy/\n\n\na_star &lt;- function(start, goal, h, dmin, dmax) {\n  \n  # Current set of discovered nodes awaitng further investigation\n  frontier &lt;- list(\n    list(id = start, axis = 'Re', priority = 0),\n    list(id = start, axis = 'Im', priority = 0)\n  )\n  \n  # For each vertex, the immediately preceeding vertex on its cheapest path\n  came_from &lt;- rep(list(lst(Re = NA, Im = NA)), nmax)\n  \n  # Tracks the current min cost to get from 'start' node to node n\n  cost_so_far &lt;- rep(list(lst(Re = Inf, Im = Inf)), nmax)\n  cost_so_far[[start]]$Re &lt;- 0\n  cost_so_far[[start]]$Im &lt;- 0\n  \n  while (length(frontier) &gt; 0) {\n    cur_id   &lt;- frontier[[1]]$id\n    cur_z    &lt;- z[[cur_id]]\n    cur_axis &lt;- frontier[[1]]$axis\n    nxt_axis &lt;- case_match(cur_axis, 'Re' ~ 'Im', 'Im' ~ 'Re')\n    frontier &lt;- tail(frontier, -1)\n    \n    # Return info about best path to goal\n    if (cur_id == goal) return(cost_so_far[[cur_id]][[cur_axis]])\n    \n    # If this path is better than the current record, then replace it\n    for (nxt_z in neighbors(cur_z, cur_axis, dmin, dmax)) {\n      nxt_id &lt;- match(nxt_z, z)\n      tentative_cost &lt;- cost_so_far[[cur_id]][[cur_axis]] + move_cost(cur_z, nxt_z)\n      \n      if (tentative_cost &lt; cost_so_far[[nxt_id]][[nxt_axis]]) {\n        came_from[[nxt_id]][[nxt_axis]] &lt;- cur_id\n        cost_so_far[[nxt_id]][[nxt_axis]] &lt;- tentative_cost\n        \n        frontier &lt;- psort(c(frontier, list(list(\n          id = nxt_id, \n          axis = nxt_axis, \n          priority = tentative_cost + h(nxt_z, z[[goal]])\n        ))))\n      }\n    }\n  }\n}\n\nRun on puzzle input:\n\na_star(1, nmax, h = manhattan_dist, dmin = 1, dmax = 3)",
    "crumbs": [
      "2023",
      "Day 17"
    ]
  },
  {
    "objectID": "2023/R/day17.html#part-2",
    "href": "2023/R/day17.html#part-2",
    "title": "Day 17",
    "section": "Part 2",
    "text": "Part 2\nRe-run on puzzle input with modified min/max distance values passed to the neighbors function:\n\na_star(1, nmax, h = manhattan_dist, dmin = 4, dmax = 10)",
    "crumbs": [
      "2023",
      "Day 17"
    ]
  },
  {
    "objectID": "2023/R/day02.html",
    "href": "2023/R/day02.html",
    "title": "Day 2",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day02.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 2"
    ]
  },
  {
    "objectID": "2023/R/day02.html#setup",
    "href": "2023/R/day02.html#setup",
    "title": "Day 2",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day02.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 2"
    ]
  },
  {
    "objectID": "2023/R/day02.html#part-1",
    "href": "2023/R/day02.html#part-1",
    "title": "Day 2",
    "section": "Part 1",
    "text": "Part 1\nExtract game IDs and red/green/blue counts from each line in the input:\n\ncubes &lt;- input |&gt; \n  \n  # Extract cube colors, numbers, rounds, and games\n  unglue_data(\"Game {game}: {txt=.*}\", convert = TRUE) |&gt; \n  mutate(txt = str_split(txt, \"; \")) |&gt; \n  unnest_longer(txt, indices_to = \"round\", values_to = \"txt\") |&gt; \n  mutate(txt = str_split(txt, \", \")) |&gt; \n  unnest_longer(txt) |&gt; \n  separate(txt, into = c(\"num_cubes\", \"color\"), convert = TRUE) |&gt; \n  \n  # Add implicit zero counts for each color of cube not listed in each round\n  complete(\n    color = c(\"red\", \"blue\", \"green\"), \n    nesting(game, round),\n    fill = list(num_cubes = 0)\n  )\n\nCheck which games are possible if the bag contains only 12 red cubes, 13 green cubes, and 14 blue cubes by flagging any games with any color count over the limit:\n\nlimits &lt;- c(\"red\" = 12, \"green\" = 13, \"blue\" = 14)\n\ncubes |&gt; \n  \n  # Categorize each game as possible vs impossible\n  mutate(num_over_lim = num_cubes &gt; limits[color]) |&gt; \n  summarize(impossible = any(num_over_lim), .by = game) |&gt; \n  \n  # Pull and sum the indices of the possible games\n  filter(!impossible) |&gt; \n  pull(game) |&gt; \n  sum()",
    "crumbs": [
      "2023",
      "Day 2"
    ]
  },
  {
    "objectID": "2023/R/day02.html#part-2",
    "href": "2023/R/day02.html#part-2",
    "title": "Day 2",
    "section": "Part 2",
    "text": "Part 2\nWithin each game, compute the minimum number of cubes of each color by taking the maximum count of each color over all rounds in each game:\n\ncubes |&gt; \n  summarize(min_cubes = max(num_cubes), .by = c(game, color)) |&gt; \n  pivot_wider(names_from = color, values_from = min_cubes) |&gt; \n  mutate(power = blue * green * red) |&gt; \n  pull(power) |&gt; \n  sum()",
    "crumbs": [
      "2023",
      "Day 2"
    ]
  },
  {
    "objectID": "2023/R/day12.html",
    "href": "2023/R/day12.html",
    "title": "Day 12",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day12.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 12"
    ]
  },
  {
    "objectID": "2023/R/day12.html#setup",
    "href": "2023/R/day12.html#setup",
    "title": "Day 12",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day12.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 12"
    ]
  },
  {
    "objectID": "2023/R/day12.html#part-1",
    "href": "2023/R/day12.html#part-1",
    "title": "Day 12",
    "section": "Part 1",
    "text": "Part 1\nConvert text input to a dataframe. Identifiy the indices of each unknown value per row, and convert the numeric input into a regex pattern to test if a given spring arrangement is possible:\n\ndf &lt;- input |&gt; \n  unglue_data(\"{chr} {num}\") |&gt; \n  mutate(\n    regex_pattern = str_c(\n      \"^\\\\.*#{\", \n      str_replace_all(num, \",\", \"}\\\\.+#{\"),\n      \"}\\\\.*$\"\n    ),\n    u_idx = map(chr, ~ which(str_split_1(.x, \"\") == \"?\")),\n    num = map(num, ~ as.integer(str_split_1(.x, \",\"))),\n    total_broken = map_int(num, sum),\n    cur_broken = str_count(chr, \"#\"),\n    num_b = total_broken - cur_broken\n  )\n\nDefine a function to compute the total number of possible arrangements of broken springs for a given row using regex:\n\nidx_permutations &lt;- function(u_idx, num_b) {\n  \n  if (num_b == 0) {\n    list(list(B = numeric(0), O = u_idx))\n  } else {\n    permutations &lt;- combn(length(u_idx), num_b)\n    map(\n      1:ncol(permutations),\n      ~ list(\n        B = u_idx[permutations[,.x]],\n        O = u_idx[-permutations[,.x]]\n      )\n    )\n  }\n  \n}\n\nnum_arragements &lt;- function(input, regex_pattern, u_idx, num_b) {\n  perms &lt;- idx_permutations(u_idx, num_b)\n  vec   &lt;- str_split_1(input, \"\")\n  \n  perms |&gt; \n    map_chr(\\(perm) {\n      vec |&gt; \n        replace(perm$O, \".\") |&gt; \n        replace(perm$B, \"#\") |&gt; \n        str_c(collapse = \"\")\n    }) |&gt; \n    str_detect(regex_pattern) |&gt; \n    sum()\n}\n\nRun on puzzle input:\n\ndf |&gt; \n  pmap_int(\\(chr, regex_pattern, u_idx, num_b, ...) {\n    num_arragements(chr, regex_pattern, u_idx, num_b)\n  }) |&gt; \n  sum()",
    "crumbs": [
      "2023",
      "Day 12"
    ]
  },
  {
    "objectID": "2023/R/day12.html#part-2",
    "href": "2023/R/day12.html#part-2",
    "title": "Day 12",
    "section": "Part 2",
    "text": "Part 2\nWith hints from Reddit, re-define the arrangement-counting function using memoization and recursion to examine at each character:\n\ncount_arr &lt;- memoise::memoise(function(str, grps, grp_count) {\n\n  # Check for contradictions and/or the end of the input\n  if (length(grps) == 0)\n    return(if_else(grp_count == 0 & str_detect(str, \"^(\\\\.|\\\\?)*$\"), 1, 0))\n  else if (str == \"\")\n    return(0)\n  else if (grp_count &gt; grps[1]) \n    return(0)\n\n  # Initialize the total number of arrangements to 0 and get the current char\n  total_arr &lt;- 0\n  cur_chr   &lt;- str_sub(str, 1, 1)\n  \n  # If the char is unknown, examine both of the two possible states\n  if (cur_chr == \"?\")\n    cur_chr &lt;- c(\".\", \"#\")\n  \n  for (chr in cur_chr) {\n    \n    # If '#', recurse within the current group\n    if (chr == \"#\")\n      total_arr &lt;- total_arr + count_arr(str_sub(str, 2), grps, grp_count + 1)\n    \n    # If '.', close the current group (if one is active) & recurse\n    else if (chr == \".\") {\n      if (grp_count == 0)\n        total_arr &lt;- total_arr + count_arr(str_sub(str, 2), grps, grp_count)\n      else if (grp_count == grps[1])\n        total_arr &lt;- total_arr + count_arr(str_sub(str, 2), tail(grps, -1), 0)\n    }\n    \n  }\n  \n  total_arr\n})\n\nRun on puzzle input:\n\ndf |&gt; \n  pmap_dbl(\\(chr, num, ...) {\n    count_arr(str_c(str_c(rep(chr, 5), collapse = \"?\"), \".\"), rep(num, 5), 0)\n  }) |&gt; \n  sum() |&gt; \n  format(scientific = FALSE)",
    "crumbs": [
      "2023",
      "Day 12"
    ]
  },
  {
    "objectID": "2023/R/day07.html",
    "href": "2023/R/day07.html",
    "title": "Day 7",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day07.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 7"
    ]
  },
  {
    "objectID": "2023/R/day07.html#setup",
    "href": "2023/R/day07.html#setup",
    "title": "Day 7",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day07.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 7"
    ]
  },
  {
    "objectID": "2023/R/day07.html#part-1",
    "href": "2023/R/day07.html#part-1",
    "title": "Day 7",
    "section": "Part 1",
    "text": "Part 1\nParse text input as a bid and set of cards for each hand:\n\ncard_types &lt;- c(2:9, 'T', 'J', 'Q', 'K', 'A')\n\nhands &lt;- input |&gt; \n  unglue_data(\"{card1=.}{card2=.}{card3=.}{card4=.}{card5=.} {bid}\") |&gt; \n  transmute(\n    hand_id = row_number(),\n    bid = as.numeric(bid),\n    across(starts_with(\"card\"), partial(factor, levels = card_types)),\n    cards = pmap(list(card1, card2, card3, card4, card5), c)\n  )\n\nDefine a function to compute the type of each hand:\n\nhand_types &lt;- c(\"HIGH\", \"PAIR\", \"2PAIR\", \"3KIND\", \"FULL\", \"4KIND\", \"5KIND\")\n\nhand_type &lt;- function(cards) {\n  card_counts &lt;- sort(summary(cards), decreasing = TRUE)\n  case_when(\n    card_counts[1] == 3 & card_counts[2] == 2 ~ \"FULL\",\n    card_counts[1] == 2 & card_counts[2] == 2 ~ \"2PAIR\",\n    card_counts[1] == 5 ~ \"5KIND\",\n    card_counts[1] == 4 ~ \"4KIND\",\n    card_counts[1] == 3 ~ \"3KIND\",\n    card_counts[1] == 2 ~ \"PAIR\",\n    card_counts[1] == 1 ~ \"HIGH\"\n  )\n}\n\nDefine a function to determine the type of each hand, rank the results, and sum the total winnings:\n\nscore &lt;- function(df) {\n  df |&gt; \n    mutate(hand_type = factor(map_chr(cards, hand_type), levels = hand_types)) |&gt; \n    arrange(hand_type, card1, card2, card3, card4, card5) |&gt; \n    mutate(\n      rank = row_number(),\n      winnings = rank * bid\n    ) |&gt; \n    pull(winnings) |&gt; \n    sum()\n}\n\nRun on puzzle input:\n\nscore(hands)",
    "crumbs": [
      "2023",
      "Day 7"
    ]
  },
  {
    "objectID": "2023/R/day07.html#part-2",
    "href": "2023/R/day07.html#part-2",
    "title": "Day 7",
    "section": "Part 2",
    "text": "Part 2\nRedefine the hand-scoring function to allow jokers to act as any card:\n\nhand_type &lt;- function(cards) {\n  \n  counts_joker &lt;- sum(cards == \"J\")\n  counts_other &lt;- cards |&gt; \n    discard(~ .x == \"J\") |&gt; \n    summary() |&gt; \n    sort(decreasing = TRUE)\n  \n  top_1 &lt;- counts_other[1] + counts_joker\n  top_2 &lt;- counts_other[2]\n  \n  case_when(\n    top_1 == 3 & top_2 == 2 ~ \"FULL\",\n    top_1 == 2 & top_2 == 2 ~ \"2PAIR\",\n    top_1 == 5 ~ \"5KIND\",\n    top_1 == 4 ~ \"4KIND\",\n    top_1 == 3 ~ \"3KIND\",\n    top_1 == 2 ~ \"PAIR\",\n    top_1 == 1 ~ \"HIGH\"\n  )\n}\n\nRe-rank the jokers to the bottom of the card heirarcy and re-score:\n\ncard_types &lt;- c(\"J\", discard(card_types, ~ .x == \"J\"))\n\nhands |&gt; \n  mutate(across(num_range(\"card\", 1:5), partial(factor, levels = card_types))) |&gt; \n  score()",
    "crumbs": [
      "2023",
      "Day 7"
    ]
  },
  {
    "objectID": "2023/R/day05.html",
    "href": "2023/R/day05.html",
    "title": "Day 5",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sets)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day05.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 5"
    ]
  },
  {
    "objectID": "2023/R/day05.html#setup",
    "href": "2023/R/day05.html#setup",
    "title": "Day 5",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sets)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day05.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 5"
    ]
  },
  {
    "objectID": "2023/R/day05.html#part-1",
    "href": "2023/R/day05.html#part-1",
    "title": "Day 5",
    "section": "Part 1",
    "text": "Part 1\nParse input into sets of separate vector inputs and maps:\n\nseeds &lt;- head(input, 1) |&gt; \n  str_remove(\"seeds: \") |&gt; \n  str_split_1(\" \") |&gt; \n  as.numeric()\n\nmaps &lt;- tail(input, -2) |&gt; \n  enframe(name = NULL, value = \"txt\") |&gt; \n  mutate(\n    map_id = cumsum(txt == \"\"),\n    map_name = case_when(str_detect(txt, \":\") ~ txt)\n  ) |&gt; \n  fill(map_name, .direction = \"down\") |&gt; \n  unglue_unnest(map_name, \"{src_cat}-to-{dst_cat} map:\") |&gt; \n  filter(txt != \"\" & !str_detect(txt, \":\")) |&gt; \n  unglue_unnest(txt, \"{dst_start} {src_start} {range_len}\", convert = TRUE) |&gt; \n  mutate(\n    src_end = src_start + range_len - 1,\n    dst_end = dst_start + range_len - 1,\n    diff = dst_start - src_start\n  ) |&gt; \n  select(map_id, src_cat, dst_cat, src_start, src_end, dst_start, dst_end, diff) |&gt; \n  group_split(map_id, .keep = FALSE)\n\nConvert seed maps to interval notation:\n\n# Add rows for the interval complement (neg infinity to infinity) to each map\nmaps_interval &lt;- maps |&gt; \n  map(\\(df) {\n    complement &lt;- df |&gt; \n      pmap(\\(src_start, src_end, ...) {\n        interval(src_start, src_end, domain = 'Z')\n      }) |&gt; \n      interval_union() |&gt; \n      interval_complement() |&gt; \n      as.list() |&gt; \n      map_dfr(~ tibble(src_start = min(.x), src_end = max(.x))) |&gt; \n      mutate(\n        dst_start = src_start,\n        dst_end = src_end,\n        diff = 0\n      )\n    \n    df |&gt; \n      select(-ends_with(\"_cat\")) |&gt; \n      bind_rows(complement)\n  }) \n\n\n# Join each map to one another in sequence to create one overall src/dest map\nmain_map &lt;- maps_interval |&gt; \n  reduce(\n    ~ cross_join(.x, .y) |&gt; \n      mutate(\n        overlap_start = pmax(dst_start.x, src_start.y),\n        overlap_end   = pmin(dst_end.x,   src_end.y),\n        is_overlap    = overlap_start &lt;= overlap_end\n      ) |&gt; \n      filter(is_overlap) |&gt; \n      transmute(\n        src_start = overlap_start - diff.x,\n        src_end   = overlap_end   - diff.x,\n        dst_start = overlap_start + diff.y,\n        dst_end   = overlap_end   + diff.y,\n        diff      = diff.x + diff.y\n      )\n  )\n\nFind final location of all seeds, then take the minimum:\n\nmain_map |&gt; \n  cross_join(tibble(seed = seeds)) |&gt; \n  filter(seed &gt;= src_start & seed &lt;= src_end) |&gt; \n  mutate(loc = seed + diff) |&gt; \n  pull(loc) |&gt; \n  min()",
    "crumbs": [
      "2023",
      "Day 5"
    ]
  },
  {
    "objectID": "2023/R/day05.html#part-2",
    "href": "2023/R/day05.html#part-2",
    "title": "Day 5",
    "section": "Part 2",
    "text": "Part 2\nConvert seed inputs to intervals:\n\nseeds_interval &lt;- tibble(seed = seeds) |&gt; \n  mutate(\n    type = case_match(\n      row_number() %% 2, \n      1 ~ \"seed_start\", \n      0 ~ \"range_len\"\n    ),\n    pair_id = ceiling(row_number() / 2)\n  ) |&gt; \n  pivot_wider(names_from = type, values_from = seed) |&gt; \n  transmute(seed_start, seed_end = seed_start + range_len - 1)\n\nJoin the seed intervals onto the mapper, filter to the overlap, and take the min result:\n\nmain_map |&gt; \n  cross_join(seeds_interval) |&gt; \n  mutate(\n    overlap_start = pmax(seed_start, src_start),\n    overlap_end   = pmin(seed_end,   src_end),\n    is_overlap    = overlap_start &lt;= overlap_end\n  ) |&gt; \n  filter(is_overlap) |&gt; \n  mutate(loc_start = overlap_start + diff) |&gt; \n  pull(loc_start) |&gt; \n  min()",
    "crumbs": [
      "2023",
      "Day 5"
    ]
  },
  {
    "objectID": "2023/R/day10.html",
    "href": "2023/R/day10.html",
    "title": "Day 10",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day10.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 10"
    ]
  },
  {
    "objectID": "2023/R/day10.html#setup",
    "href": "2023/R/day10.html#setup",
    "title": "Day 10",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day10.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 10"
    ]
  },
  {
    "objectID": "2023/R/day10.html#part-1",
    "href": "2023/R/day10.html#part-1",
    "title": "Day 10",
    "section": "Part 1",
    "text": "Part 1\n\ndirs &lt;- list(\n  n = c(row = -1, col =  0),\n  s = c(row =  1, col =  0),\n  w = c(row =  0, col = -1),\n  e = c(row =  0, col =  1)\n)\n\npipes &lt;- list(\n  '|' = list(dirs$n, dirs$s),\n  '-' = list(dirs$w, dirs$e),\n  'L' = list(dirs$n, dirs$e),\n  'J' = list(dirs$n, dirs$w),\n  '7' = list(dirs$s, dirs$w),\n  'F' = list(dirs$s, dirs$e)\n)\n\nConvert text input into a graph:\n\n# Compute row and column of every tile in the input text\nmaze_src &lt;- input |&gt; \n  enframe(name = \"row\") |&gt; \n  mutate(value = str_split(value, \"\")) |&gt; \n  unnest_longer(value, indices_to = \"col\") |&gt; \n  transmute(\n    id = row_number(),\n    chr = value, \n    coords = map2(row, col, ~ c(row = .x, col = .y))\n  )\n\n# Save the index of the starting tile\nid_s &lt;- maze_src |&gt; \n  filter(chr == 'S') |&gt; \n  pull(id)\n\n# Create a copy of the maze for each possible 'S' pipe and compute their conns\nmazes &lt;- map(names(pipes), \\(pipe) {\n  maze_src |&gt; \n    mutate(\n      chr = replace(chr, id_s, pipe),\n      conn = map(chr, ~ pipes[[.x]])\n    ) |&gt; \n    unnest_longer(conn, indices_to = \"conn_num\") |&gt; \n    mutate(conn = map2(coords, conn, ~ .x + .y)) |&gt; \n    unnest_wider(coords) |&gt; \n    unnest_wider(conn, names_sep = \"_\")\n})\n\n# Turn each maze into an undirected graph\ng &lt;- mazes |&gt; \n  map(\\(maze) {\n    edge_list &lt;- maze |&gt; \n      left_join(\n        distinct(maze, conn_id = id, row, col), \n        join_by(x$conn_row == y$row, x$conn_col == y$col)\n      ) |&gt; \n      distinct(id, conn = conn_id) |&gt; \n      drop_na(conn) |&gt; \n      pmap(~ c(..1, ..2))\n    \n    intersect(edge_list, map(edge_list, rev)) |&gt; \n      keep(~ .x[[1]] &lt; .x[[2]]) |&gt; \n      unlist()\n  }) |&gt; \n  map(~ make_graph(as.integer(.x), directed = FALSE))\n\n\n# For each graph, check if there's a cycle containing the starting index\nhas_cycle_s &lt;- map_lgl(g, \\(graph) {\n  subgraphs &lt;- components(graph)$membership\n  sub_vtx &lt;- which(subgraphs == subgraphs[[id_s]])\n  \n  if (length(sub_vtx) &lt;= 2) \n    FALSE\n  else\n    graph |&gt; \n      subgraph(sub_vtx) |&gt; \n      has_eulerian_cycle()\n})\n\n# Keep only the graph that contain a cycle from the starting index\npipe_id_s &lt;- which(has_cycle_s)\nmaze_g &lt;- g[[pipe_id_s]]\n\nCompute the furthest distance on the loop from the starting point:\n\nmembership   &lt;- components(maze_g)$membership\nloop_members &lt;- which(membership == membership[[id_s]])\nloop_g       &lt;- subgraph(maze_g, loop_members)\n\nceiling(girth(loop_g)$girth / 2)",
    "crumbs": [
      "2023",
      "Day 10"
    ]
  },
  {
    "objectID": "2023/R/day10.html#part-2",
    "href": "2023/R/day10.html#part-2",
    "title": "Day 10",
    "section": "Part 2",
    "text": "Part 2\nHint from Reddit (link): To determine if a point is enclosed within a loop, check if a ray in any direction intersects the loop an even or odd number of times.\nFlag the tiles in the maze that make up the loop:\n\nmaze &lt;- maze_src |&gt; \n  mutate(chr = str_replace(chr, \"S\", names(pipes)[[pipe_id_s]])) |&gt; \n  unnest_wider(coords) |&gt; \n  mutate(in_loop = id %in% loop_members)\n\nSeparate the loop by rows and count the number of orthogonal loop tiles for each:\n\nmaze_loop &lt;- filter(maze, in_loop)\n\nloop_rows &lt;- maze_loop |&gt; \n  select(row, col, chr) |&gt; \n  arrange(row, col) |&gt; \n  mutate(\n    segment_num = cumsum(replace_na(col - lag(col), 1) &gt; 1) + 1,\n    .by = row\n  ) |&gt; \n  summarize(\n    col_min = min(col),\n    col_max = max(col),\n    chr = str_c(chr, collapse = \"\"),\n    .by = c(row, segment_num)\n  ) |&gt; \n  mutate(\n    num_crossings = chr |&gt; \n      str_replace_all(\"-\", \"\") |&gt; \n      str_replace_all(\"F7|LJ\", \"\") |&gt; \n      str_replace_all(\"FJ|L7\", \"|\") |&gt; \n      str_count(\"\\\\|\")\n  ) |&gt; \n  select(row, col_min, col_max, num_crossings)\n\nFor each non-loop member of the maze, count the number of times it intersects the loop.\n\n# Count all loop crossings to the left of each non-loop tile\nmaze |&gt; \n  filter(!in_loop) |&gt; \n  left_join(loop_rows, join_by(row, col &lt; col_min)) |&gt; \n  summarize(\n    num_crossings = sum(replace_na(num_crossings, 0)),\n    .by = c(id, row, col)\n  ) |&gt; \n  mutate(num_crossings = num_crossings %% 2) |&gt; \n  pull(num_crossings) |&gt; \n  sum()",
    "crumbs": [
      "2023",
      "Day 10"
    ]
  },
  {
    "objectID": "2024/R/day21.html",
    "href": "2024/R/day21.html",
    "title": "Day 21",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(igraph)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day21.txt\")",
    "crumbs": [
      "2024",
      "Day 21"
    ]
  },
  {
    "objectID": "2024/R/day21.html#setup",
    "href": "2024/R/day21.html#setup",
    "title": "Day 21",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(igraph)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day21.txt\")",
    "crumbs": [
      "2024",
      "Day 21"
    ]
  },
  {
    "objectID": "2024/R/day21.html#part-1",
    "href": "2024/R/day21.html#part-1",
    "title": "Day 21",
    "section": "Part 1",
    "text": "Part 1\nDefine functions calculate minimum distances between keys on a keypad:\n\n# Helper function to convert pairs of adjacent keys to their directions\nkeypad_to_df &lt;- function(keys, rows, cols) {\n  df &lt;- tibble(key = keys, row = rows, col = cols)\n  \n  cross_join(df, df, suffix = c(\"_from\", \"_to\")) |&gt; \n    filter(abs(row_to - row_from) + abs(col_to - col_from) == 1) |&gt; \n    mutate(dir = case_when(\n      col_from &lt; col_to ~ \"&gt;\",\n      col_from &gt; col_to ~ \"&lt;\",\n      row_from &lt; row_to ~ \"^\",\n      row_from &gt; row_to ~ \"v\"\n    ))\n}\n\n# Convert a keypad (set of keys and their coordinates) to a graph\nkeypad_to_graph &lt;- function(keys, rows, cols) {\n  df &lt;- keypad_to_df(keys, rows, cols)\n  g &lt;- df |&gt; \n    transmute(from = key_from, to = key_to) |&gt; \n    graph_from_data_frame(vertices = keys)\n  f &lt;- function(from, to) {\n    df |&gt; \n    filter(key_from == from & key_to == to) |&gt; \n    pull(dir)\n  }\n  list(\"df\" = df, \"g\" = g, \"f\" = f)\n}\n\n# Return all shortests paths between two keys on a keypad\nkeypad_paths &lt;- function(keypad, key_from, key_to) {\n  all_shortest_paths(keypad$g, from = key_from, to = key_to)$vpaths |&gt; \n    map_chr(\\(x) {\n      dirs &lt;- map2_chr(\n        head(names(x), -1), \n        head(lead(names(x)), -1), \n        \\(dir_from, dir_to) keypad$f(dir_from, dir_to)\n      )\n      str_c(c(dirs, \"A\"), collapse = \"\")\n    })\n}\n\n# Define the numeric keypad\nkeys_num &lt;- c(\"A\", 0:9)\nrows_num &lt;- case_match(keys_num,\n  c(\"A\", \"0\")      ~ 1,\n  c(\"1\", \"2\", \"3\") ~ 2,\n  c(\"4\", \"5\", \"6\") ~ 3,\n  c(\"7\", \"8\", \"9\") ~ 4\n)\ncols_num &lt;- case_match(keys_num,\n  c(\"1\", \"4\", \"7\")      ~ 1,\n  c(\"0\", \"2\", \"5\", \"8\") ~ 2,\n  c(\"A\", \"3\", \"6\", \"9\") ~ 3\n)\nkeypad_num &lt;- keypad_to_graph(keys = keys_num, row = rows_num, col = cols_num)\n\n# Define the directional keypad\nkeys_dir &lt;- c(\"&lt;\", \"v\", \"&gt;\", \"^\", \"A\")\nrows_dir &lt;- case_match(keys_dir,\n  c(\"&lt;\", \"v\", \"&gt;\") ~ 1,\n  c(\"^\", \"A\")      ~ 2\n)\ncols_dir &lt;- case_match(keys_dir,\n  c(\"&lt;\")      ~ 1,\n  c(\"v\", \"^\") ~ 2,\n  c(\"&gt;\", \"A\") ~ 3\n)\nkeypad_dir &lt;- keypad_to_graph(keys = keys_dir, row = rows_dir, col = cols_dir)\n\n# Recursively compute the minimum user input for a given input string\nmin_path &lt;- function(input_str, level = 0, max_level = 3) {\n  if (level == max_level)\n    return(str_length(input_str))\n  \n  keypad &lt;- if (level == 0) keypad_num else keypad_dir\n  \n  input_to &lt;- str_split_1(input_str, \"\")\n  input_from &lt;- lag(input_to, default = \"A\")\n  steps &lt;- map2_int(\n    input_from, \n    input_to, \n    \\(from, to) keypad_paths(keypad, from, to) |&gt; \n      map_int(min_path, level = level + 1, max_level = max_level) |&gt; \n      min()\n  )\n  sum(steps)\n}\n\nRun on puzzle input:\n\ntibble(input) |&gt; \n  mutate(\n    numeric_code = parse_number(input),\n    shortest_seq = map_int(input, min_path),\n    complexity = numeric_code * shortest_seq\n  ) |&gt; \n  pull(complexity) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 21"
    ]
  },
  {
    "objectID": "2024/R/day21.html#part-2",
    "href": "2024/R/day21.html#part-2",
    "title": "Day 21",
    "section": "Part 2",
    "text": "Part 2\nModify the min_path function to condense all inputs wherever possible so needless computation isn’t repeated:\n\nmin_path &lt;- function(input_str, level = 0, max_level = 3) {\n  if (level == max_level)\n    return(str_length(input_str))\n  \n  keypad &lt;- if (level == 0) keypad_num else keypad_dir\n  \n  df &lt;- tibble(str = input_str) |&gt; \n    mutate(\n      id = row_number(),\n      key = map(str, ~ tibble(\n        input_to = str_split_1(.x, \"\"),\n        input_from = lag(input_to, default = \"A\")\n      ))\n    ) |&gt; \n      unnest(key)\n\n  steps &lt;- df |&gt; \n    distinct(input_from, input_to) |&gt; \n    mutate(paths = map2(input_from, input_to, ~ keypad_paths(keypad, .x, .y))) |&gt; \n    unnest(paths) |&gt; \n    mutate(len = min_path(paths, level = level + 1, max_level = max_level)) |&gt; \n    slice_min(len, by = c(input_from, input_to), with_ties = FALSE)\n  \n  df |&gt; \n    left_join(steps, join_by(input_from, input_to)) |&gt; \n    summarize(steps = sum(len), .by = c(id, str)) |&gt; \n    pull(steps)\n}\n\nRe-run puzzle input with a max level of 26:\n\ntibble(input) |&gt; \n  mutate(\n    numeric_code = parse_number(input),\n    shortest_seq = map_dbl(input, min_path, max_level = 26),\n    complexity = numeric_code * shortest_seq\n  ) |&gt; \n  pull(complexity) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 21"
    ]
  },
  {
    "objectID": "2024/R/day08.html",
    "href": "2024/R/day08.html",
    "title": "Day 8",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day08.txt\")\n\nConvert text input to a character matrix:\n\nmtx &lt;- input |&gt;\n  str_split(\"\") |&gt; \n  unlist() |&gt; \n  matrix(nrow = length(input), byrow = TRUE)",
    "crumbs": [
      "2024",
      "Day 8"
    ]
  },
  {
    "objectID": "2024/R/day08.html#setup",
    "href": "2024/R/day08.html#setup",
    "title": "Day 8",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day08.txt\")\n\nConvert text input to a character matrix:\n\nmtx &lt;- input |&gt;\n  str_split(\"\") |&gt; \n  unlist() |&gt; \n  matrix(nrow = length(input), byrow = TRUE)",
    "crumbs": [
      "2024",
      "Day 8"
    ]
  },
  {
    "objectID": "2024/R/day08.html#part-1",
    "href": "2024/R/day08.html#part-1",
    "title": "Day 8",
    "section": "Part 1",
    "text": "Part 1\nDefine a helper function to check if a coordinate x is within the bounds of the map (mtx):\n\nin_bounds &lt;- \\(x, map) between(x[1], 1, nrow(map)) & between(x[2], 1, ncol(map))\n\nDefine a helper function to compute the antinodes of a given pair of antenna coordinates on a map:\n\nantinode_pair &lt;- function(x1, x2, map) {\n  diff &lt;- x2 - x1\n  keep(list(x1 - diff, x2 + diff), ~ in_bounds(.x, map))\n}\n\nDefine a helper function to get the coordinates of every antenna of a given frequency on a map:\n\nget_antennas &lt;- function(freq, map) {\n  antennas &lt;- which(map == freq, arr.ind = TRUE)\n  split(antennas, row(antennas))\n}\n\nDefine a function to compute all antinodes of a given frequency in a map:\n\nget_all_antinodes &lt;- function(freq, map, f) {\n  antennas &lt;- get_antennas(freq, map)\n  \n  pairs &lt;- combn(antennas, 2)\n  pairs &lt;- split(pairs, col(pairs))\n  \n  pairs |&gt; \n    map(~ f(.x[[1]], .x[[2]], map)) |&gt; \n    list_flatten() |&gt; \n    unique()\n}\n\nCompute the distinct set of frequencies in the map:\n\nfreqs &lt;- mtx |&gt;\n  as.vector() |&gt;\n  unique() |&gt; \n  keep(~ .x %in% c(letters, LETTERS, as.character(0:9)))\n\nCount all distinct antinode locations across all frequencies in the map:\n\nfreqs |&gt; \n  map(~ get_all_antinodes(.x, mtx, antinode_pair)) |&gt; \n  list_flatten() |&gt; \n  unique() |&gt; \n  length()",
    "crumbs": [
      "2024",
      "Day 8"
    ]
  },
  {
    "objectID": "2024/R/day08.html#part-2",
    "href": "2024/R/day08.html#part-2",
    "title": "Day 8",
    "section": "Part 2",
    "text": "Part 2\nUpdate the antinode function which computes the antidotes of a given pair of antennas:\n\nantinode_set &lt;- function(x1, x2, map) {\n  diff &lt;- x2 - x1\n  antinodes &lt;- list(x1, x2)\n  \n  i &lt;- 1\n  while(in_bounds(x2 + i * diff, map)) {\n    antinodes &lt;- c(antinodes, list(as.integer(x2 + i * diff)))\n    i &lt;- i + 1\n  }\n\n  i &lt;- 1\n  while(in_bounds(x1 - i * diff, map)) {\n    antinodes &lt;- c(antinodes, list(as.integer(x1 - i * diff)))\n    i &lt;- i + 1\n  }\n  \n  antinodes\n}\n\nRe-run puzzle input:\n\nfreqs |&gt; \n  map(~ get_all_antinodes(.x, mtx, antinode_set)) |&gt; \n  list_flatten() |&gt; \n  unique() |&gt; \n  length()",
    "crumbs": [
      "2024",
      "Day 8"
    ]
  },
  {
    "objectID": "2024/R/day23.html",
    "href": "2024/R/day23.html",
    "title": "Day 23",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(igraph)\n\nRead input from text file into a data frame:\n\ninput &lt;- read_lines(\"../input/day23.txt\") |&gt; \n  unglue_data(\"{v1}-{v2}\")",
    "crumbs": [
      "2024",
      "Day 23"
    ]
  },
  {
    "objectID": "2024/R/day23.html#setup",
    "href": "2024/R/day23.html#setup",
    "title": "Day 23",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(igraph)\n\nRead input from text file into a data frame:\n\ninput &lt;- read_lines(\"../input/day23.txt\") |&gt; \n  unglue_data(\"{v1}-{v2}\")",
    "crumbs": [
      "2024",
      "Day 23"
    ]
  },
  {
    "objectID": "2024/R/day23.html#part-1",
    "href": "2024/R/day23.html#part-1",
    "title": "Day 23",
    "section": "Part 1",
    "text": "Part 1\nConvert the lists of connections to an undirected graph:\n\ng &lt;- input |&gt; \n  pmap(function(v1, v2) c(v1, v2)) |&gt; \n  unlist() |&gt; \n  make_graph(directed = FALSE)\n\nFind all sets of 3 connected vertices (cliques of size 3) and count the sets having some vertex starting with ‘t’\n\ncliques(g, min = 3, max = 3) |&gt; \n  keep(\n    ~ names(.x) |&gt; \n      str_starts(\"t\") |&gt; \n      any()\n  ) |&gt; \n  length()",
    "crumbs": [
      "2024",
      "Day 23"
    ]
  },
  {
    "objectID": "2024/R/day23.html#part-2",
    "href": "2024/R/day23.html#part-2",
    "title": "Day 23",
    "section": "Part 2",
    "text": "Part 2\nFind the largest interconnected set of vertices, then convert the list of vertices into the “password” by sorting alphabetically and concatenating with commas:\n\ng |&gt; \n  largest_cliques() |&gt; \n  unlist() |&gt; \n  names() |&gt; \n  sort() |&gt; \n  str_flatten(\",\")",
    "crumbs": [
      "2024",
      "Day 23"
    ]
  },
  {
    "objectID": "2024/R/day18.html",
    "href": "2024/R/day18.html",
    "title": "Day 18",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(igraph)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day18.txt\") |&gt; \n  unglue_data(patterns = \"{col},{row}\", convert = TRUE) |&gt; \n  mutate(byte_num = row_number())\n\nDefine paramaters – coordinates can be no more than 70 in any direction:\n\nmaxdim &lt;- 70",
    "crumbs": [
      "2024",
      "Day 18"
    ]
  },
  {
    "objectID": "2024/R/day18.html#setup",
    "href": "2024/R/day18.html#setup",
    "title": "Day 18",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(igraph)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day18.txt\") |&gt; \n  unglue_data(patterns = \"{col},{row}\", convert = TRUE) |&gt; \n  mutate(byte_num = row_number())\n\nDefine paramaters – coordinates can be no more than 70 in any direction:\n\nmaxdim &lt;- 70",
    "crumbs": [
      "2024",
      "Day 18"
    ]
  },
  {
    "objectID": "2024/R/day18.html#part-1",
    "href": "2024/R/day18.html#part-1",
    "title": "Day 18",
    "section": "Part 1",
    "text": "Part 1\nFill out the full grid with the provided dimensions:\n\ngrid &lt;- input |&gt; \n  complete(col = 0:maxdim, row = 0:maxdim) |&gt; \n  mutate(id = row_number(), .before = everything()) |&gt; \n  \n  # Define the graph edges (cell borders) between vertices (cells)\n  mutate(edge_w = map2(id, lag(id), ~ c(.x, .y)), .by = row) |&gt; \n  mutate(edge_n = map2(id, lag(id), ~ c(.x, .y)), .by = col)\n\nDefine the IDs of the start and end vertices:\n\nstart &lt;- grid |&gt; \n  filter(row == 0 & col == 0) |&gt; \n  pull(id)\n\nexit &lt;- grid |&gt; \n  filter(row == maxdim & col == maxdim) |&gt; \n  pull(id)\n\nConvert the grid to a graph and count the steps from the start to the exit:\n\ncompute_num_steps &lt;- function(grid, start, exit, num_bytes) {\n\n  grid |&gt; \n    \n    # Flag and remove any graph edges between corrupted cells\n    mutate(corrupted = replace_na(byte_num &lt;= num_bytes, FALSE)) |&gt; \n    mutate(\n      edge_w = case_when(!corrupted & !lag(corrupted) ~ edge_w), \n      .by = row\n    ) |&gt; \n    mutate(\n      edge_n = case_when(!corrupted & !lag(corrupted) ~ edge_n), \n      .by = col\n    ) |&gt; \n    \n    # Pull graph edges\n    select(edge_w, edge_n) |&gt; \n    pivot_longer(everything()) |&gt; \n    pull(value) |&gt; \n    discard(is.null) |&gt; \n    unlist() |&gt; \n    \n    # Convert to a graph\n    make_graph(n = max(grid$id), directed = FALSE) |&gt; \n    \n    # Count the steps from the start to the exit\n    distances(start, exit) |&gt; \n    as.list() |&gt; \n    unlist()\n  \n}\n\nRun puzzle input:\n\ncompute_num_steps(grid, start, exit, 1024)",
    "crumbs": [
      "2024",
      "Day 18"
    ]
  },
  {
    "objectID": "2024/R/day18.html#part-2",
    "href": "2024/R/day18.html#part-2",
    "title": "Day 18",
    "section": "Part 2",
    "text": "Part 2\nLoop through different byte values to find the first byte that blocks the path:\n\n# Initialize byte counts\nmax_bytes &lt;- max(grid$byte_num, na.rm = TRUE)\nmax_walkable &lt;- 1024\nmin_unwalkable &lt;- max_bytes\nnum_bytes &lt;- round(mean(c(max_walkable, min_unwalkable)))\n\n# Loop through bytes, a half at a time\nwhile (min_unwalkable - max_walkable &gt; 1) {\n  num_steps &lt;- compute_num_steps(grid, start, exit, num_bytes)\n  \n  if (is.infinite(num_steps))\n    min_unwalkable &lt;- num_bytes\n  else \n    max_walkable &lt;- num_bytes\n    \n  num_bytes &lt;- round(mean(c(max_walkable, min_unwalkable)))\n}\n\nGet the coordinates of the first byte that blocks the path:\n\ngrid |&gt; \n  filter(byte_num == min_unwalkable) |&gt; \n  mutate(coord = str_c(col, row, sep = \",\")) |&gt; \n  pull(coord)",
    "crumbs": [
      "2024",
      "Day 18"
    ]
  },
  {
    "objectID": "2024/R/day25.html",
    "href": "2024/R/day25.html",
    "title": "Day 25",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file\n\ninput &lt;- read_lines(\"../input/day25.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2024",
      "Day 25"
    ]
  },
  {
    "objectID": "2024/R/day25.html#setup",
    "href": "2024/R/day25.html#setup",
    "title": "Day 25",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file\n\ninput &lt;- read_lines(\"../input/day25.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2024",
      "Day 25"
    ]
  },
  {
    "objectID": "2024/R/day25.html#part-1",
    "href": "2024/R/day25.html#part-1",
    "title": "Day 25",
    "section": "Part 1",
    "text": "Part 1\nConvert input to lists of keys and locks by height:\n\ngroups &lt;- input |&gt; \n  enframe(name = NULL) |&gt; \n  mutate(group_id = cumsum(value == \"\"), .before = everything()) |&gt; \n  filter(value != \"\") |&gt; \n  mutate(\n    col = str_split(value, \"\"),\n    row = row_number(),\n    .by = group_id\n  ) |&gt; \n  mutate(\n    type = case_when(row == 1 ~ if_else(str_detect(value, \"#\"), \"lock\", \"key\"))\n  ) |&gt; \n  fill(type, .direction = \"down\") |&gt; \n  unnest_wider(col, names_sep = \"\") |&gt; \n  mutate(group_id = str_c(type, \"_\", group_id)) |&gt; \n  select(-c(value, row, type, row)) |&gt; \n  group_split(group_id)\n\ngroups &lt;- set_names(groups, map_chr(groups, ~ unique(pull(.x, group_id))))\n\nTranspose data frames and count pin heights of each column:\n\npins &lt;- groups |&gt; \n  map(\n    ~ .x |&gt; \n      select(-group_id) |&gt; \n      as.matrix() |&gt; \n      t() |&gt; \n      as_tibble() |&gt; \n      transmute(height = rowSums(across(everything(), ~ .x == \"#\")) - 1) |&gt; \n      pull(height)\n  )\n\nlocks &lt;- keep_at(pins, ~ str_starts(.x, \"lock\"))\nkeys  &lt;- keep_at(pins, ~ str_starts(.x, \"key\"))\n\nCompute maximum height for any given lock/key combo:\n\nmax_height &lt;- nrow(groups[[1]]) - 2\n\nCross all locks with all keys and check for overlapping pins:\n\nexpand_grid(lock = locks, key = keys) |&gt; \n  mutate(fits = map2_lgl(lock, key, ~ max(.x + .y) &lt;= max_height)) |&gt; \n  pull(fits) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 25"
    ]
  },
  {
    "objectID": "2024/R/day01.html",
    "href": "2024/R/day01.html",
    "title": "Day 1",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file into a data frame:\n\ninput &lt;- read_table(\"../input/day01.txt\", col_names = c(\"x\", \"y\"))",
    "crumbs": [
      "2024",
      "Day 1"
    ]
  },
  {
    "objectID": "2024/R/day01.html#setup",
    "href": "2024/R/day01.html#setup",
    "title": "Day 1",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file into a data frame:\n\ninput &lt;- read_table(\"../input/day01.txt\", col_names = c(\"x\", \"y\"))",
    "crumbs": [
      "2024",
      "Day 1"
    ]
  },
  {
    "objectID": "2024/R/day01.html#part-1",
    "href": "2024/R/day01.html#part-1",
    "title": "Day 1",
    "section": "Part 1",
    "text": "Part 1\nSort each list independently, then sum the distances between each pair of ordered items:\n\nsum(abs(sort(input$x) - sort(input$y)))",
    "crumbs": [
      "2024",
      "Day 1"
    ]
  },
  {
    "objectID": "2024/R/day01.html#part-2",
    "href": "2024/R/day01.html#part-2",
    "title": "Day 1",
    "section": "Part 2",
    "text": "Part 2\nFor each item in list x, multiply its value by its number of occurrences in list y, then sum the total. Since an x value occurring 0 times in list y doesn’t contribute to the total, we can just filter y to the values also in x and sum the result:\n\nsum(keep(input$y, \\(y) y %in% input$x))",
    "crumbs": [
      "2024",
      "Day 1"
    ]
  },
  {
    "objectID": "2024/R/day03.html",
    "href": "2024/R/day03.html",
    "title": "Day 3",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file and combine into a single string:\n\ninput &lt;- read_lines(\"../input/day03.txt\") |&gt; \n  str_c(collapse = \"\")",
    "crumbs": [
      "2024",
      "Day 3"
    ]
  },
  {
    "objectID": "2024/R/day03.html#setup",
    "href": "2024/R/day03.html#setup",
    "title": "Day 3",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file and combine into a single string:\n\ninput &lt;- read_lines(\"../input/day03.txt\") |&gt; \n  str_c(collapse = \"\")",
    "crumbs": [
      "2024",
      "Day 3"
    ]
  },
  {
    "objectID": "2024/R/day03.html#part-1",
    "href": "2024/R/day03.html#part-1",
    "title": "Day 3",
    "section": "Part 1",
    "text": "Part 1\nDefine a function that “uncorrupts” a string of text by extracting all valid mul instructions, executing them, and adding them together. We perform this extraction with regex:\n\nuncorrupt &lt;- function(str) {\n  str |&gt; \n    str_extract_all(\"mul\\\\(\\\\d+,\\\\d+\\\\)\") |&gt; \n    unlist() |&gt; \n    unglue_data(\"mul({d1},{d2})\", convert = TRUE) |&gt; \n    pmap_dbl(prod) |&gt; \n    sum()\n}\n\nRun the uncorrupt function on the puzzle input:\n\nuncorrupt(input)",
    "crumbs": [
      "2024",
      "Day 3"
    ]
  },
  {
    "objectID": "2024/R/day03.html#part-2",
    "href": "2024/R/day03.html#part-2",
    "title": "Day 3",
    "section": "Part 2",
    "text": "Part 2\nRemove all text between don't() and do(), then uncorrupt the result. We use the regex expression .*? to remove as little text as possible between the don't and do statements (ungreedy), so that only the most recent command is used:\n\ninput |&gt; \n  str_remove_all(\"don't\\\\(\\\\).*?do\\\\(\\\\)\") |&gt;   \n  uncorrupt()",
    "crumbs": [
      "2024",
      "Day 3"
    ]
  },
  {
    "objectID": "2024/R/day16.html",
    "href": "2024/R/day16.html",
    "title": "Day 16",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(igraph)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day16.txt\")",
    "crumbs": [
      "2024",
      "Day 16"
    ]
  },
  {
    "objectID": "2024/R/day16.html#setup",
    "href": "2024/R/day16.html#setup",
    "title": "Day 16",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(igraph)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day16.txt\")",
    "crumbs": [
      "2024",
      "Day 16"
    ]
  },
  {
    "objectID": "2024/R/day16.html#part-1",
    "href": "2024/R/day16.html#part-1",
    "title": "Day 16",
    "section": "Part 1",
    "text": "Part 1\nConvert text input into a weighted, undirected graph:\n\n# Convert input to a data frame\ndf &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  unlist() |&gt; \n  as_tibble_col(column_name = \"cell\") |&gt; \n  mutate(\n    input_id  = row_number() - 1,\n    row = floor(input_id / length(input)),\n    col = floor(input_id %% length(input))\n  )\n\n# Convert borders between grid cells to graph vertices and map edges by cell\nborders &lt;- df |&gt; \n  mutate(border_e = (cell != \"#\" & lead(cell) != \"#\"), .by = row) |&gt; \n  mutate(border_s = (cell != \"#\" & lead(cell) != \"#\"), .by = col) |&gt; \n  mutate(\n    vtx_id_e = case_when(border_e ~ cumsum(border_e)),\n    vtx_id_s = case_when(border_s ~ cumsum(border_s) + max(vtx_id_e, na.rm = T))\n  ) |&gt; \n  mutate(vtx_id_n = lag(vtx_id_s), .by = col) |&gt; \n  mutate(vtx_id_w = lag(vtx_id_e), .by = row) |&gt; \n  mutate(\n    conn_ns = map2(vtx_id_n, vtx_id_s, ~ na.omit(c(.x, .y))),\n    conn_ew = map2(vtx_id_e, vtx_id_w, ~ na.omit(c(.x, .y))),\n    conn_ne = map2(vtx_id_n, vtx_id_e, ~ na.omit(c(.x, .y))),\n    conn_nw = map2(vtx_id_n, vtx_id_w, ~ na.omit(c(.x, .y))),\n    conn_se = map2(vtx_id_s, vtx_id_e, ~ na.omit(c(.x, .y))),\n    conn_sw = map2(vtx_id_s, vtx_id_w, ~ na.omit(c(.x, .y))),\n  )\n\n# Extract the list of all vertices\nvertices &lt;- c(borders$vtx_id_e, borders$vtx_id_s) |&gt; \n  na.omit() |&gt; \n  sort()\n\n# Convert vertices and edges to an adjacency matrix\nmtx &lt;- borders |&gt; \n  # Unnest lists of edge connections between vertices\n  select(starts_with(\"conn\")) |&gt; \n  pivot_longer(everything(), names_to = \"conn\", names_prefix = \"conn_\") |&gt; \n  unnest_wider(value, names_sep = \"_\") |&gt; \n  drop_na(value_1, value_2) |&gt; \n  # Rotations get an extra 1k added to the weight\n  mutate(weight = case_match(conn, c(\"ns\", \"ew\") ~ 1, .default = 1001)) |&gt; \n  select(-conn) |&gt; \n  # Convert to matrix format, where unconnected vertices have weight 0\n  complete(value_1 = vertices, value_2 = vertices, fill = list(weight = 0)) |&gt; \n  arrange(value_1, value_2) |&gt; \n  pivot_wider(names_from = value_2, values_from = weight) |&gt; \n  column_to_rownames(var = \"value_1\") |&gt; \n  as.matrix()\n\n# Make matrix symmetric (for an undirected graph)\nsym_mtx &lt;- pmax(mtx, t(mtx))\n\n# Convert adjacency matrix to a graph\ng &lt;- graph_from_adjacency_matrix(sym_mtx, mode = \"undirected\", weighted = TRUE)\n\nDetermine possible starting and ending locations from the input:\n\nspecial_cells &lt;- borders |&gt; \n  filter(cell %in% c(\"S\", \"E\")) |&gt; \n  select(cell, starts_with(\"vtx_id\")) |&gt; \n  pivot_longer(\n    starts_with(\"vtx_id\"), \n    names_prefix = \"vtx_id_\",\n    names_to = \"dir\",\n    values_to = \"vertex\"\n  ) |&gt; \n  drop_na(vertex)\n\n# Create all combinations of start & end cell borders\ncombos &lt;- special_cells |&gt; \n  filter(cell == \"S\") |&gt; \n  mutate(\n    init_rotation = case_match(dir, \"e\" ~ 0, c(\"n\", \"s\") ~ 1, \"w\" ~ 2) * 1000\n  ) |&gt;\n  select(start_vertex = vertex, init_rotation) |&gt; \n  cross_join(\n    special_cells |&gt; \n      filter(cell == \"E\") |&gt; \n      select(end_vertex = vertex)\n  )\n\nFind the minimum path distance for each start/end vertex combo:\n\nmin_dist &lt;- combos |&gt; \n  mutate(\n    dist = map2_int(\n      start_vertex, \n      end_vertex, \n      ~ distances(g, .x, .y)) + init_rotation + 1\n  ) |&gt; \n  slice_min(dist)\n\nmin_dist |&gt; \n  pull(dist)",
    "crumbs": [
      "2024",
      "Day 16"
    ]
  },
  {
    "objectID": "2024/R/day16.html#part-2",
    "href": "2024/R/day16.html#part-2",
    "title": "Day 16",
    "section": "Part 2",
    "text": "Part 2\nPull all paths that have the minimum distance from start to end:\n\nshortest_paths &lt;- min_dist |&gt; \n  pmap(function(start_vertex, init_rotation, end_vertex, ...) {\n    all_shortest_paths(g, start_vertex, end_vertex)$vpaths\n  }) |&gt; \n  flatten() |&gt; \n  map(as.integer)\n\npath_vertices &lt;- shortest_paths |&gt; \n  unlist() |&gt; \n  unique() |&gt; \n  sort()\n\nCount all non-wall cells with a border in the shortest path vertex list:\n\nborders |&gt; \n  select(cell, input_id, starts_with(\"vtx_id\")) |&gt; \n  pivot_longer(starts_with(\"vtx_id\")) |&gt; \n  drop_na(value) |&gt; \n  filter(map_lgl(value, ~ .x %in% path_vertices)) |&gt; \n  filter(cell != \"#\") |&gt; \n  distinct(input_id) |&gt; \n  nrow()",
    "crumbs": [
      "2024",
      "Day 16"
    ]
  },
  {
    "objectID": "2024/R/day06.html",
    "href": "2024/R/day06.html",
    "title": "Day 6",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day06.txt\")\n\nConvert text input of the map into a 1/0 matrix (saving the guard’s initial location):\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  unlist() |&gt; \n  case_match(\".\" ~ 0, \"#\" ~ 1, c(\"^\", \"v\", \"&lt;\", \"&gt;\") ~ 2) |&gt; \n  matrix(nrow = length(input), byrow = TRUE)\n\ninit &lt;- as.vector(which(mtx == 2, arr.ind = TRUE))\n\nmtx &lt;- replace(mtx, mtx == 2, 0)",
    "crumbs": [
      "2024",
      "Day 6"
    ]
  },
  {
    "objectID": "2024/R/day06.html#setup",
    "href": "2024/R/day06.html#setup",
    "title": "Day 6",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day06.txt\")\n\nConvert text input of the map into a 1/0 matrix (saving the guard’s initial location):\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  unlist() |&gt; \n  case_match(\".\" ~ 0, \"#\" ~ 1, c(\"^\", \"v\", \"&lt;\", \"&gt;\") ~ 2) |&gt; \n  matrix(nrow = length(input), byrow = TRUE)\n\ninit &lt;- as.vector(which(mtx == 2, arr.ind = TRUE))\n\nmtx &lt;- replace(mtx, mtx == 2, 0)",
    "crumbs": [
      "2024",
      "Day 6"
    ]
  },
  {
    "objectID": "2024/R/day06.html#part-1",
    "href": "2024/R/day06.html#part-1",
    "title": "Day 6",
    "section": "Part 1",
    "text": "Part 1\nDefine a function that loops through guard positions until it leaves the map, returning a list of all positions where they turned:\n\nmaxdim &lt;- c(1, ncol(mtx), nrow(mtx), 1)\nmtxdir &lt;- c(-1, 1, 1, -1)\nmtxaxis &lt;- c(1, 2, 1, 2)\n\nguard_path &lt;- function(mtx, init) {\n  guard &lt;- init\n  hist &lt;- list(guard)\n  idx &lt;- 1\n  \n  repeat {\n    dir &lt;- mtxdir[idx]\n    dim &lt;- maxdim[idx]\n    axis &lt;- mtxaxis[idx]\n    \n    if (axis == 1) {\n      path &lt;- mtx[(guard[1] + dir):dim, guard[2]]\n    } else {\n      path &lt;- mtx[guard[1], (guard[2] + dir):dim]\n    }\n    \n    # Quit if we reach the edge of the map without an obstacle\n    if (all(path == 0)) {\n      guard[axis] &lt;- dim\n      hist &lt;- c(hist, list(guard))\n      return(hist)\n    }\n    \n    # Move the guard\n    guard[axis] &lt;- guard[axis] + dir * head(which(path == 1) - 1, 1)\n    \n    # If we've entered a loop (same position + same direction), exit early\n    if (list(guard) %in% hist) {\n      # (we can't compare nested lists directly, so must compare str vers)\n      hist_str &lt;- map_chr(hist, ~ str_flatten(.x, collapse = \"|\"))\n      guard_str &lt;- str_flatten(guard, collapse = \"|\")\n      if (idx %in% ((which(guard_str == hist_str) - 2) %% 4 + 1))\n        return()\n    }\n    \n    # Update the guard's history and the indexing\n    hist &lt;- c(hist, list(guard))\n    idx &lt;- idx %% 4 + 1\n  }\n}\n\nGet the guard’s path for the puzzle input, then count the number of unique positions visited by the guard:\n\npath &lt;- guard_path(mtx, init)\n\npath_full &lt;- map2(head(path, -1), tail(path, -1), \\(source, target) {\n  expand_grid(row = source[1]:target[1], col = source[2]:target[2])\n}) |&gt; \n  bind_rows() |&gt; \n  distinct()\n\nnrow(path_full)",
    "crumbs": [
      "2024",
      "Day 6"
    ]
  },
  {
    "objectID": "2024/R/day13.html",
    "href": "2024/R/day13.html",
    "title": "Day 13",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day13.txt\", skip_empty_rows = TRUE)\n\nExtract numerical values from text input into a data frame:\n\ndf &lt;- input |&gt; \n  unglue_data(c(\n    \"Button {button}: X+{x=\\\\d+}, Y+{y=\\\\d+}\",\n    \"{button}: X={x=\\\\d+}, Y={y=\\\\d+}\"\n  )) |&gt; \n  mutate(\n    machine_id = floor((row_number() - 1) / 3),\n    across(c(x, y), parse_number),\n    .before = everything()\n  ) |&gt; \n  pivot_wider(names_from = button, values_from = c(x, y))",
    "crumbs": [
      "2024",
      "Day 13"
    ]
  },
  {
    "objectID": "2024/R/day13.html#setup",
    "href": "2024/R/day13.html#setup",
    "title": "Day 13",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day13.txt\", skip_empty_rows = TRUE)\n\nExtract numerical values from text input into a data frame:\n\ndf &lt;- input |&gt; \n  unglue_data(c(\n    \"Button {button}: X+{x=\\\\d+}, Y+{y=\\\\d+}\",\n    \"{button}: X={x=\\\\d+}, Y={y=\\\\d+}\"\n  )) |&gt; \n  mutate(\n    machine_id = floor((row_number() - 1) / 3),\n    across(c(x, y), parse_number),\n    .before = everything()\n  ) |&gt; \n  pivot_wider(names_from = button, values_from = c(x, y))",
    "crumbs": [
      "2024",
      "Day 13"
    ]
  },
  {
    "objectID": "2024/R/day13.html#part-1",
    "href": "2024/R/day13.html#part-1",
    "title": "Day 13",
    "section": "Part 1",
    "text": "Part 1\nDefine a function to convert numeric equation input and output token counts:\n\ncompute_tokens &lt;- function(df) {\n  \n  # Convert each machine's properties into a system of equations and solve.\n  soln &lt;- df |&gt; \n    nest(coeff = c(x_A, x_B, y_A, y_B)) |&gt; \n    nest(intercept = c(x_Prize, y_Prize)) |&gt; \n    mutate(\n      coeff = map(coeff, ~ matrix(as.numeric(.x), nrow = 2, byrow = TRUE)),\n      intercept = map(intercept, as.numeric),\n      soln = map2(\n        coeff, \n        intercept, \n        ~ solve(.x, .y) |&gt; \n          set_names(\"A\", \"B\") |&gt; \n          as_tibble_row()\n      )\n    ) |&gt; \n    unnest(soln) |&gt; \n    select(machine_id, A, B)\n  \n  \n  # Check that the solution is two whole numbers, then sum the token cost\n  soln |&gt; \n    mutate(\n      across(\n        c(A, B), \n        ~ near(.x, abs(round(.x)), tol = 0.001), \n        .names = \"{.col}_valid\"\n      ),\n      win = A_valid & B_valid,\n      tokens = if_else(win, 3 * A + B, 0)\n    ) |&gt; \n    pull(tokens) |&gt; \n    sum()\n}\n\nRun function on puzzle input:\n\ncompute_tokens(df)",
    "crumbs": [
      "2024",
      "Day 13"
    ]
  },
  {
    "objectID": "2024/R/day13.html#part-2",
    "href": "2024/R/day13.html#part-2",
    "title": "Day 13",
    "section": "Part 2",
    "text": "Part 2\nAdd 10000000000000 to each prize intercept and re-compute:\n\ndf |&gt; \n  mutate(across(c(x_Prize, y_Prize), ~ .x + 10000000000000)) |&gt; \n  compute_tokens()",
    "crumbs": [
      "2024",
      "Day 13"
    ]
  },
  {
    "objectID": "2024/R/day11.html",
    "href": "2024/R/day11.html",
    "title": "Day 11",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file into a numeric vector:\n\ninput &lt;- scan(\"../input/day11.txt\")",
    "crumbs": [
      "2024",
      "Day 11"
    ]
  },
  {
    "objectID": "2024/R/day11.html#setup",
    "href": "2024/R/day11.html#setup",
    "title": "Day 11",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file into a numeric vector:\n\ninput &lt;- scan(\"../input/day11.txt\")",
    "crumbs": [
      "2024",
      "Day 11"
    ]
  },
  {
    "objectID": "2024/R/day11.html#part-1",
    "href": "2024/R/day11.html#part-1",
    "title": "Day 11",
    "section": "Part 1",
    "text": "Part 1\nDefine a function for a single blink. If x is zero, it becomes 1. If x has an even number of digits, the value is split. If odd, it’s multiplied by 2024.\n\nblink &lt;- function(x) {\n  char &lt;- format(x, scientific = FALSE)\n  n &lt;- str_length(char)\n  \n  if (x == 0) \n    1\n  else if (n %% 2 == 0)\n    parse_number(c(str_sub(char, 1, n / 2), str_sub(char, n / 2 + 1, n)))\n  else \n    x * 2024\n}\n\nDefine a recursive function to blink n times. We don’t store each stone separately – instead, we store the current unique stones and their counts at every step:\n\nblink_n &lt;- function(df, n) {\n  if (n == 0)\n    return(sum(df$n))\n  \n  df |&gt; \n    mutate(stones = map(stones, blink)) |&gt; \n    unnest(stones) |&gt; \n    summarize(n = sum(n), .by = stones) |&gt; \n    blink_n(n - 1)\n}\n\nRun the blink function 25 times on the puzzle input, starting each stone with a count of 1:\n\nblink_n(tibble(stones = input, n = 1), 25)",
    "crumbs": [
      "2024",
      "Day 11"
    ]
  },
  {
    "objectID": "2024/R/day11.html#part-2",
    "href": "2024/R/day11.html#part-2",
    "title": "Day 11",
    "section": "Part 2",
    "text": "Part 2\nRun blink function 75 times on puzzle input:\n\nblink_n(tibble(stones = input, n = 1), 75)",
    "crumbs": [
      "2024",
      "Day 11"
    ]
  },
  {
    "objectID": "2024/R/day04.html",
    "href": "2024/R/day04.html",
    "title": "Day 4",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day04.txt\")\n\nConvert plain text lines into a character matrix:\n\nmtx &lt;- input |&gt; \n  map(~ matrix(str_split_1(.x, \"\"), nrow = 1)) |&gt; \n  do.call(what = rbind)",
    "crumbs": [
      "2024",
      "Day 4"
    ]
  },
  {
    "objectID": "2024/R/day04.html#setup",
    "href": "2024/R/day04.html#setup",
    "title": "Day 4",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day04.txt\")\n\nConvert plain text lines into a character matrix:\n\nmtx &lt;- input |&gt; \n  map(~ matrix(str_split_1(.x, \"\"), nrow = 1)) |&gt; \n  do.call(what = rbind)",
    "crumbs": [
      "2024",
      "Day 4"
    ]
  },
  {
    "objectID": "2024/R/day04.html#part-1",
    "href": "2024/R/day04.html#part-1",
    "title": "Day 4",
    "section": "Part 1",
    "text": "Part 1\nExtract rows and columns as separate text strings from the matrix:\n\nmtx_rows &lt;- apply(mtx, 1, str_flatten)\nmtx_cols &lt;- apply(mtx, 2, str_flatten)\n\nExtract diagonals from the matrix by padding each row with leading/trailing spaces, then extracting the new columns as strings:\n\npadding &lt;- str_dup(\" \", 1:nrow(mtx))\n\nmtx_diag &lt;- map(c(I, rev), \\(f) {\n  str_c(padding, f(mtx_rows), rev(padding)) |&gt; \n    str_split(\"\") |&gt; \n    list_transpose() |&gt; \n    map_chr(str_flatten) |&gt; \n    str_remove_all(\"\\\\s\")\n}) |&gt; \n  unlist()\n\nSearch for the string XMAS (or its reverse, SAMX) in each dimension of the matrix and count the total occurrences:\n\nmap(c(\"XMAS\", \"SAMX\"), ~ str_count(c(mtx_rows, mtx_cols, mtx_diag), .x)) |&gt; \n  unlist() |&gt;\n  sum()",
    "crumbs": [
      "2024",
      "Day 4"
    ]
  },
  {
    "objectID": "2024/R/day04.html#part-2",
    "href": "2024/R/day04.html#part-2",
    "title": "Day 4",
    "section": "Part 2",
    "text": "Part 2\nDefine the four possible XMAS patterns in a 3x3 grid as a regex string:\n\nxmas1 &lt;- \"M.S.A.M.S\"\nxmas4 &lt;- \"S.M.A.S.M\"\nxmas2 &lt;- \"S.S.A.M.M\"\nxmas3 &lt;- \"M.M.A.S.S\"\nxmas_regex &lt;- str_glue(\"{xmas1}|{xmas2}|{xmas3}|{xmas4}\")\n\nExtract every 3x3 submatrix in the input text block as a text string (concatenating row-wise):\n\nsub_mtx &lt;- expand_grid(row = 3:nrow(mtx), col = 3:ncol(mtx)) |&gt; \n  pmap(\\(row, col) mtx[row - 0:2, col - 0:2]) |&gt; \n  map_chr(str_flatten)\n\nCount all text strings with a valid XMAS pattern:\n\nsum(str_detect(sub_mtx, xmas_regex))",
    "crumbs": [
      "2024",
      "Day 4"
    ]
  },
  {
    "objectID": "2025/R/day08.html",
    "href": "2025/R/day08.html",
    "title": "Day 8",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day08.txt\") |&gt; \n  str_split(\",\") |&gt; \n  map(as.numeric)",
    "crumbs": [
      "2025",
      "Day 8"
    ]
  },
  {
    "objectID": "2025/R/day08.html#setup",
    "href": "2025/R/day08.html#setup",
    "title": "Day 8",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day08.txt\") |&gt; \n  str_split(\",\") |&gt; \n  map(as.numeric)",
    "crumbs": [
      "2025",
      "Day 8"
    ]
  },
  {
    "objectID": "2025/R/day08.html#part-1",
    "href": "2025/R/day08.html#part-1",
    "title": "Day 8",
    "section": "Part 1",
    "text": "Part 1\nDefine a helper function to compute the euclidian distance between two vectors:\n\ndist &lt;- \\(x, y) sqrt(sum(map2_dbl(x, y, ~ (.x - .y)^2)))\n\nConstruct all unique combinations of junction boxes, then compute the distance between each:\n\ncombos &lt;- combn(1:length(input), 2, simplify = FALSE) |&gt; \n  as_tibble_col(\"box\") |&gt; \n  unnest_wider(box, names_sep = \"\") |&gt; \n  mutate(\n    across(c(box1, box2), ~ input[.x], .names = \"{.col}_coord\"),\n    d = map2_dbl(box1_coord, box2_coord, dist)\n  ) |&gt; \n  arrange(d)\n\nAssign each box to its own circut, iterate through the first 1000 box pairs:\n\ncircuts &lt;- 1:length(input)\n\nfor (i in 1:1000) {\n  circut1 &lt;- circuts[combos$box1[i]]\n  circut2 &lt;- circuts[combos$box2[i]]\n  if (circut1 != circut2) {\n    circuts &lt;- replace(circuts, circuts == circut1, circut2)\n  }\n}\n\nMultiply together the sizes of the 3 largest circuts:\n\ncircuts |&gt; \n  sort() |&gt; \n  rle() |&gt; \n  pluck(\"lengths\") |&gt; \n  sort(decreasing = TRUE) |&gt; \n  head(3) |&gt; \n  prod()",
    "crumbs": [
      "2025",
      "Day 8"
    ]
  },
  {
    "objectID": "2025/R/day08.html#part-2",
    "href": "2025/R/day08.html#part-2",
    "title": "Day 8",
    "section": "Part 2",
    "text": "Part 2\nIteravely make connections until all boxes are on a single circut:\n\ncircuts &lt;- 1:length(input)\ni &lt;- 0\n\nwhile(length(unique(circuts)) &gt; 1) {\n  i &lt;- i + 1\n  circut1 &lt;- circuts[combos$box1[i]]\n  circut2 &lt;- circuts[combos$box2[i]]\n  if (circut1 != circut2) {\n    circuts &lt;- replace(circuts, circuts == circut1, circut2)\n  }\n}\n\nMultiply the x coordinates of the last two boxes connected:\n\ncombos$box1_coord[[i]][1] * combos$box2_coord[[i]][1]",
    "crumbs": [
      "2025",
      "Day 8"
    ]
  },
  {
    "objectID": "2025/R/day03.html",
    "href": "2025/R/day03.html",
    "title": "Day 3",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nDisable scientific notation to display all digits of large numbers:\n\noptions(scipen = 999)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day03.txt\") |&gt; \n  str_split(\"\") |&gt; \n  map(as.numeric)",
    "crumbs": [
      "2025",
      "Day 3"
    ]
  },
  {
    "objectID": "2025/R/day03.html#setup",
    "href": "2025/R/day03.html#setup",
    "title": "Day 3",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nDisable scientific notation to display all digits of large numbers:\n\noptions(scipen = 999)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day03.txt\") |&gt; \n  str_split(\"\") |&gt; \n  map(as.numeric)",
    "crumbs": [
      "2025",
      "Day 3"
    ]
  },
  {
    "objectID": "2025/R/day03.html#part-1",
    "href": "2025/R/day03.html#part-1",
    "title": "Day 3",
    "section": "Part 1",
    "text": "Part 1\nFor each number, take the largest possible single digit NOT in the final location, and combine it with the largest following digit:\n\ninput |&gt; \n  map_dbl(\\(x) {\n    tens &lt;- which.max(head(x, -1))\n    ones &lt;- max(tail(x, -tens))\n    x[tens] * 10 + ones\n  }) |&gt; \n  sum()",
    "crumbs": [
      "2025",
      "Day 3"
    ]
  },
  {
    "objectID": "2025/R/day03.html#part-2",
    "href": "2025/R/day03.html#part-2",
    "title": "Day 3",
    "section": "Part 2",
    "text": "Part 2\nDefine a recursive function which looks for the first through nth digits:\n\njoltage &lt;- function(input, n, init = \"\") {\n  \n  if (n == 0)\n    return(as.numeric(init))\n  \n  posn &lt;- input |&gt; \n    discard_at(length(input) - seq_len(n - 1) + 1) |&gt; \n    which.max()\n  \n  joltage(discard_at(input, 1:posn), n - 1, str_c(init, input[posn]))\n  \n}\n\nRun on puzzle input with 12 digits and sum the result:\n\ninput |&gt; \n  map_dbl(\\(x) joltage(x, 12)) |&gt; \n  sum()",
    "crumbs": [
      "2025",
      "Day 3"
    ]
  },
  {
    "objectID": "2025/R/day06.html",
    "href": "2025/R/day06.html",
    "title": "Day 6",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nDisable scientific notation to display all digits of large numbers:\n\noptions(scipen = 999)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day06.txt\")\n\nParse plain text input into a square data frame, having once cell per row per column (preserving whitespace):\n\ndf &lt;- str_pad(input, width = max(str_length(input)), side = \"right\") |&gt; \n  str_split(\"\") |&gt; \n  set_names(c(str_c(\"row\", seq(length(input) - 1)), \"op\")) |&gt; \n  as_tibble() |&gt; \n  mutate(\n    all_blank = rowSums(across(starts_with(\"row\"), \\(x) x != \" \")) == 0,\n    col_id = cumsum(all_blank),\n    op = case_match(op, \"+\" ~ \"sum\", \"*\" ~ \"prod\", .default = op)\n  ) |&gt; \n  filter(!all_blank) |&gt; \n  select(-all_blank)",
    "crumbs": [
      "2025",
      "Day 6"
    ]
  },
  {
    "objectID": "2025/R/day06.html#setup",
    "href": "2025/R/day06.html#setup",
    "title": "Day 6",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nDisable scientific notation to display all digits of large numbers:\n\noptions(scipen = 999)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day06.txt\")\n\nParse plain text input into a square data frame, having once cell per row per column (preserving whitespace):\n\ndf &lt;- str_pad(input, width = max(str_length(input)), side = \"right\") |&gt; \n  str_split(\"\") |&gt; \n  set_names(c(str_c(\"row\", seq(length(input) - 1)), \"op\")) |&gt; \n  as_tibble() |&gt; \n  mutate(\n    all_blank = rowSums(across(starts_with(\"row\"), \\(x) x != \" \")) == 0,\n    col_id = cumsum(all_blank),\n    op = case_match(op, \"+\" ~ \"sum\", \"*\" ~ \"prod\", .default = op)\n  ) |&gt; \n  filter(!all_blank) |&gt; \n  select(-all_blank)",
    "crumbs": [
      "2025",
      "Day 6"
    ]
  },
  {
    "objectID": "2025/R/day06.html#part-1",
    "href": "2025/R/day06.html#part-1",
    "title": "Day 6",
    "section": "Part 1",
    "text": "Part 1\nRe-combine digits row-wise into sets of numbers, apply the operation to the result, and sum:\n\ndf |&gt; \n  summarize(\n    across(starts_with(\"row\"), \\(x) parse_number(str_flatten(x))),\n    op = max(op),\n    .by = col_id\n  ) |&gt; \n  nest(nums = starts_with(\"row\")) |&gt; \n  mutate(nums = map2_dbl(op, nums, \\(op, nums) get(op)(unlist(nums)))) |&gt; \n  with(sum(nums))",
    "crumbs": [
      "2025",
      "Day 6"
    ]
  },
  {
    "objectID": "2025/R/day06.html#part-2",
    "href": "2025/R/day06.html#part-2",
    "title": "Day 6",
    "section": "Part 2",
    "text": "Part 2\nFirst combine all numbers column-wise instead of row-wise, then repeat the process from part 1:\n\ndf |&gt; \n  arrange(desc(row_number())) |&gt; \n  mutate(num_id = row_number()) |&gt; \n  nest(num = starts_with(\"row\")) |&gt; \n  mutate(num = map_dbl(num, \\(x) parse_number(str_flatten(unlist(x))))) |&gt; \n  summarize(num = get(max(op))(num), .by = col_id) |&gt; \n  with(sum(num))",
    "crumbs": [
      "2025",
      "Day 6"
    ]
  },
  {
    "objectID": "2025/R/day05.html",
    "href": "2025/R/day05.html",
    "title": "Day 5",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sets)\n\nDisable scientific notation to display all digits of large numbers:\n\noptions(scipen = 999)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day05.txt\", skip_empty_rows = TRUE)\n\nSeparate text input into (1) ranges of “fresh” IDs, and (2) a single vector of “available” IDs:\n\nfresh &lt;- input |&gt;\n  unglue_data(\"{start}-{end}\", convert = TRUE) |&gt; \n  drop_na()\n\navailable &lt;- input |&gt;\n  keep(\\(x) str_detect(x, \"^\\\\d+$\")) |&gt; \n  as.numeric()",
    "crumbs": [
      "2025",
      "Day 5"
    ]
  },
  {
    "objectID": "2025/R/day05.html#setup",
    "href": "2025/R/day05.html#setup",
    "title": "Day 5",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sets)\n\nDisable scientific notation to display all digits of large numbers:\n\noptions(scipen = 999)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day05.txt\", skip_empty_rows = TRUE)\n\nSeparate text input into (1) ranges of “fresh” IDs, and (2) a single vector of “available” IDs:\n\nfresh &lt;- input |&gt;\n  unglue_data(\"{start}-{end}\", convert = TRUE) |&gt; \n  drop_na()\n\navailable &lt;- input |&gt;\n  keep(\\(x) str_detect(x, \"^\\\\d+$\")) |&gt; \n  as.numeric()",
    "crumbs": [
      "2025",
      "Day 5"
    ]
  },
  {
    "objectID": "2025/R/day05.html#part-1",
    "href": "2025/R/day05.html#part-1",
    "title": "Day 5",
    "section": "Part 1",
    "text": "Part 1\nCount how many of the “available” IDs are in any “fresh” ID range:\n\navailable |&gt; \n  enframe() |&gt; \n  cross_join(fresh) |&gt; \n  filter(between(value, start, end)) |&gt; \n  distinct(value) |&gt; \n  nrow()",
    "crumbs": [
      "2025",
      "Day 5"
    ]
  },
  {
    "objectID": "2025/R/day05.html#part-2",
    "href": "2025/R/day05.html#part-2",
    "title": "Day 5",
    "section": "Part 2",
    "text": "Part 2\nConvert each pair of start/end “fresh” IDs into intervals, take their union, and count the size of the result:\n\nfresh |&gt; \n  with(map2(start, end, \\(a, b) interval(a, b, bounds = \"closed\"))) |&gt; \n  reduce(interval_union) |&gt; \n  as.list() |&gt; \n  map_dbl(\\(x) interval_measure(x) + 1) |&gt; \n  sum()",
    "crumbs": [
      "2025",
      "Day 5"
    ]
  },
  {
    "objectID": "2022/R/day09.html",
    "href": "2022/R/day09.html",
    "title": "Day 9",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(ctmle, include.only = \"bound\")\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day09.txt\") |&gt;\n  str_split(\" \")",
    "crumbs": [
      "2022",
      "Day 9"
    ]
  },
  {
    "objectID": "2022/R/day09.html#setup",
    "href": "2022/R/day09.html#setup",
    "title": "Day 9",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(ctmle, include.only = \"bound\")\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day09.txt\") |&gt;\n  str_split(\" \")",
    "crumbs": [
      "2022",
      "Day 9"
    ]
  },
  {
    "objectID": "2022/R/day09.html#part-1",
    "href": "2022/R/day09.html#part-1",
    "title": "Day 9",
    "section": "Part 1",
    "text": "Part 1\n\n# Convert head movements to sequence of locations on complex plane\nhead_path &lt;- input |&gt;\n  map(~ rep(.x[[1]], .x[[2]])) |&gt;\n  reduce(c) |&gt;\n  recode(\"R\" = 1 + 0i, \"L\" = -1 + 0i, \"U\" = 0 + 1i, \"D\" = 0 - 1i) |&gt;\n  accumulate(.init = 0 + 0i, .f = sum)\n\n# Find path of next knot given path of previous knot.\nmove_next_knot &lt;- function(prev_knot_path) {\n  accumulate(\n    .x = prev_knot_path,\n    .f = function(tail = .x, head = .y) {\n      diff &lt;- head - tail\n      if_else(\n        max(abs(Re(diff)), abs(Im(diff))) &lt;= 1,\n        tail,\n        tail + bound(Re(diff), c(-1, 1)) + bound(Im(diff), c(-1, 1)) * 1i\n      )\n    }\n  )\n}\n\n\nunique_tail_spots &lt;- function(path, num_knots) {\n  # Iteratively compute path of each knot from head & to tail\n  move_tail &lt;- reduce(map(1:(num_knots - 1), ~ move_next_knot), compose)\n\n  # Find number of unique locations in the tail's path\n  length(unique(move_tail(path)))\n}\n\n\nunique_tail_spots(head_path, num_knots = 2)",
    "crumbs": [
      "2022",
      "Day 9"
    ]
  },
  {
    "objectID": "2022/R/day09.html#part-2",
    "href": "2022/R/day09.html#part-2",
    "title": "Day 9",
    "section": "Part 2",
    "text": "Part 2\n\nunique_tail_spots(head_path, num_knots = 10)",
    "crumbs": [
      "2022",
      "Day 9"
    ]
  },
  {
    "objectID": "2022/R/day20.html",
    "href": "2022/R/day20.html",
    "title": "Day 20",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day20.txt\", skip_empty_rows = TRUE) |&gt; \n  as.numeric()",
    "crumbs": [
      "2022",
      "Day 20"
    ]
  },
  {
    "objectID": "2022/R/day20.html#setup",
    "href": "2022/R/day20.html#setup",
    "title": "Day 20",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day20.txt\", skip_empty_rows = TRUE) |&gt; \n  as.numeric()",
    "crumbs": [
      "2022",
      "Day 20"
    ]
  },
  {
    "objectID": "2022/R/day20.html#part-1",
    "href": "2022/R/day20.html#part-1",
    "title": "Day 20",
    "section": "Part 1",
    "text": "Part 1\n\n# Shift the value at the given index by n steps\nshift_value &lt;- function(vec, idx_old, n) {\n  idx_new &lt;- (idx_old + n - 2) %% (length(vec) - 1) + 1\n  value &lt;- vec[idx_old]\n  \n  vec |&gt; \n    discard_at(idx_old) |&gt; \n    append(value, after = idx_new)\n}\n\n# Mix the given list of integers in order by shifting values one-by-one \nmix &lt;- function(file, n = 1) {\n  ids &lt;- 1:length(file)\n  \n  for (rep in 1:n) {\n    for (i in 1:length(file)) {\n      ids &lt;- shift_value(ids, which(ids == i), file[i])\n    }\n  }\n  \n  file[ids]\n}\n\n# Sum the grove coordinates in a given vector\ngrove_coords &lt;- function(vec) {\n  c(1000, 2000, 3000) |&gt; \n    map_dbl(~ vec[(which(vec == 0) + .x) %% length(vec)]) |&gt; \n    sum()\n}\n\nRun on puzzle input:\n\ninput |&gt; \n  mix() |&gt; \n  grove_coords()",
    "crumbs": [
      "2022",
      "Day 20"
    ]
  },
  {
    "objectID": "2022/R/day20.html#part-2",
    "href": "2022/R/day20.html#part-2",
    "title": "Day 20",
    "section": "Part 2",
    "text": "Part 2\nApply decryption key and mix 10 times:\n\n(input * 811589153) |&gt; \n  mix(n = 10) |&gt; \n  grove_coords()",
    "crumbs": [
      "2022",
      "Day 20"
    ]
  },
  {
    "objectID": "2022/R/day22.html",
    "href": "2022/R/day22.html",
    "title": "Day 22",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day22.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 22"
    ]
  },
  {
    "objectID": "2022/R/day22.html#setup",
    "href": "2022/R/day22.html#setup",
    "title": "Day 22",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day22.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 22"
    ]
  },
  {
    "objectID": "2022/R/day22.html#part-1",
    "href": "2022/R/day22.html#part-1",
    "title": "Day 22",
    "section": "Part 1",
    "text": "Part 1\nConvert input to a grid board and a series of steps in the path:\n\nboard &lt;- input |&gt; \n  head(-1) |&gt; \n  enframe(name = \"row\") |&gt; \n  mutate(value = str_split(value, \"\")) |&gt; \n  unnest(value) |&gt; \n  mutate(col = row_number(), .by = row, .after = row) |&gt; \n  filter(value %in% c(\".\", \"#\")) |&gt; \n  mutate(id = row_number(), .before = everything())\n\npath &lt;- input |&gt;\n  tail(1) |&gt; \n  str_split_1(\"(?&lt;=.)(?=[LR])\") |&gt; \n  as_tibble_col(column_name = \"input\") |&gt; \n  mutate(\n    turn = case_match(str_extract(input, \"L|R\"), \n      \"R\" ~ 1, \n      \"L\" ~ -1, \n      .default = 0\n    ),\n    walk = parse_number(input),\n  )\n\nCreate a set of 2D lists by direction:\n\nvecs &lt;- map(\n  c(row = \"row\", col = \"col\"),\n  ~ board |&gt; \n    select({{ .x }}, id, value) |&gt; \n    arrange(.data[[.x]]) |&gt; \n    nest(vec = c(id, value)) |&gt; \n    mutate(vec = map(vec, deframe)) |&gt; \n    select(vec) |&gt; \n    deframe()\n)\n\n\nwrap_head &lt;- \\(x, n) c(tail(x,  n), head(x, -n))\nwrap_tail &lt;- \\(x, n) c(tail(x, -n), head(x,  n))\n\ndirs_2d &lt;- c(\"row_pos\", \"col_pos\", \"row_neg\", \"col_neg\")\n\nnext_dir &lt;- function(dir_vec, prv_dir, turn) {\n  dir_vec[((which(dir_vec == prv_dir) + turn - 1) %% length(dir_vec)) + 1]\n}\n\nwalk_n &lt;- function(id_start, dir_start, n) {\n  dir_vec  &lt;- str_extract(dir_start, \"row|col\")\n  dir_sign &lt;- case_match(str_extract(dir_start, \"pos|neg\"), \n    \"pos\" ~ 1, \n    \"neg\" ~ -1\n  )\n  \n  vec_idx &lt;- board |&gt; \n    filter(id == id_start) |&gt; \n    pull({{ dir_vec }})\n  \n  x   &lt;- vecs[[dir_vec]][[vec_idx]]\n  idx &lt;- which(names(x) == id_start)\n  \n  for (i in 1:n) {\n    idx_next &lt;- (idx + dir_sign - 1) %% length(x) + 1\n    \n    if (x[idx_next] == \"#\")\n      break\n    else\n      idx &lt;- idx_next\n  }\n  \n  as.numeric(names(x)[idx])\n}\n\ncompute_pwd &lt;- function(cell_id, dir_num) {\n  final &lt;- filter(board, id == cell_id)\n  1000 * final$row + 4 * final$col + unname(dir_num)\n}\n\ninit_cell &lt;- board |&gt; \n  filter(value == \".\") |&gt; \n  pull(id) |&gt; \n  min()\n\nRun on puzzle input:\n\ncell &lt;- init_cell\ndir  &lt;- \"row_pos\"\n  \nfor (i in 1:nrow(path)) {\n  prv_dir  &lt;- dir\n  prv_cell &lt;- cell\n  \n  dir  &lt;- next_dir(dirs_2d, prv_dir, path$turn[i])\n  cell &lt;- walk_n(cell, dir, path$walk[i])\n}\n\ncompute_pwd(cell, which(dirs_2d == dir) - 1)",
    "crumbs": [
      "2022",
      "Day 22"
    ]
  },
  {
    "objectID": "2022/R/day22.html#part-2",
    "href": "2022/R/day22.html#part-2",
    "title": "Day 22",
    "section": "Part 2",
    "text": "Part 2\nConvert from row/col vectors to roll/pitch/yaw vectors:\n\nbox_dim &lt;- 50\n\nvecs[[\"roll\"]] &lt;- pmap(\n  list(\n    vecs$row[1:box_dim],\n    vecs$row[1:box_dim + box_dim * 2] |&gt; \n      rev() |&gt; \n      map(rev)\n  ),\n  ~ c(..1, ..2)\n)\n\nvecs[[\"pitch\"]] &lt;- pmap(\n  list(\n    vecs$col[1:box_dim + box_dim],\n    vecs$row[1:box_dim + box_dim * 3] |&gt; \n      map(rev)\n  ),\n  ~ c(..1, ..2)\n)\n\nvecs[[\"yaw\"]] &lt;- pmap(\n  list(\n    vecs$row[1:box_dim + box_dim],\n    vecs$col[1:box_dim + box_dim * 2] |&gt; \n      map(rev),\n    vecs$col[1:box_dim] |&gt; \n      map(rev)\n  ),\n  ~ c(..1, ..2, ..3)\n)\n\ncoords_3d &lt;- map(\n  c(roll = \"roll\", pitch = \"pitch\", yaw = \"yaw\"),\n  ~ vecs[[.x]] |&gt; \n    map(~ as.numeric(names(.x))) |&gt; \n    enframe(name = .x, value = \"id\") |&gt; \n    unnest(id) |&gt; \n    relocate(id)\n) |&gt; \n  reduce(partial(full_join, by = join_by(id)))\n\nCreate a new set of instructions for making left/right turns that depend on which box face is currently occupied:\n\ndirs_3d &lt;- list(\n  f1 = c(\"roll_pos\",  \"pitch_pos\", \"roll_neg\",  \"pitch_neg\"),\n  f2 = c(\"roll_pos\",  \"yaw_neg\",   \"roll_neg\",  \"yaw_pos\"),\n  f3 = c(\"yaw_pos\",   \"pitch_pos\", \"yaw_neg\",   \"pitch_neg\"),\n  f4 = c(\"roll_neg\",  \"yaw_neg\",   \"roll_pos\",  \"yaw_pos\"),\n  f5 = c(\"roll_neg\",  \"pitch_pos\", \"roll_pos\",  \"pitch_neg\"),\n  f6 = c(\"pitch_neg\", \"yaw_neg\",   \"pitch_pos\", \"yaw_pos\")\n) |&gt; \n  map(partial(set_names, nm = c(\"row_pos\", \"col_pos\", \"row_neg\", \"col_neg\")))\n\nfaces &lt;- board |&gt; \n  mutate(\n    face_row = ceiling(row / box_dim), \n    face_col = ceiling(col / box_dim)\n  ) |&gt;\n  arrange(id) |&gt; \n  mutate(\n    box_face = cur_group_id(),\n    .by = c(face_row, face_col)\n  ) |&gt; \n  select(id, box_face)\n\nboard_3d &lt;- board |&gt; \n  left_join(coords_3d, join_by(id)) |&gt; \n  left_join(faces, join_by(id))\n\nRedefine the walk function to take roll/pitch/yaw directions:\n\nwalk_n &lt;- function(id_start, dir_start, n) {\n  dir_vec  &lt;- str_extract(dir_start, \"roll|pitch|yaw\")\n  dir_sign &lt;- case_match(str_extract(dir_start, \"pos|neg\"), \n    \"pos\" ~ 1, \n    \"neg\" ~ -1\n  )\n  \n  vec_idx &lt;- board_3d |&gt; \n    filter(id == id_start) |&gt; \n    pull({{ dir_vec }})\n  \n  x   &lt;- vecs[[dir_vec]][[vec_idx]]\n  idx &lt;- which(names(x) == id_start)\n  \n  for (i in 1:n) {\n    idx_next &lt;- (idx + dir_sign - 1) %% length(x) + 1\n    \n    if (x[idx_next] == \"#\")\n      break\n    else\n      idx &lt;- idx_next\n  }\n  \n  as.numeric(names(x)[idx])\n}\n\nRe-run the puzzle input:\n\ncell &lt;- init_cell\ndir  &lt;- \"roll_pos\"\ndir_vec &lt;- dirs_3d$f1\n  \nfor (i in 1:nrow(path)) {\n  prv_dir  &lt;- dir\n  prv_cell &lt;- cell\n  \n  dir_vec &lt;- dirs_3d[[board_3d$box_face[[prv_cell]]]]\n  \n  dir  &lt;- next_dir(dir_vec, prv_dir, path$turn[i])\n  cell &lt;- walk_n(cell, dir, path$walk[i])\n}\n\ncompute_pwd(cell, which(dir_vec == dir) - 1)",
    "crumbs": [
      "2022",
      "Day 22"
    ]
  },
  {
    "objectID": "2022/R/day24.html",
    "href": "2022/R/day24.html",
    "title": "Day 24",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day24.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 24"
    ]
  },
  {
    "objectID": "2022/R/day24.html#setup",
    "href": "2022/R/day24.html#setup",
    "title": "Day 24",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day24.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 24"
    ]
  },
  {
    "objectID": "2022/R/day24.html#part-1",
    "href": "2022/R/day24.html#part-1",
    "title": "Day 24",
    "section": "Part 1",
    "text": "Part 1\nConvert input string to a matrix of characters:\n\nw &lt;- str_length(input[[1]])\nh &lt;- length(input)\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  unlist() |&gt; \n  matrix(nrow = h, byrow = TRUE)\n\nDefine helper functions to determine whether a map space is occupied at a given time. Hint from reddit user u/jaccomoc to scan rows/columns for blizzards at a certain time, rather than simulating the entire map at every time point:\n\n# Define the constant start/end locations\ninit   &lt;- c(row = 1, col = 2)\ntarget &lt;- c(row = h, col = w - 1)\n\n# Wrap blizzards aroound the map edges\nwrap_w &lt;- function(idx) (idx - 2) %% (w - 2) + 2\nwrap_h &lt;- function(idx) (idx - 2) %% (h - 2) + 2\n\n# Check whether a given cell is open at a given time\nis_open &lt;- function(idx, time) {\n  row &lt;- idx[[1]]\n  col &lt;- idx[[2]]\n  mtx[row, wrap_w(col - time)] != '&gt;' & mtx[wrap_h(row - time), col] != 'v' &\n  mtx[row, wrap_w(col + time)] != '&lt;' & mtx[wrap_h(row + time), col] != '^'\n}\n\n# Check whether a given cell is in the bounds of the map\nin_bounds &lt;- function(idx) {\n  row &lt;- idx[[1]]\n  col &lt;- idx[[2]]\n  \n  (between(row, 2, h - 1) & between(col, 2, w - 1)) | \n  all(idx == init) | all(idx == target)\n}\n\nDefine a function that loops through time points and stops when the first elf reaches the target. Hint on use of “quantum elves” that die if standing on a blizzard spot from Reddit user u/SLiV9.\n\nmoves &lt;- list(\n  c(row =  1, col =  0),  # down\n  c(row =  0, col =  1),  # right\n  c(row = -1, col =  0),  # up\n  c(row =  0, col = -1),  # left\n  c(row =  0, col =  0)   # still\n)\n\ntime_cross &lt;- function(time_start, init, target) {\n  \n  cur_locations &lt;- list(init)\n  t &lt;- time_start\n  \n  repeat {\n    t &lt;- t + 1\n\n    cur_locations &lt;- cur_locations |&gt; \n      map(\\(start) map(moves, \\(move) start + move)) |&gt; \n      flatten() |&gt; \n      keep(in_bounds) |&gt; \n      keep(partial(is_open, time = t)) |&gt; \n      unique()\n    \n    if (list(target) %in% cur_locations) break\n  }\n  \n  t\n}\n\nRun on puzzle input:\n\nt1 &lt;- time_cross(0, init, target)\n\nt1",
    "crumbs": [
      "2022",
      "Day 24"
    ]
  },
  {
    "objectID": "2022/R/day24.html#part-2",
    "href": "2022/R/day24.html#part-2",
    "title": "Day 24",
    "section": "Part 2",
    "text": "Part 2\nRun the simulation again two more times, swapping the target and source locations, and starting where the last left off.\n\nt2 &lt;- time_cross(t1, target, init)\nt3 &lt;- time_cross(t2, init, target)\n\nt3",
    "crumbs": [
      "2022",
      "Day 24"
    ]
  },
  {
    "objectID": "2022/R/day19.html",
    "href": "2022/R/day19.html",
    "title": "Day 19",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day19.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 19"
    ]
  },
  {
    "objectID": "2022/R/day19.html#setup",
    "href": "2022/R/day19.html#setup",
    "title": "Day 19",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day19.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 19"
    ]
  },
  {
    "objectID": "2022/R/day19.html#part-1",
    "href": "2022/R/day19.html#part-1",
    "title": "Day 19",
    "section": "Part 1",
    "text": "Part 1\nReformat the input as lists of robots with inputs and outputs for each blueprint:\n\nore      &lt;- c(\"ore\" = 1, \"clay\" = 0, \"obsidian\" = 0, \"geode\" = 0)\nclay     &lt;- c(\"ore\" = 0, \"clay\" = 1, \"obsidian\" = 0, \"geode\" = 0)\nobsidian &lt;- c(\"ore\" = 0, \"clay\" = 0, \"obsidian\" = 1, \"geode\" = 0)\ngeode    &lt;- c(\"ore\" = 0, \"clay\" = 0, \"obsidian\" = 0, \"geode\" = 1)\nempty    &lt;- c(\"ore\" = 0, \"clay\" = 0, \"obsidian\" = 0, \"geode\" = 0)\n\nunglue_pattern &lt;- str_c(\n  \"Blueprint {blueprint}:\",\n  \"Each ore robot costs {ore_ore} ore.\",\n  \"Each clay robot costs {clay_ore} ore.\",\n  \"Each obsidian robot costs {obsidian_ore} ore and {obsidian_clay} clay.\",\n  \"Each geode robot costs {geode_ore} ore and {geode_obsidian} obsidian.\",\n  sep = \" \"\n)\n\nblueprints &lt;- input |&gt; \n  unglue::unglue_data(unglue_pattern, convert = TRUE) |&gt; \n  pivot_longer(\n    -blueprint, \n    names_to = c(\"robot\", \"cost_type\"), \n    values_to = \"cost_value\",\n    names_sep = \"_\"\n  ) |&gt; \n  pivot_wider(names_from = cost_type, values_from = cost_value, values_fill = 0) |&gt; \n  mutate(geode = 0) |&gt; \n  nest(cost = c(ore, clay, obsidian, geode)) |&gt; \n  mutate(\n    cost = map(cost, unlist),\n    output = map(robot, get)\n  ) |&gt; \n  group_split(blueprint)\n\nDefine a set of functions to find the maximum number of geodes for each blueprint.\nOptimizations to improve runtime were sourced from Reddit (1, 2).\n\nmax_geodes &lt;- function(blueprint, inventory, production, time_left, max_cost, cur_best = 0) {\n  \n  # If the best possible set of geode robots in this branch can't outdo the current\n  # best, then don't traverse this branch.\n  theoretical_best &lt;- inventory[\"geode\"] + \n    production[\"geode\"] * time_left +\n    sum(1:time_left - 1)\n  \n  if (time_left == 0 | theoretical_best &lt;= cur_best)\n    return(inventory[\"geode\"])\n    \n  # Determine the amount of time required to build each robot next\n  time_to_build &lt;- map_dbl(blueprint$cost, \n    ~ ceiling((.x - inventory) / production) |&gt; \n      keep(.x &gt; 0) |&gt; \n      map_dbl(~ max(.x, 0) + 1) |&gt; \n      max()\n  )\n  \n  # Determine which robots are buildable within the remaining time\n  idx &lt;- which(\n    is.finite(time_to_build) & \n      time_to_build &lt; time_left & \n      production &lt; max_cost\n  )\n  \n  # Quit if there are no remaining options\n  if (length(idx) == 0)\n    return((inventory + time_left * production)[\"geode\"])\n  \n  # Loop through each branch of options\n  for (i in rev(idx)) {\n    branch_best &lt;- max_geodes(\n        blueprint  = blueprint,\n        inventory  = inventory + \n          production * time_to_build[[i]] - \n          blueprint$cost[[i]],\n        production = production + blueprint$output[[i]],\n        time_left  = time_left - time_to_build[[i]],\n        max_cost   = max_cost,\n        cur_best   = cur_best\n      )\n    if (branch_best &gt; cur_best)\n      cur_best &lt;- branch_best\n  }\n  \n  return(cur_best)\n}\n\nblueprint_geodes &lt;- function(blueprints, total_time) {\n  \n  best &lt;- c()\n  \n  for (blueprint in blueprints) {\n    max_cost &lt;- blueprint |&gt; \n      pull(cost) |&gt; \n      do.call(what = pmax) |&gt; \n      modify_at(.at = \"geode\", ~ Inf)\n    best &lt;- c(\n      best,\n      max_geodes(\n        blueprint  = blueprint,\n        inventory  = empty,\n        production = ore,\n        time_left  = total_time, \n        max_cost   = max_cost,\n        cur_best   = 0\n      )\n    )\n  }\n  \n  unname(best)\n}\n\nCompute total quality score by multiplying the max geodes for each blueprint by its index:\n\nblueprint_geodes(blueprints, total_time = 24) |&gt; \n  imap_dbl(\\(geodes, i) i * geodes) |&gt; \n  sum()",
    "crumbs": [
      "2022",
      "Day 19"
    ]
  },
  {
    "objectID": "2022/R/day19.html#part-2",
    "href": "2022/R/day19.html#part-2",
    "title": "Day 19",
    "section": "Part 2",
    "text": "Part 2\nFilter to the first 3 blueprints, increase the total time to 32 seconds, and take the product of the max geodes:\n\nblueprints |&gt; \n  keep_at(1:3) |&gt; \n  blueprint_geodes(total_time = 32) |&gt; \n  prod()",
    "crumbs": [
      "2022",
      "Day 19"
    ]
  },
  {
    "objectID": "2022/R/day14.html",
    "href": "2022/R/day14.html",
    "title": "Day 14",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from text\ninput &lt;- read_lines(\"../input/day14.txt\")",
    "crumbs": [
      "2022",
      "Day 14"
    ]
  },
  {
    "objectID": "2022/R/day14.html#setup",
    "href": "2022/R/day14.html#setup",
    "title": "Day 14",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from text\ninput &lt;- read_lines(\"../input/day14.txt\")",
    "crumbs": [
      "2022",
      "Day 14"
    ]
  },
  {
    "objectID": "2022/R/day14.html#part-1",
    "href": "2022/R/day14.html#part-1",
    "title": "Day 14",
    "section": "Part 1",
    "text": "Part 1\nConvert input from rows of text lines to a list of obstacle coordinates:\n\n# Extract numeric values from the input text\ndf &lt;- input |&gt; \n  str_split(\" -&gt; \") |&gt; \n  imap_dfr(\\(input, idx) tibble(idx, input)) |&gt; \n  unglue_unnest(input, \"{x},{y}\", convert = TRUE)\n\n\n# Expand the endpoints into a list of coordinates of every obstacle\nobstacles &lt;- df |&gt; \n  mutate(\n    seq_x = map2(x, lead(x), ~ if (!is.na(.x) & !is.na(.y)) .x:.y),\n    seq_y = map2(y, lead(y), ~ if (!is.na(.x) & !is.na(.y)) .x:.y),\n    .by = idx\n  ) |&gt; \n  unnest(c(seq_x, seq_y)) |&gt; \n  distinct(x = seq_x, y = seq_y) |&gt; \n  mutate(chr = '#')\n\nDefine a function to recursively drop a grain of sand until it comes to rest:\n\ndrop_grain &lt;- function(scan, x_cur, y_cur) {\n  y_new &lt;- y_cur + 1\n  \n  # Check if new y-coordinate is out of bounds\n  if (y_new &gt; max(scan$y))\n    return(scan)\n  \n  for (x_new in c(x_cur, x_cur - 1, x_cur + 1)) {\n    # Check if next x-coordinate is out of bounds\n    if (!between(x_new, min(scan$x), max(scan$x)))\n      return(scan)\n    # If grain can flow into the next spot, recurse into next spot\n    else if (nrow(filter(scan, x == x_new, y == y_new)) == 0)\n      return(drop_grain(scan, x_new, y_new))\n  }\n\n  # If grain has nowhere to go, drop the grain in its current place and exit\n  return(add_row(scan, x = x_cur, y = y_cur, chr = \"o\"))\n}\n\nDefine a function that fills the map with sand one grain at a time, starting from the designated point, until all sand comes to rest:\n\nfill_sand &lt;- function(scan, grain_func) {\n  repeat {\n    scan_new &lt;- grain_func(scan)\n    \n    # If the scan is unchanged after dropping the grain, the sand is at rest. \n    if (nrow(scan_new) == nrow(scan)) break\n    \n    scan &lt;- scan_new\n  }\n  scan\n}\n\ncount_grains &lt;- function(scan) {\n  scan |&gt; \n    filter(chr == \"o\") |&gt; \n    nrow()\n}\n\nCount the grains using the puzzle input:\n\nobstacles |&gt; \n  fill_sand(grain_func = partial(drop_grain, x_cur = 500, y_cur = 0)) |&gt; \n  count_grains()",
    "crumbs": [
      "2022",
      "Day 14"
    ]
  },
  {
    "objectID": "2022/R/day14.html#part-2",
    "href": "2022/R/day14.html#part-2",
    "title": "Day 14",
    "section": "Part 2",
    "text": "Part 2\nRe-define the drop_grain function to allow for the boundless floor:\n\ndrop_grain &lt;- function(scan, x_cur, y_cur, floor) {\n  y_new &lt;- y_cur + 1\n  \n  # Check if current location already has a grain of sand (entry blocked)\n  if (nrow(filter(scan, x == x_cur, y == y_cur)) &gt; 0)\n    return(scan)\n  \n  # Check if the current sand grain is sitting on top of the floor\n  if (y_new == floor)\n    return(add_row(scan, x = x_cur, y = y_cur, chr = \"o\"))\n  \n  # If grain can flow into the next spot, recurse into next spot\n  for (x_new in c(x_cur, x_cur - 1, x_cur + 1)) {\n    if (nrow(filter(scan, x == x_new, y == y_new)) == 0)\n      return(drop_grain(scan, x_new, y_new, floor))\n  }\n\n  # If grain has nowhere to go, drop the grain in its current place and exit\n  return(add_row(scan, x = x_cur, y = y_cur, chr = \"o\"))\n}\n\nCount the grains using the puzzle input:\n\nobstacles |&gt; \n  fill_sand(\n    grain_func = partial(\n      drop_grain, \n      x_cur = 500, \n      y_cur = 0, \n      floor = max(obstacles$y) + 2\n    )\n  ) |&gt; \n  count_grains()",
    "crumbs": [
      "2022",
      "Day 14"
    ]
  },
  {
    "objectID": "2022/R/day15.html",
    "href": "2022/R/day15.html",
    "title": "Day 15",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sf)\n\ntheme_set(theme_bw())\n\n# Read input from text and extract numeric values into a data frame\ninput &lt;- read_lines(\"../input/day15.txt\") |&gt; \n  unglue_data(\n    \"Sensor at x={s_x}, y={s_y}: closest beacon is at x={b_x}, y={b_y}\",\n    convert = TRUE\n  )",
    "crumbs": [
      "2022",
      "Day 15"
    ]
  },
  {
    "objectID": "2022/R/day15.html#setup",
    "href": "2022/R/day15.html#setup",
    "title": "Day 15",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sf)\n\ntheme_set(theme_bw())\n\n# Read input from text and extract numeric values into a data frame\ninput &lt;- read_lines(\"../input/day15.txt\") |&gt; \n  unglue_data(\n    \"Sensor at x={s_x}, y={s_y}: closest beacon is at x={b_x}, y={b_y}\",\n    convert = TRUE\n  )",
    "crumbs": [
      "2022",
      "Day 15"
    ]
  },
  {
    "objectID": "2022/R/day15.html#part-1",
    "href": "2022/R/day15.html#part-1",
    "title": "Day 15",
    "section": "Part 1",
    "text": "Part 1\nConvert input into a list of beacons, sensors, and total detection distances:\n\nsensors &lt;- input |&gt; \n  distinct(\n    s_x, \n    s_y, \n    max_dist = abs(b_x - s_x) + abs(b_y - s_y)\n  )\n\nbeacons &lt;- input |&gt; \n  distinct(x = b_x, y = b_y)\n\nGenerate a set of polygons that defines the regions detectible by each sensor:\n\n# Convert each sensor's detection distance into a region defined by a polygon\npoly &lt;- sensors |&gt; \n  mutate(\n    polygon = pmap(list(s_x, s_y, max_dist), function(x, y, dist) {\n      rbind(\n        c(x - dist, y),\n        c(x, y - dist),\n        c(x + dist, y),\n        c(x, y + dist),\n        c(x - dist, y)\n      ) |&gt; \n        list() |&gt; \n        st_polygon()\n    }),\n    geometry = st_sfc(polygon)\n  ) |&gt; \n  transmute(idx = row_number(), geometry) |&gt; \n  st_as_sf()\n\n# Merge all polygons into a single geometric shape\npoly_union &lt;- st_union(poly)\n\nVisualize:\n\n# Overlapping regions\nggplot() + \n  geom_sf(data = poly, aes(fill = factor(idx))) + \n  scale_fill_viridis_d(guide = \"none\")\n\n\n\n\n\n\n\n# Merged region\nggplot() + \n  geom_sf(data = poly_union)\n\n\n\n\n\n\n\n\nDefine a set of functions to count the number of integer points that cannot have a beacon within the detection region\n\n# Convert a set of x/y boundaries to a spatial rectangle object\npoly_rect &lt;- function(xmin, xmax, ymin, ymax) {\n  rbind(\n    c(xmin, ymax), \n    c(xmin, ymin), \n    c(xmax, ymin), \n    c(xmax, ymax), \n    c(xmin, ymax)\n  ) |&gt; \n    list() |&gt; \n    st_polygon() |&gt; \n    st_sfc()\n}\n\n# Get the coordinates within a poly, optionally limited within x/y bounds\nsf_points_in_poly &lt;- function(poly, xlim = NULL, ylim = NULL) {\n  \n  # Define a rectangular region within which to generate grid points\n  points_region &lt;- poly_rect(\n    xmin = (if (is_null(xlim)) st_bbox(poly)$xmin else head(xlim, 1)) - 0.5, \n    xmax = (if (is_null(xlim)) st_bbox(poly)$xmax else tail(xlim, 1)) + 0.5, \n    ymin = (if (is_null(ylim)) st_bbox(poly)$ymin else head(ylim, 1)) - 0.5,\n    ymax = (if (is_null(ylim)) st_bbox(poly)$ymax else tail(ylim, 1)) + 0.5\n  )\n  \n  # Generate the grid points that sit within the polygon\n  points_region |&gt; \n    st_make_grid(cellsize = 1, what = \"centers\") |&gt; \n    st_intersection(poly) |&gt; \n    \n    # Convert the set of points from spatial objects to x-y coordinates\n    st_coordinates() |&gt; \n    as_tibble() |&gt; \n    mutate(across(everything(), as.integer)) |&gt; \n    rename_with(tolower)\n}\n\n# Count the points in a sf region (with optional x/y lims) that can't be a beacon\ncount_nonbeacon &lt;- function(detection_region, known_beacons, x = NULL, y = NULL) {\n  \n  # Get the set of integer points within the polygon and x-y region specified\n  detection_region |&gt; \n    sf_points_in_poly(xlim = x, ylim = y) |&gt;\n  \n    # Remove known beacons from the list of points and count\n    anti_join(known_beacons, join_by(x, y)) |&gt;\n    nrow()\n}\n\nRun puzzle input:\n\ncount_nonbeacon(poly_union, beacons, y = 2000000)",
    "crumbs": [
      "2022",
      "Day 15"
    ]
  },
  {
    "objectID": "2022/R/day15.html#part-2",
    "href": "2022/R/day15.html#part-2",
    "title": "Day 15",
    "section": "Part 2",
    "text": "Part 2\nDefine a function to get the location of an undetected beacon within a viewport:\n\nfind_undetected_beacon &lt;- function(detection_region, xlim, ylim) {\n  boundary &lt;- poly_rect(xlim[1], xlim[2], ylim[1], ylim[2])\n  \n  # Find the polygon region where an undetected beacon could occur\n  undetected_region &lt;- st_difference(boundary, detection_region)\n  \n  # Get all integer points in the region\n  points &lt;- sf_points_in_poly(undetected_region)\n  \n  # Compute the region's boundary points to exclude\n  undetected_region_boundary &lt;- undetected_region |&gt;\n    st_bbox() |&gt;\n    as.list() |&gt;\n    pmap(\\(xmin, xmax, ymin, ymax) poly_rect(xmin, xmax, ymin, ymax)) |&gt;\n    pluck(1) |&gt; \n    st_difference(undetected_region) |&gt; \n    sf_points_in_poly()\n  \n  # Exclude all boundary points from the region\n  anti_join(points, undetected_region_boundary, join_by(x, y))\n  \n}\n\ntuning_freq &lt;- function(x, y) format(4000000 * x + y, scientific = FALSE)\n\nRun on puzzle input:\n\npoint &lt;- find_undetected_beacon(poly_union, c(0, 4000000), c(0, 4000000))\n\ntuning_freq(point$x, point$y)",
    "crumbs": [
      "2022",
      "Day 15"
    ]
  },
  {
    "objectID": "2022/R/day17.html",
    "href": "2022/R/day17.html",
    "title": "Day 17",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day17.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split_1(\"\")",
    "crumbs": [
      "2022",
      "Day 17"
    ]
  },
  {
    "objectID": "2022/R/day17.html#setup",
    "href": "2022/R/day17.html#setup",
    "title": "Day 17",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day17.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split_1(\"\")",
    "crumbs": [
      "2022",
      "Day 17"
    ]
  },
  {
    "objectID": "2022/R/day17.html#part-1",
    "href": "2022/R/day17.html#part-1",
    "title": "Day 17",
    "section": "Part 1",
    "text": "Part 1\nRepresenting obstacles as 1s and empty space as 0s, represent the shapes of the falling blocks, the floor, and the walls as bitwise integers:\n\nblock1 &lt;- strtoi(c(\"000111100\"                                    ), base = 2)\nblock2 &lt;- strtoi(c(\"000010000\",\"000111000\",\"000010000\"            ), base = 2)\nblock3 &lt;- strtoi(c(\"000111000\",\"000001000\",\"000001000\"            ), base = 2)\nblock4 &lt;- strtoi(c(\"000100000\",\"000100000\",\"000100000\",\"000100000\"), base = 2)\nblock5 &lt;- strtoi(c(\"000110000\",\"000110000\"                        ), base = 2)\n\nwalls  &lt;- strtoi(\"100000001\", base = 2)\nfloor  &lt;- strtoi(\"111111111\", base = 2)\n\nblocks &lt;- list(block1, block2, block3, block4, block5)\n\nDefine functions that give properties of the tower:\n\n# Print tower to terminal (for debugging)\nprint_tower &lt;- function(tower) {\n  tower |&gt;\n  imap_chr(\\(row, name) {\n    row |&gt; \n      intToBits() |&gt; \n      rev() |&gt; \n      tail(9) |&gt; \n      as.integer() |&gt; \n      case_match(0 ~ \"·\", 1 ~ \"#\") |&gt; \n      modify_at(.at = c(1L, 9L), .f = ~ \"|\") |&gt; \n      str_c(collapse = \"\") |&gt; \n      str_c(name, sep = \" \")\n  }) |&gt; \n  modify_at(.at = 1L, .f = ~ if_else(.x == \"|#######| 0\", \"+-------+ 0\", .x)) |&gt; \n  rev() |&gt; \n  cat(sep = \"\\n\")\n}\n\ntower_height &lt;- function(tower) {\n  idx &lt;- max(which(tower != walls))\n  tower[idx] |&gt;\n    names() |&gt; \n    as.double()\n}\n\ntower_base &lt;- function(tower) {\n  idx &lt;- max(which(accumulate(tower, bitwOr, .dir = \"backward\") == floor))\n  tower[idx] |&gt;\n    names() |&gt; \n    as.double()\n}\n\ntrim_tower &lt;- function(tower) {\n  base &lt;- tower_base(tower)\n  top  &lt;- tower_height(tower)\n  tower[as.character(base:top)]\n}\n\nDefine functions that move blocks and check if the move is valid:\n\nshift_block &lt;- function(block, dir) {\n  f &lt;- switch(dir, \n    \"&lt;\" = bitwShiftL, \n    \"&gt;\" = bitwShiftR\n  )\n  f(block, 1)\n}\n\nis_collision &lt;- function(block, tower_slice) {\n  any(bitwAnd(block, tower_slice) &gt; 0)\n}\n\n# Try to move the block L/R if the move is valid, or return the old one if not\ntry_shift_block &lt;- function(block, dir, tower_slice) {\n  new &lt;- shift_block(block, dir)\n  if (is_collision(new, tower_slice))\n    block\n  else\n    new\n}\n\nDefine a function to drop blocks onto a tower:\n\ndrop_blocks &lt;- function(jets, n_blocks) {\n  \n  tower        &lt;- floor\n  names(tower) &lt;- 1:length(tower) - 1\n  \n  n_jets &lt;- length(jets)\n  time   &lt;- 0\n  \n  # Cycle through the list of blocks and drop them in order\n  for (i in 1:n_blocks) {\n    \n    block_idx &lt;- (i - 1) %% length(blocks) + 1\n    block     &lt;- blocks[[block_idx]]\n    \n    # Initialize the vertical location of the block\n    block_loc &lt;- 1:length(block) + 3 + tower_height(tower)\n    \n    # Add empty wall space to the top of the tower\n    add_walls &lt;- rep(walls, length(block) + 3) |&gt; \n      set_names(c(min(block_loc) - 3:1, block_loc))\n    tower &lt;- c(tower, add_walls)\n    \n    # Drop block until it comes to rest\n    repeat {\n      jet_idx &lt;- time %% n_jets + 1\n      \n      # Apply jet blast & increment time\n      block &lt;- try_shift_block(block, jets[jet_idx], tower[as.character(block_loc)])\n      time &lt;- time + 1\n      \n      # Check if block has come to rest; if so, add block to tower\n      if (is_collision(block, tower[as.character(block_loc - 1)])) {\n        tower[as.character(block_loc)] &lt;- bitwOr(tower[as.character(block_loc)], block)\n        tower &lt;- trim_tower(tower)\n        break\n        \n      } \n      # Otherwise drop block one unit and repeat the block jet seq\n      else {\n        block_loc &lt;- block_loc - 1\n      }\n    }\n  }\n  \n  tower\n}\n\nRun on puzzle input:\n\ninput |&gt; \n  drop_blocks(2022) |&gt; \n  tower_height()",
    "crumbs": [
      "2022",
      "Day 17"
    ]
  },
  {
    "objectID": "2022/R/day17.html#part-2",
    "href": "2022/R/day17.html#part-2",
    "title": "Day 17",
    "section": "Part 2",
    "text": "Part 2\nModify the drop_blocks function to loop until a cycle is found and return cycle info:\n\nfind_cycle &lt;- function(jets) {\n  \n  tower        &lt;- floor\n  names(tower) &lt;- 1:length(tower) - 1\n  \n  n_jets &lt;- length(jets)\n  time   &lt;- 0\n  states &lt;- tibble(\n    n_blocks  = numeric(0),\n    tower_idx = list(),\n    tower_val = list(), \n    block_idx = numeric(0), \n    jet_idx   = numeric(0)\n  )\n  \n  i &lt;- 1\n  # Cycle through the list of blocks and drop them in order\n  repeat {\n    \n    block_idx &lt;- (i - 1) %% length(blocks) + 1\n    block     &lt;- blocks[[block_idx]]\n    \n    # Initialize the vertical location of the block\n    block_loc &lt;- 1:length(block) + 3 + tower_height(tower)\n    \n    # Add empty wall space to the top of the tower\n    add_walls &lt;- rep(walls, length(block) + 3) |&gt; \n      set_names(c(min(block_loc) - 3:1, block_loc))\n    tower &lt;- c(tower, add_walls)\n    \n    # Drop block until it comes to rest\n    repeat {\n      jet_idx &lt;- time %% n_jets + 1\n      \n      # Apply jet blast & increment time\n      block &lt;- try_shift_block(block, jets[jet_idx], tower[as.character(block_loc)])\n      time &lt;- time + 1\n      \n      # Check if block has come to rest; if so, add block to tower\n      if (is_collision(block, tower[as.character(block_loc - 1)])) {\n        tower[as.character(block_loc)] &lt;- bitwOr(tower[as.character(block_loc)], block)\n        tower &lt;- trim_tower(tower)\n        \n        # Add block and jet index to the states list\n        states &lt;- states |&gt; \n          add_row(\n            n_blocks  = i,\n            tower_idx = list(names(tower)),\n            tower_val = list(unname(tower)),\n            block_idx = block_idx,\n            jet_idx   = jet_idx\n          )\n        # print(tower)\n        break\n        \n      } \n      # Otherwise drop block one unit and repeat the block jet seq\n      else {\n        block_loc &lt;- block_loc - 1\n      }\n    }\n    \n    i &lt;- i + 1\n    \n    # After each block is dropped, check if a cycle has been found and return it\n    dupes &lt;- states |&gt; \n      filter(n_distinct(tower_val) != n(), .by = c(block_idx, jet_idx))\n    \n    if (nrow(dupes) &gt; 0) {\n      \n      cycle_length &lt;- dupes |&gt;\n        pull(n_blocks) |&gt;\n        reduce(`-`) |&gt;\n        abs()\n\n      cycle_start &lt;- dupes |&gt;\n        pull(n_blocks) |&gt;\n        min()\n      \n      cycle_height &lt;- dupes |&gt;\n        pull(tower_idx) |&gt; \n        map(as.numeric) |&gt; \n        reduce(`-`) |&gt; \n        unique() |&gt; \n        abs()\n\n      return(list(length = cycle_length, start = cycle_start, height = cycle_height))\n      return(dupes)\n    }\n  }\n}\n\nGet the cycle of the puzzle input:\n\ncycle &lt;- find_cycle(input)\n\nUsing the cycle info from the output, compute the majority of the height using the cycle, then and add the height of the remaineder:\n\nn_cycles &lt;- floor((1000000000000 - cycle$start) / cycle$length)\nn_blocks &lt;- (1000000000000 - cycle$start) %% cycle$length + cycle$start\n\n((n_cycles * cycle$height) + tower_height(drop_blocks(input, n_blocks))) |&gt; \n  format(scientific = FALSE)",
    "crumbs": [
      "2022",
      "Day 17"
    ]
  },
  {
    "objectID": "2022/R/day02.html",
    "href": "2022/R/day02.html",
    "title": "Day 2",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_fwf(\"../input/day02.txt\", col_types = \"c\")",
    "crumbs": [
      "2022",
      "Day 2"
    ]
  },
  {
    "objectID": "2022/R/day02.html#setup",
    "href": "2022/R/day02.html#setup",
    "title": "Day 2",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_fwf(\"../input/day02.txt\", col_types = \"c\")",
    "crumbs": [
      "2022",
      "Day 2"
    ]
  },
  {
    "objectID": "2022/R/day02.html#part-1",
    "href": "2022/R/day02.html#part-1",
    "title": "Day 2",
    "section": "Part 1",
    "text": "Part 1\n\n# Format shapes/strategies as numbers 1-3 for modular arithmetic\ndf &lt;- tibble(\n  opponent = as.numeric(factor(input$X1, levels = c(\"A\", \"B\", \"C\"))),\n  strategy = as.numeric(factor(input$X2, levels = c(\"X\", \"Y\", \"Z\")))\n)\n\nscore_shape &lt;- function(df) {\n  df |&gt; \n    mutate(\n      self = strategy,\n      outcome = (self - opponent + 1) %% 3 * 3,\n      score = self + outcome\n    ) |&gt;\n    pull(score) |&gt;\n    sum()\n}\n\nRun puzzle input:\n\nscore_shape(df)",
    "crumbs": [
      "2022",
      "Day 2"
    ]
  },
  {
    "objectID": "2022/R/day02.html#part-2",
    "href": "2022/R/day02.html#part-2",
    "title": "Day 2",
    "section": "Part 2",
    "text": "Part 2\n\nscore_outcome &lt;- function(df) {\n  df |&gt; \n    mutate(\n      self = (opponent + strategy) %% 3 + 1,\n      outcome = (strategy - 1) * 3,\n      score = self + outcome\n    ) |&gt;\n    pull(score) |&gt;\n    sum()\n}\n\n\nscore_outcome(df)",
    "crumbs": [
      "2022",
      "Day 2"
    ]
  },
  {
    "objectID": "2022/R/day12.html",
    "href": "2022/R/day12.html",
    "title": "Day 12",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day12.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 12"
    ]
  },
  {
    "objectID": "2022/R/day12.html#setup",
    "href": "2022/R/day12.html#setup",
    "title": "Day 12",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day12.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 12"
    ]
  },
  {
    "objectID": "2022/R/day12.html#part-1",
    "href": "2022/R/day12.html#part-1",
    "title": "Day 12",
    "section": "Part 1",
    "text": "Part 1\nReformat input as a data frame of coordinates and elevations:\n\ndf &lt;- input |&gt;\n  str_split(\"\") |&gt;\n  unlist() |&gt;\n  as_tibble() |&gt;\n  transmute(\n    id = row_number(),\n    letter = value,\n    elevation = case_when(\n      letter == \"S\" ~  Inf,\n      letter == \"E\" ~ -Inf,\n      .default = match(letter, letters)\n    ),\n    row = floor((id - 1) / str_length(input[1]) + 1),\n    col = (id - 1) %% str_length(input[1]) + 1\n  )\n\n\ndf_to_graph &lt;- function(df) {\n\n  # Flag whether each neighbor of each vertex is walkable\n  neighbors &lt;- df |&gt;\n    mutate(up   = lag(id), down  = lead(id), .by = col) |&gt;\n    mutate(left = lag(id), right = lead(id), .by = row) |&gt;\n    mutate(\n      across(\n        c(up, down, left, right),\n        ~ elevation[.x],\n        .names = \"{.col}_elev\"\n      ),\n      across(\n        ends_with(\"_elev\"),\n        ~ (.x - elevation) &lt;= 1,\n        .names = \"{str_remove(.col, '_elev')}_walkable\"\n      )\n    ) |&gt;\n    rename_with(.cols = c(up, down, left, right), ~ str_c(.x, \"_idx\")) |&gt;\n    select(source_idx = id, ends_with(c(\"idx\", \"walkable\")))\n\n  # Construct a list of edges\n  edge_list &lt;- neighbors |&gt;\n    pivot_longer(\n      !source_idx,\n      names_to = c(\"target_dir\", \".value\"),\n      names_sep = \"_\"\n    ) |&gt;\n    rename(\n      target_idx = idx,\n      target_walkable = walkable\n    ) |&gt;\n    filter(target_walkable == TRUE) |&gt;\n    pmap(function(source_idx, target_idx, ...) { c(source_idx, target_idx) }) |&gt;\n    unlist()\n\n  # Convert to a directed graph\n  g &lt;- make_empty_graph() |&gt;\n    add_vertices(length(df$id)) |&gt;\n    add_edges(edge_list)\n\n}\n\nshortest_path_length &lt;- function(g, source_idx, target_idx) {\n  shortest_paths(g, from = source_idx, to = target_idx)$vpath[[1]] |&gt;\n    length() - 1\n}\n\n\ng &lt;- df_to_graph(df)\n\n\n# Get the indices of the start and end vertices\nidx_start &lt;- match(\"S\", df$letter)\nidx_end   &lt;- match(\"E\", df$letter)\n\n# Compute shortest path from start to end\nshortest_path_length(g, idx_start, idx_end)",
    "crumbs": [
      "2022",
      "Day 12"
    ]
  },
  {
    "objectID": "2022/R/day12.html#part-2",
    "href": "2022/R/day12.html#part-2",
    "title": "Day 12",
    "section": "Part 2",
    "text": "Part 2\n\n# Loop over all starting locations and find the shortest path to the end\nmin_dist &lt;- Inf\nfor (i in c(idx_start, which(df$letter == \"a\"))) {\n  cur &lt;- shortest_path_length(g, i, idx_end)\n  if (cur &gt;= 0 & cur &lt; min_dist) {\n    min_dist &lt;- cur\n  }\n}\nmin_dist",
    "crumbs": [
      "2022",
      "Day 12"
    ]
  },
  {
    "objectID": "2022/R/day07.html",
    "href": "2022/R/day07.html",
    "title": "Day 7",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day07.txt\") |&gt; \n  enframe(name = NULL)",
    "crumbs": [
      "2022",
      "Day 7"
    ]
  },
  {
    "objectID": "2022/R/day07.html#setup",
    "href": "2022/R/day07.html#setup",
    "title": "Day 7",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day07.txt\") |&gt; \n  enframe(name = NULL)",
    "crumbs": [
      "2022",
      "Day 7"
    ]
  },
  {
    "objectID": "2022/R/day07.html#part-1",
    "href": "2022/R/day07.html#part-1",
    "title": "Day 7",
    "section": "Part 1",
    "text": "Part 1\n\ndir_sizes &lt;- input |&gt; \n  mutate(\n\n    # Determine path of each file by accumulating preceding cd terms\n    path = value |&gt;\n      str_extract(\"(?&lt;=^\\\\$ cd ).*\") |&gt;\n      str_c(\"/\") |&gt;\n      replace_na(\"\") |&gt;\n      accumulate(\n        ~ if (.y == \"../\") {\n          str_remove(.x, \"(?&lt;=/)[a-z]+/$\")\n        } else {\n          str_c(.x, .y)\n        }\n      ) |&gt;\n      str_remove_all(\"^/|/$\"),\n\n    # Convert paths to lists of all containing directories\n    dirs = path |&gt;\n      str_split(\"/\") |&gt;\n      map(~accumulate(.x, str_c, sep = \"/\"))\n  ) |&gt;\n\n  # Remove commands & directories from output and format file info as cols\n  filter(!str_detect(value, \"^\\\\$|dir \")) |&gt;\n  separate(value, into = c(\"size\", \"file\"), sep = \" \") |&gt;\n  mutate(size = as.integer(size)) |&gt;\n\n  # Convert nested lists of directories to long-format\n  unnest_wider(dirs, names_sep = \"_\") |&gt;\n  mutate(dirs_1 = \"/\") |&gt;\n  pivot_longer(\n    cols = matches(\"dirs_\\\\d+\"),\n    names_to = NULL,\n    values_to = \"dir\",\n    values_drop_na = TRUE\n  ) |&gt;\n\n  # Compute size of each directory\n  group_by(dir) |&gt;\n  summarize(size = sum(size)) |&gt;\n  ungroup()\n\nSum sizes of all directories with maximum size 100000:\n\ndir_sizes |&gt;\n  filter(size &lt;= 100000) |&gt;\n  pull(size) |&gt;\n  sum()",
    "crumbs": [
      "2022",
      "Day 7"
    ]
  },
  {
    "objectID": "2022/R/day07.html#part-2",
    "href": "2022/R/day07.html#part-2",
    "title": "Day 7",
    "section": "Part 2",
    "text": "Part 2\nFind size of the smallest necessary directory to delete:\n\ncurr_system_size &lt;- dir_sizes |&gt;\n  filter(dir == \"/\") |&gt;\n  pull(size)\n\ndir_sizes |&gt;\n  filter(size &gt;= (30000000 - (70000000 - curr_system_size))) |&gt;\n  slice_min(size) |&gt;\n  pull(size)",
    "crumbs": [
      "2022",
      "Day 7"
    ]
  },
  {
    "objectID": "2022/R/day05.html",
    "href": "2022/R/day05.html",
    "title": "Day 5",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\npath &lt;- \"../input/day05.txt\"\ninput &lt;- read_lines(path)",
    "crumbs": [
      "2022",
      "Day 5"
    ]
  },
  {
    "objectID": "2022/R/day05.html#setup",
    "href": "2022/R/day05.html#setup",
    "title": "Day 5",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\npath &lt;- \"../input/day05.txt\"\ninput &lt;- read_lines(path)",
    "crumbs": [
      "2022",
      "Day 5"
    ]
  },
  {
    "objectID": "2022/R/day05.html#part-1",
    "href": "2022/R/day05.html#part-1",
    "title": "Day 5",
    "section": "Part 1",
    "text": "Part 1\n\n# Format raw input\nmoves &lt;- input |&gt;\n  tail_while(~ .x != \"\") |&gt;\n  str_extract_all(\"\\\\d+\") |&gt;\n  map(as.integer)\n\nstacks &lt;- read_fwf(\n  path,\n  n_max = length(input) - length(moves) - 2,\n  col_types = \"c\"\n) |&gt;\n  mutate(across(everything(), ~ str_extract(.x, \"[A-Z]\"))) |&gt;\n  as.list() |&gt;\n  map(discard, is.na) |&gt;\n  map(rev)\n\nmove_crates &lt;- function(moves, stacks, func) {\n  \n  # Execute moves\n  for (curr_move in moves) {\n    count &lt;- curr_move[1]\n    from  &lt;- curr_move[2]\n    to    &lt;- curr_move[3]\n    \n    crates &lt;- func(tail(stacks[[from]], count))\n\n    stacks[[to]]   &lt;- append(stacks[[to]], crates)\n    stacks[[from]] &lt;- head(stacks[[from]], -1 * count)\n  }\n\n  # Examine final top row of crates\n  stacks |&gt;\n    map(~ tail(.x, 1)) |&gt;\n    str_c(collapse = \"\")\n}\n\n\nmove_crates(moves, stacks, rev)",
    "crumbs": [
      "2022",
      "Day 5"
    ]
  },
  {
    "objectID": "2022/R/day05.html#part-2",
    "href": "2022/R/day05.html#part-2",
    "title": "Day 5",
    "section": "Part 2",
    "text": "Part 2\n\nmove_crates(moves, stacks, identity)",
    "crumbs": [
      "2022",
      "Day 5"
    ]
  },
  {
    "objectID": "2022/R/day10.html",
    "href": "2022/R/day10.html",
    "title": "Day 10",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day10.txt\") |&gt;\n  enframe(name = \"cmd_num\")",
    "crumbs": [
      "2022",
      "Day 10"
    ]
  },
  {
    "objectID": "2022/R/day10.html#setup",
    "href": "2022/R/day10.html#setup",
    "title": "Day 10",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day10.txt\") |&gt;\n  enframe(name = \"cmd_num\")",
    "crumbs": [
      "2022",
      "Day 10"
    ]
  },
  {
    "objectID": "2022/R/day10.html#part-1",
    "href": "2022/R/day10.html#part-1",
    "title": "Day 10",
    "section": "Part 1",
    "text": "Part 1\n\nsignal &lt;- input |&gt;\n\n  # Convert multi-cycle commands into list of changes to X at each cycle\n  separate(value, into = c(\"cmd\", \"V\"), sep = \" \", convert = TRUE) |&gt;\n  transmute(cmd_num, v1 = 0, v2 = V) |&gt;\n  pivot_longer(\n    c(v1, v2),\n    names_to = \"cycle_count\",\n    values_to = \"x_change\",\n    values_drop_na = TRUE\n  ) |&gt;\n  pull(x_change) |&gt;\n\n  # Iterate through changes to X to get value of X during each cycle\n  accumulate(`+`, .init = 1) |&gt;\n  enframe(name = \"cycle\", value = \"X\") |&gt;\n  slice_head(n = -1)\n\n\n# Sum the signal strength at 20th cycle & every 40 cycles after that\nsignal |&gt;\n  filter(cycle %% 40 == 20) |&gt;\n  mutate(signal_strength = cycle * X) |&gt;\n  pull(signal_strength) |&gt;\n  sum()",
    "crumbs": [
      "2022",
      "Day 10"
    ]
  },
  {
    "objectID": "2022/R/day10.html#part-2",
    "href": "2022/R/day10.html#part-2",
    "title": "Day 10",
    "section": "Part 2",
    "text": "Part 2\n\n# Draw pixel when position of 3px-wide sprite overlaps w/ CRT position\nsignal |&gt;\n  mutate(\n    row = floor((cycle - 1) / 40),\n    col = (cycle - 1) %% 40\n  ) |&gt;\n  mutate(pixel = if_else(X &lt;= col + 1 & X &gt;= col - 1, \"#\", \".\")) |&gt;\n  group_by(row) |&gt;\n  summarize(val = str_c(pixel, collapse = \"\")) |&gt;\n  pull(val) |&gt;\n  cat(sep = \"\\n\")",
    "crumbs": [
      "2022",
      "Day 10"
    ]
  },
  {
    "objectID": "2022/R/day04.html",
    "href": "2022/R/day04.html",
    "title": "Day 4",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_csv(\"../input/day04.txt\", col_names = FALSE)",
    "crumbs": [
      "2022",
      "Day 4"
    ]
  },
  {
    "objectID": "2022/R/day04.html#setup",
    "href": "2022/R/day04.html#setup",
    "title": "Day 4",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_csv(\"../input/day04.txt\", col_names = FALSE)",
    "crumbs": [
      "2022",
      "Day 4"
    ]
  },
  {
    "objectID": "2022/R/day04.html#parts-1-2",
    "href": "2022/R/day04.html#parts-1-2",
    "title": "Day 4",
    "section": "Parts 1 & 2",
    "text": "Parts 1 & 2\n\ninput |&gt;  \n  separate(X1, into = c(\"start1\", \"end1\"), sep = \"-\", convert = TRUE) |&gt;\n  separate(X2, into = c(\"start2\", \"end2\"), sep = \"-\", convert = TRUE) |&gt;\n  mutate(\n    range1 = map2(start1, end1, ~ .x:.y),\n    range2 = map2(start2, end2, ~ .x:.y),\n    contained = map2_lgl(range1, range2, ~ all(.x %in% .y) | all(.y %in% .x)),\n    overlap   = map2_lgl(range1, range2, ~ length(intersect(.x, .y)) &gt; 0)\n  ) |&gt;\n  summarize(num_contained = sum(contained), num_overlap = sum(overlap))",
    "crumbs": [
      "2022",
      "Day 4"
    ]
  },
  {
    "objectID": "2022/R/day11.html",
    "href": "2022/R/day11.html",
    "title": "Day 11",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day11.txt\") |&gt;\n  trimws() |&gt;\n  discard(~ .x == \"\")",
    "crumbs": [
      "2022",
      "Day 11"
    ]
  },
  {
    "objectID": "2022/R/day11.html#setup",
    "href": "2022/R/day11.html#setup",
    "title": "Day 11",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day11.txt\") |&gt;\n  trimws() |&gt;\n  discard(~ .x == \"\")",
    "crumbs": [
      "2022",
      "Day 11"
    ]
  },
  {
    "objectID": "2022/R/day11.html#part-1",
    "href": "2022/R/day11.html#part-1",
    "title": "Day 11",
    "section": "Part 1",
    "text": "Part 1\n\n# Reformat input\nitems &lt;- str_match(input, \"Starting items:(.*)\")[,2] |&gt;\n  discard(is.na) |&gt;\n  str_split(\",\") |&gt;\n  map(parse_number)\n\noperations &lt;- input |&gt;\n  keep(~ str_detect(.x, \"Operation:\")) |&gt;\n  str_replace(\"Operation: new = \", \"~ \") |&gt;\n  str_replace_all(\"old\", \".x\") |&gt;\n  map(~ rlang::as_function(as.formula(.x)))\n\ndiv  &lt;- parse_number(keep(input, ~ str_detect(.x, \"Test:\")))\ndivt &lt;- parse_number(keep(input, ~ str_detect(.x, \"If true:\")))\ndivf &lt;- parse_number(keep(input, ~ str_detect(.x, \"If false:\")))\n\ntest &lt;- pmap(\n  list(div, divt, divf),\n  ~ function(x) if_else(x %% ..1 == 0, ..2 + 1, ..3 + 1)\n)\n\nnum_monkeys &lt;- length(input) / 6\n\n\ncompute_monkey_business &lt;- function(num_rounds, worry_func) {\n  # Initialize\n  activity &lt;- rep(0, num_monkeys)\n\n  # Perform the tosses\n  for (round in 1:num_rounds) {\n    for (monkey in 1:num_monkeys) {\n      for (item in items[[monkey]]) {\n        worry &lt;- worry_func(operations[[monkey]](item))\n        toss  &lt;- test[[monkey]](worry)\n        items[[toss]] &lt;- c(items[[toss]], worry)\n      }\n      activity[[monkey]] &lt;- activity[[monkey]] + length(items[[monkey]])\n      items[[monkey]] &lt;- numeric(0)\n    }\n  }\n\n  # Compute monkey business score\n  activity |&gt;\n    sort() |&gt;\n    tail(2) |&gt;\n    reduce(`*`)\n}\n\n\ncompute_monkey_business(num_rounds = 20, worry_func = \\(x) floor(x / 3))",
    "crumbs": [
      "2022",
      "Day 11"
    ]
  },
  {
    "objectID": "2022/R/day11.html#part-2",
    "href": "2022/R/day11.html#part-2",
    "title": "Day 11",
    "section": "Part 2",
    "text": "Part 2\n\nlcm &lt;- DescTools::LCM(div)\ncompute_monkey_business(num_rounds = 10000, worry_func = \\(x) x %% lcm)",
    "crumbs": [
      "2022",
      "Day 11"
    ]
  },
  {
    "objectID": "2022/R/day13.html",
    "href": "2022/R/day13.html",
    "title": "Day 13",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input into a data frame and convert to indexed nested lists\ndf &lt;- read_table(\"../input/day13.txt\", col_names = \"txt\") |&gt; \n  mutate(\n    row_id   = row_number(),\n    group_id = floor((row_id - 1) / 2) + 1,\n    item_id  = (row_id - 1) %% 2 + 1,\n    lst      = map(txt, jsonlite::fromJSON, simplifyVector = FALSE)\n  )",
    "crumbs": [
      "2022",
      "Day 13"
    ]
  },
  {
    "objectID": "2022/R/day13.html#setup",
    "href": "2022/R/day13.html#setup",
    "title": "Day 13",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input into a data frame and convert to indexed nested lists\ndf &lt;- read_table(\"../input/day13.txt\", col_names = \"txt\") |&gt; \n  mutate(\n    row_id   = row_number(),\n    group_id = floor((row_id - 1) / 2) + 1,\n    item_id  = (row_id - 1) %% 2 + 1,\n    lst      = map(txt, jsonlite::fromJSON, simplifyVector = FALSE)\n  )",
    "crumbs": [
      "2022",
      "Day 13"
    ]
  },
  {
    "objectID": "2022/R/day13.html#part-1",
    "href": "2022/R/day13.html#part-1",
    "title": "Day 13",
    "section": "Part 1",
    "text": "Part 1\nDefine a function to compare nested lists:\n\ncompare_nested &lt;- function(a, b) {\n\n  # Compare if both inputs are numeric\n  if (is.numeric(a) & is.numeric(b)) {\n    if (a &lt; b)  return(-1)\n    if (a &gt; b)  return(1)\n    if (a == b) return(0)\n  }\n\n  # Compare if only one input is numeric\n  if (is.numeric(a) != is.numeric(b)) {\n    if (is.numeric(a))\n      return(compare_nested(list(a), b))\n    if (is.numeric(b))\n      return(compare_nested(a, list(b)))\n  }\n\n  # Compare if both inputs are lists\n  i &lt;- 1\n  while (i &lt;= min(length(a), length(b))) {\n    result &lt;- compare_nested(a[[i]], b[[i]])\n    if (result %in% c(1, -1))\n      return(result)\n    i &lt;- i + 1\n  }\n  # When all comparable values are equal, compare lengths\n  return(compare_nested(length(a), length(b)))\n}\n\nSum the indices of packet pairs that are in order:\n\ndf |&gt;\n  select(group_id, item_id, lst) |&gt;\n  pivot_wider(\n    names_from = item_id,\n    names_prefix = \"item_\",\n    values_from = lst\n  ) |&gt;\n  mutate(comparison = map2_int(item_1, item_2, compare_nested)) |&gt;\n  filter(comparison == -1) |&gt;\n  pull(group_id) |&gt; \n  sum()",
    "crumbs": [
      "2022",
      "Day 13"
    ]
  },
  {
    "objectID": "2022/R/day13.html#part-2",
    "href": "2022/R/day13.html#part-2",
    "title": "Day 13",
    "section": "Part 2",
    "text": "Part 2\nDefine a function to determine the pairwise order of nested lists:\n\nsort_nested &lt;- function(lst) {\n  n &lt;- length(lst)\n  indices &lt;- 1:n\n\n  if (n == 0) return()\n  if (n == 1) return(indices)\n\n  # Bubble sort: loop through list and swap elements until sorted\n  repeat {\n    swap_occurred &lt;- FALSE\n    for (i in 1:(n - 1)) {\n      j1 &lt;- which(indices == i)\n      j2 &lt;- which(indices == i + 1)\n      if (compare_nested(lst[[j1]], lst[[j2]]) == 1) {\n        indices[j1] &lt;- i + 1\n        indices[j2] &lt;- i\n        swap_occurred &lt;- TRUE\n      }\n    }\n    if (!swap_occurred) break\n  }\n  return(indices)\n}\n\nAdd new flagged packets, sort all, and multiply flagged indices:\n\nnew_packets &lt;- list(\"[[2]]\", \"[[6]]\") |&gt;\n  map(jsonlite::fromJSON, simplifyVector = FALSE) |&gt;\n  as_tibble_col(column_name = \"lst\")\n\ndf |&gt;\n  transmute(lst, flag = FALSE) |&gt;\n  add_row(new_packets, flag = TRUE) |&gt;\n  mutate(ord = sort_nested(lst)) |&gt;\n  filter(flag) |&gt;\n  pull(ord) |&gt; \n  prod()",
    "crumbs": [
      "2022",
      "Day 13"
    ]
  },
  {
    "objectID": "2022/R/day06.html",
    "href": "2022/R/day06.html",
    "title": "Day 6",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day06.txt\") |&gt;\n  str_split_1(\"\") |&gt;\n  enframe(name = \"idx\", value = \"char\")",
    "crumbs": [
      "2022",
      "Day 6"
    ]
  },
  {
    "objectID": "2022/R/day06.html#setup",
    "href": "2022/R/day06.html#setup",
    "title": "Day 6",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day06.txt\") |&gt;\n  str_split_1(\"\") |&gt;\n  enframe(name = \"idx\", value = \"char\")",
    "crumbs": [
      "2022",
      "Day 6"
    ]
  },
  {
    "objectID": "2022/R/day06.html#part-1",
    "href": "2022/R/day06.html#part-1",
    "title": "Day 6",
    "section": "Part 1",
    "text": "Part 1\n\nfind_marker &lt;- function(df, marker_length) {\n  df |&gt; \n    # Construct sequences of next n chars and count # of unique chars in each\n    transmute(\n      marker_idx = idx + marker_length - 1,\n      char_seq = reduce(\n        .x = map(0:(marker_length - 1), ~ lead(char, n = .x)),\n        .f = str_c\n      ),\n      n_unique = map_int(\n        char_seq,\n        ~ .x |&gt;\n          str_split(\"\") |&gt;\n          unlist() |&gt;\n          unique() |&gt;\n          length()\n      )\n    ) |&gt;\n\n    # Extract first instance where all n chars are unique\n    filter(n_unique == marker_length) |&gt;\n    pull(marker_idx) |&gt;\n    min()\n}\n\n\nfind_marker(input, marker_length = 4)",
    "crumbs": [
      "2022",
      "Day 6"
    ]
  },
  {
    "objectID": "2022/R/day06.html#part-2",
    "href": "2022/R/day06.html#part-2",
    "title": "Day 6",
    "section": "Part 2",
    "text": "Part 2\n\nfind_marker(input, marker_length = 14)",
    "crumbs": [
      "2022",
      "Day 6"
    ]
  },
  {
    "objectID": "2022/R/day16.html",
    "href": "2022/R/day16.html",
    "title": "Day 16",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\n    c(\n      \"Valve {source} has flow rate={rate}; tunnels lead to valves {target}\",\n      \"Valve {source} has flow rate={rate}; tunnel leads to valve {target}\"\n    ),\n    convert = TRUE\n  ) |&gt; \n  mutate(target = map(target, \\(x) str_split_1(x, \", \")))",
    "crumbs": [
      "2022",
      "Day 16"
    ]
  },
  {
    "objectID": "2022/R/day16.html#setup",
    "href": "2022/R/day16.html#setup",
    "title": "Day 16",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\n    c(\n      \"Valve {source} has flow rate={rate}; tunnels lead to valves {target}\",\n      \"Valve {source} has flow rate={rate}; tunnel leads to valve {target}\"\n    ),\n    convert = TRUE\n  ) |&gt; \n  mutate(target = map(target, \\(x) str_split_1(x, \", \")))",
    "crumbs": [
      "2022",
      "Day 16"
    ]
  },
  {
    "objectID": "2022/R/day16.html#part-1",
    "href": "2022/R/day16.html#part-1",
    "title": "Day 16",
    "section": "Part 1",
    "text": "Part 1\nRepresent tunnels and valves as a graph:\n\ng &lt;- input |&gt;\n  unnest(target) |&gt; \n  pmap(function(source, target, ...) c(source, target)) |&gt; \n  unique() |&gt; \n  unlist() |&gt; \n  make_graph(directed = TRUE) |&gt; \n  as_undirected()\n\nGet the list of valves with nonzero flow:\n\nflows &lt;- input |&gt; \n  filter(rate &gt; 0 | source == \"AA\") |&gt; \n  select(source, rate) |&gt; \n  deframe()\n\nnon_init_flows &lt;- flows |&gt; \n  discard_at(\"AA\")\n\nvalves &lt;- names(flows)\n\ndists &lt;- distances(g, valves, valves)\n\nList all permutations of possible valves to visit with a total distance less than 30:\n\nget_path &lt;- function(choices, last, cur_length, max_length) {\n  if (cur_length &gt;= max_length)\n    return(head(last, -1))\n  if (length(choices) == 0)\n    return(last)\n  \n  ls &lt;- list()\n  for (valve in choices) {\n    ls &lt;- append(\n      ls, \n      list(get_path(\n        choices[choices != valve], \n        c(last, valve), \n        cur_length + dists[tail(last, 1), valve] + 1,\n        max_length\n      ))\n    )\n  }\n  ls |&gt; \n    discard(is_null) |&gt; \n    list_flatten() |&gt; \n    unique()\n}\n\ncombos &lt;- get_path(names(non_init_flows), names(flows[\"AA\"]), 0, 30)\n\nCompute total pressure released for each permutation:\n\nget_pressures &lt;- function(paths, max_time) {\n  map_dbl(paths, \\(path) {\n    valve      &lt;- tail(path, -1)\n    valve_lag  &lt;- head(path, -1)\n    flow       &lt;- tail(flows[path], -1)\n    \n    dist       &lt;- map2_int(valve_lag, valve, \\(src, target) dists[src, target])\n    time_start &lt;- cumsum(dist) + 1:length(dist) + 1\n    pressure   &lt;- (max_time - time_start + 1) * flow\n    \n    sum(pressure[time_start &lt;= max_time])\n  })\n}\n\npressures &lt;- get_pressures(combos, 30)\n\nFind the permutation that gives the maximum pressure:\n\nmax_idx &lt;- which.max(pressures)\npressures[max_idx]",
    "crumbs": [
      "2022",
      "Day 16"
    ]
  },
  {
    "objectID": "2022/R/day16.html#part-2",
    "href": "2022/R/day16.html#part-2",
    "title": "Day 16",
    "section": "Part 2",
    "text": "Part 2\nList all permutations of possible valves to visit with a total distance less than 26:\n\nel_combos    &lt;- get_path(names(non_init_flows), names(flows[\"AA\"]), 0, 26)\nel_pressures &lt;- get_pressures(el_combos, 26)\n\nFor each set of permutations, get the best pressure.\n\nel_best &lt;- tibble(valves = map(el_combos, sort), pressure = el_pressures) |&gt; \n  slice_max(pressure, by = valves, with_ties = FALSE)\n\nGet best combinations of permutations between yourself and the elephant:\n\nel_best |&gt; \n  rename(el_valves = valves, el_pressure = pressure) |&gt; \n  pmap_dbl(\\(el_valves, el_pressure) {\n    el_valves &lt;- el_valves[el_valves != \"AA\"]\n    el_pressure + el_best |&gt;\n      filter(map_lgl(valves, ~ length(intersect(.x, el_valves)) == 0)) |&gt; \n      pull(pressure) |&gt; \n      max()\n  }) |&gt; \n  max()",
    "crumbs": [
      "2022",
      "Day 16"
    ]
  },
  {
    "objectID": "2022/R/day03.html",
    "href": "2022/R/day03.html",
    "title": "Day 3",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_table(\"../input/day03.txt\", col_names = \"str\")",
    "crumbs": [
      "2022",
      "Day 3"
    ]
  },
  {
    "objectID": "2022/R/day03.html#setup",
    "href": "2022/R/day03.html#setup",
    "title": "Day 3",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_table(\"../input/day03.txt\", col_names = \"str\")",
    "crumbs": [
      "2022",
      "Day 3"
    ]
  },
  {
    "objectID": "2022/R/day03.html#part-1",
    "href": "2022/R/day03.html#part-1",
    "title": "Day 3",
    "section": "Part 1",
    "text": "Part 1\n\ninput |&gt;\n  mutate(\n    # Separate each line into two compartments\n    str_length = str_length(str) / 2,\n    str_1 = str_sub(str, start = 1L, end = str_length),\n    str_2 = str_sub(str, start = str_length + 1, end = -1L),\n\n    # Find the letter in common between each pair of compartments\n    across(c(str_1, str_2), ~ str_split(.x, \"\")),\n    dup = map2_chr(str_1, str_2, ~ intersect(.x, .y)),\n\n    # Convert to priority value\n    priority = match(dup, c(letters, LETTERS))\n  ) |&gt;\n\n  # Compute total sum\n  pull(priority) |&gt;\n  sum()",
    "crumbs": [
      "2022",
      "Day 3"
    ]
  },
  {
    "objectID": "2022/R/day03.html#part-2",
    "href": "2022/R/day03.html#part-2",
    "title": "Day 3",
    "section": "Part 2",
    "text": "Part 2\n\ninput |&gt;\n\n  # Reshape to one row per group, one column per elf\n  mutate(\n    str = str_split(str, \"\"),\n    group_num = floor((row_number() - 1) / 3),\n    elf_num = as.character(row_number() %% 3)\n  ) |&gt;\n  pivot_wider(names_from = elf_num, values_from = str, names_prefix = \"elf_\") |&gt;\n\n  # Find the character in common between all 3 elves & convert to priority val\n  mutate(\n    dup = pmap_chr(\n      list(elf_0, elf_1, elf_2),\n      ~ reduce(list(..1, ..2, ..3), intersect)\n    ),\n    priority = match(dup, c(letters, LETTERS))\n  ) |&gt;\n\n  # Compute total sum\n  pull(priority) |&gt;\n  sum()",
    "crumbs": [
      "2022",
      "Day 3"
    ]
  },
  {
    "objectID": "2022/R/day01.html",
    "href": "2022/R/day01.html",
    "title": "Day 1",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day01.txt\") |&gt; \n  as.integer()",
    "crumbs": [
      "2022",
      "Day 1"
    ]
  },
  {
    "objectID": "2022/R/day01.html#setup",
    "href": "2022/R/day01.html#setup",
    "title": "Day 1",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day01.txt\") |&gt; \n  as.integer()",
    "crumbs": [
      "2022",
      "Day 1"
    ]
  },
  {
    "objectID": "2022/R/day01.html#part-1",
    "href": "2022/R/day01.html#part-1",
    "title": "Day 1",
    "section": "Part 1",
    "text": "Part 1\n\n# Format input as a data frame and number the elves\ndf &lt;- tibble(\n  cal = input,\n  elf_id = cumsum(is.na(cal)) + 1\n) |&gt;\n  filter(!is.na(cal))\n\n# Compute calorie sum for each elf, get the top n elves, and combine totals\ncount_max &lt;- function(df, num_top_elves) {\n  df |&gt; \n    group_by(elf_id) |&gt;\n    summarize(total_cal = sum(cal)) |&gt;\n    slice_max(total_cal, n = num_top_elves) |&gt;\n    pull(total_cal) |&gt;\n    sum()\n}\n\nRun puzzle input:\n\ncount_max(df, 1)",
    "crumbs": [
      "2022",
      "Day 1"
    ]
  },
  {
    "objectID": "2022/R/day01.html#part-2",
    "href": "2022/R/day01.html#part-2",
    "title": "Day 1",
    "section": "Part 2",
    "text": "Part 2\n\ncount_max(df, 3)",
    "crumbs": [
      "2022",
      "Day 1"
    ]
  },
  {
    "objectID": "2022/R/day25.html",
    "href": "2022/R/day25.html",
    "title": "Day 25",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day25.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 25"
    ]
  },
  {
    "objectID": "2022/R/day25.html#setup",
    "href": "2022/R/day25.html#setup",
    "title": "Day 25",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day25.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 25"
    ]
  },
  {
    "objectID": "2022/R/day25.html#part-1",
    "href": "2022/R/day25.html#part-1",
    "title": "Day 25",
    "section": "Part 1",
    "text": "Part 1\nConvert “snafu” strings to decimal numbers:\n\nsnafu_to_dbl &lt;- function(snafu) {\n  snafu |&gt; \n    str_split(\"\") |&gt; \n    map(~ case_match(rev(.x), \"2\" ~ 2, \"1\" ~ 1, \"0\" ~ 0, \"-\" ~ -1, \"=\" ~ -2)) |&gt; \n    map(~ .x * 5^(0:(length(.x) - 1))) |&gt; \n    map_dbl(sum)\n}\n\nConvert decimal numbers to “snafu” strings:\n\ndbl_to_snafu &lt;- function(x) {\n  output &lt;- c()\n\n  repeat {\n    output &lt;- c((x + 2) %% 5 - 2, output)\n    x &lt;- floor((x + 2) / 5)\n    \n    if (x == 0) break\n  }\n  \n  output |&gt; \n    case_match(2 ~ '2', 1 ~ '1', 0 ~ '0', -1 ~ '-', -2 ~ '=') |&gt; \n    str_c(collapse = \"\")\n}\n\nRun on puzzle input:\n\ninput |&gt; \n  snafu_to_dbl() |&gt; \n  sum() |&gt; \n  dbl_to_snafu()",
    "crumbs": [
      "2022",
      "Day 25"
    ]
  },
  {
    "objectID": "2022/R/day18.html",
    "href": "2022/R/day18.html",
    "title": "Day 18",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day18.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\"{x},{y},{z}\", convert = TRUE) |&gt; \n  mutate(id = row_number(), .before = everything())",
    "crumbs": [
      "2022",
      "Day 18"
    ]
  },
  {
    "objectID": "2022/R/day18.html#setup",
    "href": "2022/R/day18.html#setup",
    "title": "Day 18",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day18.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\"{x},{y},{z}\", convert = TRUE) |&gt; \n  mutate(id = row_number(), .before = everything())",
    "crumbs": [
      "2022",
      "Day 18"
    ]
  },
  {
    "objectID": "2022/R/day18.html#part-1",
    "href": "2022/R/day18.html#part-1",
    "title": "Day 18",
    "section": "Part 1",
    "text": "Part 1\nCreate a containing box for the set of cubes, padded by 1 voxel of air in each direction, and convert the full rectangular area into a graph:\n\nxrange &lt;- (min(input$x) - 1):(max(input$x) + 1)\nyrange &lt;- (min(input$y) - 1):(max(input$y) + 1)\nzrange &lt;- (min(input$z) - 1):(max(input$z) + 1)\n\n# Fill out each coordinate of the containing box with air\ncontainer &lt;- input |&gt; \n  mutate(type = \"cube\") |&gt; \n  complete(x = xrange, y = yrange, z = zrange, fill = list(type = \"air\")) |&gt; \n  mutate(id = row_number())\n\n# For each coordinate, create edges between adjacent coords of the same type\nedges &lt;- container |&gt;\n  arrange(x, y, z) |&gt; \n  mutate(\n    edge_x1 = case_when(type == lag(type)  ~ lag(id)),\n    edge_x2 = case_when(type == lead(type) ~ lead(id)),\n    .by = c(y, z)\n  ) |&gt; \n  mutate(\n    edge_y1 = case_when(type == lag(type)  ~ lag(id)),\n    edge_y2 = case_when(type == lead(type) ~ lead(id)),\n    .by = c(x, z)\n  ) |&gt; \n  mutate(\n    edge_z1 = case_when(type == lag(type)  ~ lag(id)),\n    edge_z2 = case_when(type == lead(type) ~ lead(id)),\n    .by = c(x, y)\n  ) |&gt; \n  mutate(across(starts_with(\"edge\"), \\(col) {\n    case_when(!is.na(col) ~ map2(id, col, ~ c(.x, .y)))\n  })) |&gt; \n  select(starts_with(\"edge\")) |&gt; \n  pivot_longer(everything()) |&gt; \n  pull(value) |&gt; \n  unlist()\n\n\n# Convert to a graph\ng &lt;- make_graph(edges = edges, n = max(container$id), directed = TRUE) |&gt; \n  as_undirected()\n\nCompute the surface area of the cubes. Start by giving every cube a surface area of 6, then subtract the cube’s vertex degree (which is the number of adjacent cubes):\n\n# Get the vertex IDs of all cubes\ncube_ids &lt;- container |&gt; \n  filter(type == \"cube\") |&gt; \n  pull(id)\n\n# Compute the surface area of all cubes\ng |&gt; \n  degree() |&gt; \n  keep_at(cube_ids) |&gt; \n  map_dbl(~ 6 - .x) |&gt; \n  sum()",
    "crumbs": [
      "2022",
      "Day 18"
    ]
  },
  {
    "objectID": "2022/R/day18.html#part-2",
    "href": "2022/R/day18.html#part-2",
    "title": "Day 18",
    "section": "Part 2",
    "text": "Part 2\nTo compute the external surface area, we compute the total surface area of the outermost containing box of air, then subtract away its known rectangular external surface area.\n\n# First vertex is external air padding, so we pull all vertices having its group\noutside_ids &lt;- which(components(g)$membership == components(g)$membership[1])\n\n# Compute the surface area of the external air voxels using their vertex degree\ntotal_sa &lt;- g |&gt; \n  degree() |&gt; \n  keep_at(outside_ids) |&gt; \n  map_dbl(~ 6 - .x) |&gt; \n  sum()\n\n# Compute the outer surface of the bounding box\nxlen &lt;- max(xrange) - min(xrange) + 1\nylen &lt;- max(yrange) - min(yrange) + 1\nzlen &lt;- max(zrange) - min(zrange) + 1\nbounding_sa &lt;- 2 * (xlen * ylen + xlen * zlen + ylen * zlen)\n\n# Subtract the outer surface area from the total surface area of the air padding\ntotal_sa - bounding_sa",
    "crumbs": [
      "2022",
      "Day 18"
    ]
  },
  {
    "objectID": "2022/R/day23.html",
    "href": "2022/R/day23.html",
    "title": "Day 23",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day23.txt\", skip_empty_rows = TRUE) |&gt; \n  enframe(name = \"row\") |&gt; \n  mutate(value = map(value, ~ enframe(str_split_1(.x, \"\"), name = \"col\"))) |&gt; \n  unnest(value)",
    "crumbs": [
      "2022",
      "Day 23"
    ]
  },
  {
    "objectID": "2022/R/day23.html#setup",
    "href": "2022/R/day23.html#setup",
    "title": "Day 23",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day23.txt\", skip_empty_rows = TRUE) |&gt; \n  enframe(name = \"row\") |&gt; \n  mutate(value = map(value, ~ enframe(str_split_1(.x, \"\"), name = \"col\"))) |&gt; \n  unnest(value)",
    "crumbs": [
      "2022",
      "Day 23"
    ]
  },
  {
    "objectID": "2022/R/day23.html#part-1",
    "href": "2022/R/day23.html#part-1",
    "title": "Day 23",
    "section": "Part 1",
    "text": "Part 1\nConvert map to a list of positions for each elf, using complex numbers to store 2D coords:\n\nelves &lt;- input |&gt; \n  filter(value == \"#\") |&gt; \n  mutate(z = complex(real = col, imaginary = row)) |&gt; \n  pull(z)\n\nDefine function to move elves in each round:\n\ncardinal_dirs &lt;- c(\n  n  =  0 - 1i,\n  s  =  0 + 1i,\n  w  = -1 + 0i,\n  e  =  1 + 0i,\n  nw = -1 - 1i,\n  ne =  1 - 1i,\n  sw = -1 + 1i,\n  se =  1 + 1i\n)\n\nadjacent_dirs &lt;- list(\n  n = c(\"n\", \"nw\", \"ne\"),\n  s = c(\"s\", \"sw\", \"se\"),\n  w = c(\"w\", \"nw\", \"sw\"),\n  e = c(\"e\", \"ne\", \"se\")\n)\n\nmove_elves &lt;- function(elves, round_num) {\n\n  # Determine which neighboring cells are occupied\n  neighbors &lt;- map(cardinal_dirs, \\(dir) elves + dir)\n  occupied  &lt;- map(neighbors, ~ .x %in% elves)\n  \n  # Determine which n/s/w/e moves are valid\n  valid &lt;- map(adjacent_dirs, \\(dir_set) {\n    dir_set |&gt; \n      map(~!occupied[[.x]]) |&gt; \n      reduce(`&`)\n  })\n  \n  # Re-order the n/s/w/e priority according to the current round number\n  valid &lt;- valid[(1:4 + round_num - 2) %% 4 + 1]\n  \n  # For all elves not surrounded by empty cells, determine their proposed move\n  all_borders_empty &lt;- reduce(valid, `&`)\n  proposals &lt;- valid |&gt; \n    imap(\\(vec, dir) case_when(vec ~ neighbors[[dir]])) |&gt;\n    pmap(\n      ~ c(discard(c(..1, ..2, ..3, ..4), is.na), NA) |&gt; \n        head(1)\n    ) |&gt; \n    unlist() |&gt; \n    modify_if(all_borders_empty, ~ NA)\n  \n  # Nullify any colliding proposed moves\n  collisions &lt;- na.omit(proposals)[duplicated(na.omit(proposals))]\n  movements &lt;- if_else(proposals %in% collisions, NA, proposals)\n  \n  # Return the new elf coordinates\n  coalesce(movements, elves)\n}\n\nDefine a function to compute the area of the bounding box then subtract away the number of elves:\n\nn_empty_tiles &lt;- function(elves) {\n  height &lt;- 1 + diff(range(Im(elves)))\n  width  &lt;- 1 + diff(range(Re(elves)))\n  \n  height * width - length(elves)\n}\n\nRun 10 rounds on puzzle input:\n\nreduce(1:10, move_elves, .init = elves) |&gt; \n  n_empty_tiles()",
    "crumbs": [
      "2022",
      "Day 23"
    ]
  },
  {
    "objectID": "2022/R/day23.html#part-2",
    "href": "2022/R/day23.html#part-2",
    "title": "Day 23",
    "section": "Part 2",
    "text": "Part 2\nRun until no further movements occur:\n\ni &lt;- 1\ncur_elves &lt;- elves\n\nrepeat {\n  new_elves &lt;- move_elves(cur_elves, i)\n  \n  if (all(new_elves == cur_elves)) break\n  \n  cur_elves &lt;- new_elves\n  i &lt;- i + 1\n}\n\ni",
    "crumbs": [
      "2022",
      "Day 23"
    ]
  },
  {
    "objectID": "2022/R/day08.html",
    "href": "2022/R/day08.html",
    "title": "Day 8",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file and format as a matrix\ninput &lt;- read_fwf(\"../input/day08.txt\") |&gt; \n  transmute(x = str_split(X1, \"\")) |&gt;\n  unnest_wider(x, names_sep = \"\") |&gt;\n  mutate(across(everything(), as.integer)) |&gt;\n  as.matrix()",
    "crumbs": [
      "2022",
      "Day 8"
    ]
  },
  {
    "objectID": "2022/R/day08.html#setup",
    "href": "2022/R/day08.html#setup",
    "title": "Day 8",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file and format as a matrix\ninput &lt;- read_fwf(\"../input/day08.txt\") |&gt; \n  transmute(x = str_split(X1, \"\")) |&gt;\n  unnest_wider(x, names_sep = \"\") |&gt;\n  mutate(across(everything(), as.integer)) |&gt;\n  as.matrix()",
    "crumbs": [
      "2022",
      "Day 8"
    ]
  },
  {
    "objectID": "2022/R/day08.html#parts-1-2",
    "href": "2022/R/day08.html#parts-1-2",
    "title": "Day 8",
    "section": "Parts 1 & 2",
    "text": "Parts 1 & 2\n\n# Create df with one row per tree and variables for its containing row & col\nexpand_grid(\n  col_pos = 1:nrow(input),\n  row_pos = 1:ncol(input)\n) |&gt;\n  mutate(\n    tree_idx = row_number(),\n    row_list = map(col_pos, ~ unname(as.matrix(input)[.x, ])),\n    col_list = map(row_pos, ~ unname(as.matrix(input)[, .x])),\n  ) |&gt;\n\n  # For each tree, construct its treeline looking outward in each direction\n  pivot_longer(\n    c(col_pos, row_pos, col_list, row_list),\n    names_to = c(\"axis\", \".value\"),\n    names_sep = \"_\"\n  ) |&gt;\n  mutate(\n    split = map2(\n      list,\n      pos,\n      ~ split(.x, c(rep(\"bwd\", .y - 1), \"curr_tree\", rep(\"fwd\", length(.x) - .y)))\n    )\n  ) |&gt;\n  unnest_wider(split) |&gt;\n  mutate(bwd = map(bwd, rev)) |&gt;\n  pivot_longer(c(fwd, bwd), names_to = \"dir\", values_to = \"treeline\") |&gt;\n\n  # Check if each is the tallest tree in each direction & count visible trees\n  mutate(\n    is_tallest = map2_lgl(curr_tree, treeline, ~ all(.x &gt; .y)),\n    num_visible = map2_int(curr_tree, treeline, function(curr_tree, treeline) {\n      ifelse(\n        every(treeline, ~.x &lt; curr_tree),\n        length(treeline),\n        detect_index(treeline, ~ .x &gt;= curr_tree)\n      )\n    })\n  ) |&gt;\n\n  # Summarize visibility & scenic scores from all 4 directions for each tree\n  group_by(tree_idx) |&gt;\n  summarize(\n    is_visible = any(is_tallest),\n    scenic_score = prod(num_visible)\n  ) |&gt;\n  ungroup() |&gt;\n\n  # Compute total trees visible from forest edge & max scenic score in forest\n  summarize(\n    total_visible = sum(is_visible),\n    max_scenic_score = max(scenic_score)\n  )",
    "crumbs": [
      "2022",
      "Day 8"
    ]
  },
  {
    "objectID": "2022/R/day21.html",
    "href": "2022/R/day21.html",
    "title": "Day 21",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day21.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\n    patterns = c(\n      \"{monkey}: {input_1} {operation} {input_2}\",\n      \"{monkey}: {number}\"\n    ),\n    convert = TRUE\n  )",
    "crumbs": [
      "2022",
      "Day 21"
    ]
  },
  {
    "objectID": "2022/R/day21.html#setup",
    "href": "2022/R/day21.html#setup",
    "title": "Day 21",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day21.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\n    patterns = c(\n      \"{monkey}: {input_1} {operation} {input_2}\",\n      \"{monkey}: {number}\"\n    ),\n    convert = TRUE\n  )",
    "crumbs": [
      "2022",
      "Day 21"
    ]
  },
  {
    "objectID": "2022/R/day21.html#part-1",
    "href": "2022/R/day21.html#part-1",
    "title": "Day 21",
    "section": "Part 1",
    "text": "Part 1\nIteratively apply each monkey-to-monnkey operation until complete:\n\nnumbers &lt;- input |&gt; \n  select(monkey, number) |&gt; \n  deframe()\n\neqns &lt;- input |&gt; \n  filter(!is.na(operation)) |&gt; \n  select(-number)\n\ncompute_monkeys &lt;- function(numbers, eqns) {\n  repeat {\n    new_values &lt;- eqns |&gt; \n      mutate(\n        value_1 = numbers[input_1],\n        value_2 = numbers[input_2]\n      ) |&gt; \n      drop_na(value_1, value_2) |&gt; \n      mutate(output = pmap_dbl(\n        list(operation, value_1, value_2), \n        ~ get(..1)(..2, ..3)\n      )) |&gt; \n      select(monkey, output) |&gt; \n      deframe()\n    \n    if (length(new_values) == 0) {\n      break\n    } else {\n      numbers[names(new_values)] &lt;- new_values\n      eqns &lt;- filter(eqns, !(monkey %in% names(new_values)))\n    }\n  }\n  \n  numbers\n}\n\nRun on puzzle input:\n\ncompute_monkeys(numbers, eqns) |&gt; \n  keep_at(\"root\") |&gt;  \n  format(scientific = FALSE)",
    "crumbs": [
      "2022",
      "Day 21"
    ]
  },
  {
    "objectID": "2022/R/day21.html#part-2",
    "href": "2022/R/day21.html#part-2",
    "title": "Day 21",
    "section": "Part 2",
    "text": "Part 2\n\n# Replace 'humn' number with NA and re-compute known equation values\nmodified_numbers &lt;- compute_monkeys(\n  modify_at(numbers, \"humn\", ~ NA),\n  mutate(eqns, operation = if_else(monkey == \"root\", \"==\", operation))\n)\n\nmonkey_funcs &lt;- eqns |&gt; \n  \n  # Reformat equations\n  mutate(operation = if_else(monkey == \"root\", \"==\", operation)) |&gt; \n  mutate(\n    value_1 = modified_numbers[input_1], \n    value_2 = modified_numbers[input_2],\n    const = unname(coalesce(value_1, value_2)),\n    xposn = if_else(is.na(value_1), 1, 2),\n    input = if_else(is.na(value_1), input_1, input_2),\n  ) |&gt; \n  filter(is.na(value_1) | is.na(value_2)) |&gt; \n  \n  # Convert each operation into an inverse function\n  mutate(\n    f = pmap(list(operation, const, xposn), \\(op, const, xposn) {\n      if (op == \"+\")                   partial(`-`, ... = , const)\n      else if (op == \"*\")              partial(`/`, ... = , const)\n      else if (op == \"-\" & xposn == 1) partial(`+`, ... = , const)\n      else if (op == \"/\" & xposn == 1) partial(`*`, ... = , const)\n      else if (op == \"-\" & xposn == 2) partial(`-`, const, ... = )\n      else if (op == \"/\" & xposn == 2) partial(`/`, const, ... = )\n    }),\n  ) |&gt; \n  select(output = monkey, f, input, const)\n\n# Initiate starting monkey value at the root monkey\ncur_monkey  &lt;- filter(monkey_funcs, output == \"root\")\ncur_value   &lt;- cur_monkey$const\nnext_monkey &lt;- cur_monkey$input\n\n# Compute function inverse for each monkey until \"humn\" is reached\nwhile (next_monkey != \"humn\") {\n  cur_monkey  &lt;- filter(monkey_funcs, output == next_monkey)\n  cur_value   &lt;- cur_monkey$f[[1]](cur_value)\n  next_monkey &lt;- cur_monkey$input\n}\n\n# View final input needed to achieve equality\ncur_value |&gt; \n  format(scientific = FALSE)",
    "crumbs": [
      "2022",
      "Day 21"
    ]
  },
  {
    "objectID": "2025/R/day04.html",
    "href": "2025/R/day04.html",
    "title": "Day 4",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file into a matrix:\n\ninput &lt;- read_lines(\"../input/day04.txt\") |&gt;\n  str_split(\"\") |&gt; \n  enframe(name = NULL) |&gt; \n  unnest_wider(value, names_sep = \"\") |&gt; \n  as.matrix() |&gt; \n  unname()",
    "crumbs": [
      "2025",
      "Day 4"
    ]
  },
  {
    "objectID": "2025/R/day04.html#setup",
    "href": "2025/R/day04.html#setup",
    "title": "Day 4",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file into a matrix:\n\ninput &lt;- read_lines(\"../input/day04.txt\") |&gt;\n  str_split(\"\") |&gt; \n  enframe(name = NULL) |&gt; \n  unnest_wider(value, names_sep = \"\") |&gt; \n  as.matrix() |&gt; \n  unname()",
    "crumbs": [
      "2025",
      "Day 4"
    ]
  },
  {
    "objectID": "2025/R/day04.html#part-1",
    "href": "2025/R/day04.html#part-1",
    "title": "Day 4",
    "section": "Part 1",
    "text": "Part 1\nDefine a function to shift a matrix up, down, left, or right:\n\nshift &lt;- function(mtx, dir = c(\"up\", \"down\", \"left\", \"right\"), ...) {\n  switch(dir,\n    \"up\"    = mtx |&gt; lead(...),\n    \"down\"  = mtx |&gt; lag(...),\n    \"left\"  = mtx |&gt; t() |&gt; lead(...) |&gt; t(),\n    \"right\" = mtx |&gt; t() |&gt; lag(...)  |&gt; t()\n  )\n}\n\nDefine a function which, for each cell in the matrix, counts how many of its 8 immediate neighbors match a given value:\n\ncount_nbrs &lt;- function(mtx, value) {\n  list(\n    mtx |&gt; shift(\"up\",    default = \".\"),\n    mtx |&gt; shift(\"down\",  default = \".\"),\n    mtx |&gt; shift(\"left\",  default = \".\"),\n    mtx |&gt; shift(\"right\", default = \".\"),\n    mtx |&gt; shift(\"up\",    default = \".\") |&gt; shift(\"left\",  default = \".\"),\n    mtx |&gt; shift(\"up\",    default = \".\") |&gt; shift(\"right\", default = \".\"),\n    mtx |&gt; shift(\"down\",  default = \".\") |&gt; shift(\"left\",  default = \".\"),\n    mtx |&gt; shift(\"down\",  default = \".\") |&gt; shift(\"right\", default = \".\")\n  ) |&gt; \n    map(\\(x) x == value) |&gt; \n    reduce(`+`)\n}\n\nCount how many rolls in the input have less than 4 neighboring rolls:\n\nsum(input == '@' & count_nbrs(input, '@') &lt; 4)",
    "crumbs": [
      "2025",
      "Day 4"
    ]
  },
  {
    "objectID": "2025/R/day04.html#part-2",
    "href": "2025/R/day04.html#part-2",
    "title": "Day 4",
    "section": "Part 2",
    "text": "Part 2\nIteratively remove rolls until no more removals are possible:\n\ncur &lt;- input\n\nrepeat {\n  prv &lt;- cur\n  cur[cur == '@' & count_nbrs(cur, '@') &lt; 4] &lt;- \".\"\n  if (all(prv == cur))\n    break\n}\n\nfnl &lt;- cur\n\nCount how many rolls were removed:\n\nsum(input == \"@\") - sum(fnl == \"@\")",
    "crumbs": [
      "2025",
      "Day 4"
    ]
  },
  {
    "objectID": "2025/R/day07.html",
    "href": "2025/R/day07.html",
    "title": "Day 7",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nDisable scientific notation to display all digits of large numbers:\n\noptions(scipen = 999)\n\nRead text input from file into a data frame of characters with row & column positions:\n\ninput &lt;- read_lines(\"../input/day07.txt\") |&gt; \n  str_split(\"\") |&gt; \n  map(enframe, name = \"col\") |&gt; \n  list_rbind(names_to = \"row\") |&gt; \n  filter(value != \".\") |&gt; \n  arrange(value != \"S\") |&gt; \n  mutate(id = row_number(), .before = everything())",
    "crumbs": [
      "2025",
      "Day 7"
    ]
  },
  {
    "objectID": "2025/R/day07.html#setup",
    "href": "2025/R/day07.html#setup",
    "title": "Day 7",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nDisable scientific notation to display all digits of large numbers:\n\noptions(scipen = 999)\n\nRead text input from file into a data frame of characters with row & column positions:\n\ninput &lt;- read_lines(\"../input/day07.txt\") |&gt; \n  str_split(\"\") |&gt; \n  map(enframe, name = \"col\") |&gt; \n  list_rbind(names_to = \"row\") |&gt; \n  filter(value != \".\") |&gt; \n  arrange(value != \"S\") |&gt; \n  mutate(id = row_number(), .before = everything())",
    "crumbs": [
      "2025",
      "Day 7"
    ]
  },
  {
    "objectID": "2025/R/day07.html#part-1",
    "href": "2025/R/day07.html#part-1",
    "title": "Day 7",
    "section": "Part 1",
    "text": "Part 1\nIterate through the rows of the input, tracking the current beam locations at each step, counting when a beam splits, and tracking how many timelines (for part 2) have been created so far:\n\nncol  &lt;- max(input$col) + 1\nbeams &lt;- rep(FALSE, ncol) |&gt; replace(input$col[input$value == \"S\"], TRUE)\ntimelines &lt;- as.numeric(beams)\nnsplit &lt;- 0\n\nfor (row_num in unique(input$row[-1])) {\n  \n  split &lt;- input |&gt; \n    filter(row == row_num) |&gt; \n    pull(col) |&gt; \n    keep(\\(x) beams[x] == TRUE)\n  \n  newbeams &lt;- unique(c(split - 1, split + 1))\n  \n  beams[split] &lt;- FALSE\n  beams[newbeams] &lt;- TRUE\n  \n  timelines[split - 1] &lt;- timelines[split - 1] + timelines[split]\n  timelines[split + 1] &lt;- timelines[split + 1] + timelines[split]\n  timelines[split] &lt;- 0\n  \n  nsplit &lt;- nsplit + length(split)\n  \n}\n\nCount the total number of splits that occurred:\n\nnsplit",
    "crumbs": [
      "2025",
      "Day 7"
    ]
  },
  {
    "objectID": "2025/R/day07.html#part-2",
    "href": "2025/R/day07.html#part-2",
    "title": "Day 7",
    "section": "Part 2",
    "text": "Part 2\nCount the total timelines created:\n\nsum(timelines)",
    "crumbs": [
      "2025",
      "Day 7"
    ]
  },
  {
    "objectID": "2025/R/day02.html",
    "href": "2025/R/day02.html",
    "title": "Day 2",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file into a set of start/end values:\n\ninput &lt;- read_lines(\"../input/day02.txt\") |&gt; \n  str_split_1(\",\") |&gt; \n  unglue_data(\"{start}-{end}\", convert = TRUE)",
    "crumbs": [
      "2025",
      "Day 2"
    ]
  },
  {
    "objectID": "2025/R/day02.html#setup",
    "href": "2025/R/day02.html#setup",
    "title": "Day 2",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file into a set of start/end values:\n\ninput &lt;- read_lines(\"../input/day02.txt\") |&gt; \n  str_split_1(\",\") |&gt; \n  unglue_data(\"{start}-{end}\", convert = TRUE)",
    "crumbs": [
      "2025",
      "Day 2"
    ]
  },
  {
    "objectID": "2025/R/day02.html#part-1",
    "href": "2025/R/day02.html#part-1",
    "title": "Day 2",
    "section": "Part 1",
    "text": "Part 1\nUse regex to match all instances of single-repeated substrings within the range of integers:\n\ninput |&gt; \n  with(map2(start, end, seq)) |&gt; \n  unlist() |&gt; \n  keep(\\(x) str_detect(x, \"^(.+)\\\\1$\")) |&gt; \n  sum()",
    "crumbs": [
      "2025",
      "Day 2"
    ]
  },
  {
    "objectID": "2025/R/day02.html#part-2",
    "href": "2025/R/day02.html#part-2",
    "title": "Day 2",
    "section": "Part 2",
    "text": "Part 2\nAlter the regex from ^(.+)\\\\1$ to ^(.+)\\\\1+$ to allow any number of repeated matches (not just one):\n\ninput |&gt; \n  with(map2(start, end, seq)) |&gt; \n  unlist() |&gt; \n  keep(\\(x) str_detect(x, \"^(.+)\\\\1+$\")) |&gt; \n  sum()",
    "crumbs": [
      "2025",
      "Day 2"
    ]
  },
  {
    "objectID": "2025/R/day01.html",
    "href": "2025/R/day01.html",
    "title": "Day 1",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day01.txt\")\n\nConvert text input into a vector of positive (R) or negative (L) rotation integers:\n\nrotation &lt;- input |&gt; \n  unglue_data(\"{dir=L|R}{num=\\\\d+}\", convert = TRUE) |&gt; \n  mutate(num = case_match(dir, \"R\" ~ num, \"L\" ~ -num)) |&gt; \n  pull(num)",
    "crumbs": [
      "2025",
      "Day 1"
    ]
  },
  {
    "objectID": "2025/R/day01.html#setup",
    "href": "2025/R/day01.html#setup",
    "title": "Day 1",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day01.txt\")\n\nConvert text input into a vector of positive (R) or negative (L) rotation integers:\n\nrotation &lt;- input |&gt; \n  unglue_data(\"{dir=L|R}{num=\\\\d+}\", convert = TRUE) |&gt; \n  mutate(num = case_match(dir, \"R\" ~ num, \"L\" ~ -num)) |&gt; \n  pull(num)",
    "crumbs": [
      "2025",
      "Day 1"
    ]
  },
  {
    "objectID": "2025/R/day01.html#part-1",
    "href": "2025/R/day01.html#part-1",
    "title": "Day 1",
    "section": "Part 1",
    "text": "Part 1\nStarting from 50, apply all rotations in sequence as additions modulo 100:\n\ndial &lt;- accumulate(rotation, .f = \\(x, y) (x + y) %% 100, .init = 50)\n\nCount the number of zeroes in the resulting sequence:\n\nsum(dial == 0)",
    "crumbs": [
      "2025",
      "Day 1"
    ]
  },
  {
    "objectID": "2025/R/day01.html#part-2",
    "href": "2025/R/day01.html#part-2",
    "title": "Day 1",
    "section": "Part 2",
    "text": "Part 2\nUsing the dial’s starting position for each turn as calculated in part 1, additionally determine how many times 0 is passed in each turn.\nIf the rotation is positive (R direction), we can sum the rotation and the starting value and count how many times the result is divisible by 100 (integer division). If the rotation is negative (L direction), we convert the negative to a symmetrical positive rotation, starting instead at the modular complement of the dial’s starting position.\nFor example, starting at 1 and rotating left twice is equivalent to starting at 99 and rotating right twice (only in terms of the number of passes over zero).\n\ndial_start &lt;- head(dial, -1)\nnum_passes &lt;- (((sign(rotation) * dial_start) %% 100) + abs(rotation)) %/% 100\n\nCount the total times zero is passed:\n\nsum(num_passes)",
    "crumbs": [
      "2025",
      "Day 1"
    ]
  },
  {
    "objectID": "2024/R/day10.html",
    "href": "2024/R/day10.html",
    "title": "Day 10",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead plaintext input from file:\n\ninput &lt;- read_lines(\"../input/day10.txt\")\n\nConvert text input into a numeric matrix:\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt;\n  unlist() |&gt; \n  as.integer() |&gt; \n  matrix(nrow = length(input), byrow = TRUE)",
    "crumbs": [
      "2024",
      "Day 10"
    ]
  },
  {
    "objectID": "2024/R/day10.html#setup",
    "href": "2024/R/day10.html#setup",
    "title": "Day 10",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead plaintext input from file:\n\ninput &lt;- read_lines(\"../input/day10.txt\")\n\nConvert text input into a numeric matrix:\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt;\n  unlist() |&gt; \n  as.integer() |&gt; \n  matrix(nrow = length(input), byrow = TRUE)",
    "crumbs": [
      "2024",
      "Day 10"
    ]
  },
  {
    "objectID": "2024/R/day10.html#part-1",
    "href": "2024/R/day10.html#part-1",
    "title": "Day 10",
    "section": "Part 1",
    "text": "Part 1\nDefine cardinal directions (N/S/E/W) as a list of 2D vectors:\n\ndirs &lt;- list(c(0, 1), c(0, -1), c(1, 0), c(-1, 0))\n\nDefine a helper function to determine if a coordinate is within the map bounds:\n\nin_bounds &lt;- \\(x, map) between(x[1], 1, nrow(map)) & between(x[2], 1, ncol(map))\n\nDefine a function to find the trail ends given a map and a starting coordinate:\n\nfind_trail_ends &lt;- function(cur_coord, map) {\n  \n  # If the trailhead has been reached, return its coordinate.\n  if (map[cur_coord] == 9)\n    return(list(cur_coord))\n  \n  # Define the possible next steps within the map bounds\n  next_steps &lt;- dirs |&gt; \n    map(~ cur_coord + .x) |&gt; \n    keep(~ in_bounds(.x, map))\n  \n  trail_ends &lt;- list()\n  \n  # If the next step leads to a valid path, add its terminal to the list\n  for (next_coord in next_steps) {\n    if (map[next_coord] == map[cur_coord] + 1) \n      trail_ends &lt;- c(trail_ends, find_trail_ends(next_coord, map))\n  }\n  \n  return(unique(trail_ends))\n}\n\nDefine a function to score a trail given the map and trailhead:\n\nscore_trail &lt;- \\(trailhead, map) length(find_trail_ends(trailhead, map))\n\nGet a list of coordinates of all of the trailheads:\n\ntrailheads &lt;- which(mtx == 0, arr.ind = TRUE)\n\ntrailheads_list &lt;- map(\n  1:nrow(trailheads), \n  ~ array(trailheads[.x,], dim = c(1, 2))\n)\n\nScore each trailhead and sum the total:\n\ntrailheads_list |&gt; \n  map_int(~ score_trail(.x, mtx)) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 10"
    ]
  },
  {
    "objectID": "2024/R/day10.html#part-2",
    "href": "2024/R/day10.html#part-2",
    "title": "Day 10",
    "section": "Part 2",
    "text": "Part 2\nModify the trail rating function:\n\nrate_trail &lt;- function(cur_coord, map) {\n  # If the trailhead has been reached, increment the score and exit.\n  if (map[cur_coord] == 9)\n    return(1)\n  \n  # Define the possible next steps within the map bounds\n  next_steps &lt;- dirs |&gt; \n    map(~ cur_coord + .x) |&gt; \n    keep(~ in_bounds(.x, map))\n  \n  # Sum the trail ratings of all valid next steps\n  map_int(\n    next_steps,\n    ~ if (map[.x] == map[cur_coord] + 1) rate_trail(.x, map) else 0\n  ) |&gt; \n    sum()\n}\n\nRe-run on the puzzle input:\n\ntrailheads_list |&gt; \n  map_int(~ rate_trail(.x, mtx)) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 10"
    ]
  },
  {
    "objectID": "2024/R/day05.html",
    "href": "2024/R/day05.html",
    "title": "Day 5",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day05.txt\", skip_empty_rows = TRUE)\n\nExtract the page-ordering rules from the input:\n\nrules &lt;- input |&gt; \n  unglue_data(\"{p1}|{p2}\", convert = TRUE) |&gt; \n  drop_na()\n\nExtract the page sequences from the input:\n\npages &lt;- input |&gt;\n  discard_at(1:nrow(rules)) |&gt; \n  str_split(\",\") |&gt; \n  map(parse_number)",
    "crumbs": [
      "2024",
      "Day 5"
    ]
  },
  {
    "objectID": "2024/R/day05.html#setup",
    "href": "2024/R/day05.html#setup",
    "title": "Day 5",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day05.txt\", skip_empty_rows = TRUE)\n\nExtract the page-ordering rules from the input:\n\nrules &lt;- input |&gt; \n  unglue_data(\"{p1}|{p2}\", convert = TRUE) |&gt; \n  drop_na()\n\nExtract the page sequences from the input:\n\npages &lt;- input |&gt;\n  discard_at(1:nrow(rules)) |&gt; \n  str_split(\",\") |&gt; \n  map(parse_number)",
    "crumbs": [
      "2024",
      "Day 5"
    ]
  },
  {
    "objectID": "2024/R/day05.html#part-1",
    "href": "2024/R/day05.html#part-1",
    "title": "Day 5",
    "section": "Part 1",
    "text": "Part 1\nDefine a function to sort a given vector of page numbers according to the rules that apply to those page numbers:\n\nsort_by_rules &lt;- function(seq) {\n  active_rules &lt;- rules |&gt; \n    filter(p1 %in% seq & p2 %in% seq)\n  \n  repeat {\n    swap_occurred &lt;- FALSE\n    for (i in 1:nrow(active_rules)) {\n      rule &lt;- filter(active_rules, row_number() == i)\n      idx1 &lt;- which(seq == rule$p1)\n      idx2 &lt;- which(seq == rule$p2)\n      \n      if (idx1 &gt; idx2) {\n        seq[[idx1]] &lt;- rule$p2\n        seq[[idx2]] &lt;- rule$p1\n        swap_occurred &lt;- TRUE\n      }\n    }\n    if (!swap_occurred) \n      return(seq)\n  }\n}\n\nSort all page sequences in the puzzle input and extract the center page of the result:\n\noutput &lt;- pages |&gt; \n  as_tibble_col(column_name = \"update\") |&gt; \n  mutate(\n    resorted = map(update, sort_by_rules),\n    is_sorted = map2_lgl(update, resorted, identical),\n    center_page = map_int(resorted, ~ .x[(length(.x) + 1) / 2])\n  )\n\nFor all properly-ordered updates, sum the center page numbers:\n\noutput |&gt;\n  filter(is_sorted) |&gt; \n  pull(center_page) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 5"
    ]
  },
  {
    "objectID": "2024/R/day05.html#part-2",
    "href": "2024/R/day05.html#part-2",
    "title": "Day 5",
    "section": "Part 2",
    "text": "Part 2\nFor all improperly-ordered updates, sum their sorted center pages\n\noutput |&gt;\n  filter(!is_sorted) |&gt; \n  pull(center_page) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 5"
    ]
  },
  {
    "objectID": "2024/R/day07.html",
    "href": "2024/R/day07.html",
    "title": "Day 7",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead plaintext input from file into a dataframe of target / numeric sequence pairs:\n\ninput &lt;- read_lines(\"../input/day07.txt\") |&gt; \n  unglue_data(\"{target}: {seq}\", convert = TRUE) |&gt; \n  mutate(seq = map(seq, ~ as.numeric(str_split_1(.x, \" \"))))",
    "crumbs": [
      "2024",
      "Day 7"
    ]
  },
  {
    "objectID": "2024/R/day07.html#setup",
    "href": "2024/R/day07.html#setup",
    "title": "Day 7",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead plaintext input from file into a dataframe of target / numeric sequence pairs:\n\ninput &lt;- read_lines(\"../input/day07.txt\") |&gt; \n  unglue_data(\"{target}: {seq}\", convert = TRUE) |&gt; \n  mutate(seq = map(seq, ~ as.numeric(str_split_1(.x, \" \"))))",
    "crumbs": [
      "2024",
      "Day 7"
    ]
  },
  {
    "objectID": "2024/R/day07.html#part-1",
    "href": "2024/R/day07.html#part-1",
    "title": "Day 7",
    "section": "Part 1",
    "text": "Part 1\nDefine a recursive function that explores every combination of operators for a given seq and returns when any path to the target output is found:\n\ncalibrate &lt;- function(seq, target, operators) {\n  \n  # If the end of the list has been reached, check if we hit the target & exit\n  if (length(seq) == 1) \n    return(seq == target)\n  \n  # If the target is already overshot, exit\n  if (seq[1] &gt; target)\n    return(FALSE)\n  \n  # Collapse the first two items in the seq for each operator & recurse\n  map_lgl(operators, \\(f) {\n    new_start &lt;- get(f)(seq[1], seq[2])\n    new_seq &lt;- c(new_start, tail(seq, -2))\n    calibrate_operators(new_seq, target, operators)\n  }) |&gt; \n    # If any output is true, the output has been calibrated.\n    any()\n}\n\nLoop through every seq-target pair to determine which are valid, then sum their outputs:\n\ninput |&gt; \n  filter(map2_lgl(seq, target, ~ calibrate(.x, .y, c(\"+\", \"*\")))) |&gt; \n  pull(target) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 7"
    ]
  },
  {
    "objectID": "2024/R/day07.html#part-2",
    "href": "2024/R/day07.html#part-2",
    "title": "Day 7",
    "section": "Part 2",
    "text": "Part 2\nDefine a new concatenation operator:\n\nconcat &lt;- \\(x, y) as.numeric(str_c(x, y))\n\nRe-run the calibration on the puzzle input with the new concat operator:\n\ninput |&gt; \n  filter(map2_lgl(seq, target, ~ calibrate(.x, .y, c(\"+\", \"*\", \"concat\")))) |&gt; \n  pull(target) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 7"
    ]
  },
  {
    "objectID": "2024/R/day12.html",
    "href": "2024/R/day12.html",
    "title": "Day 12",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(igraph)\n\nRead input from file into a data frame:\n\ninput &lt;- read_table(\"../input/day12.txt\", col_names = \"chr\") |&gt; \n  mutate(\n    row = row_number(),\n    chr = str_split(chr, \"\")\n  ) |&gt; \n  unnest(chr) |&gt; \n  mutate(col = row_number(), .by = row) |&gt; \n  mutate(idx = row_number(), .before = everything())",
    "crumbs": [
      "2024",
      "Day 12"
    ]
  },
  {
    "objectID": "2024/R/day12.html#setup",
    "href": "2024/R/day12.html#setup",
    "title": "Day 12",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(igraph)\n\nRead input from file into a data frame:\n\ninput &lt;- read_table(\"../input/day12.txt\", col_names = \"chr\") |&gt; \n  mutate(\n    row = row_number(),\n    chr = str_split(chr, \"\")\n  ) |&gt; \n  unnest(chr) |&gt; \n  mutate(col = row_number(), .by = row) |&gt; \n  mutate(idx = row_number(), .before = everything())",
    "crumbs": [
      "2024",
      "Day 12"
    ]
  },
  {
    "objectID": "2024/R/day12.html#part-1",
    "href": "2024/R/day12.html#part-1",
    "title": "Day 12",
    "section": "Part 1",
    "text": "Part 1\nFormat the input as a graph, with edges connecting neighbors of the same type:\n\n# Flag neighboring characters of the same value that border one other\nedges_wide &lt;- input |&gt; \n  mutate(v = case_when(row + 1 == lead(row) ~ lead(idx)), .by = c(chr, col)) |&gt; \n  mutate(h = case_when(col + 1 == lead(col) ~ lead(idx)), .by = c(chr, row))\n\nedges_long &lt;- edges_wide |&gt; \n  pivot_longer(\n    c(v, h), \n    names_to = NULL, \n    values_to = \"target\", \n    values_drop_na = TRUE\n  )\n\n# Format neighbors as a list of edges and add to add a graph\ng &lt;- edges_long |&gt; \n  transmute(\n    edge_id = row_number(),\n    src = idx, \n    target\n  ) |&gt; \n  pivot_longer(c(src, target)) |&gt; \n  arrange(edge_id, value) |&gt; \n  pull(value) |&gt; \n  make_graph(n = nrow(input), directed = FALSE)\n\nV(g)$name &lt;- 1:nrow(input)\n\nSeparate out the graph into sub-graphs of innerconnected regions:\n\ndg &lt;- decompose(g)\n\nCompute the perimeter, area, and cost of each subgraph then sum the total:\n\ndg |&gt; \n  map_int(\\(subgraph) {\n    perim &lt;- sum(4 - degree(subgraph))\n    area  &lt;- gorder(subgraph)\n    perim * area\n  }) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 12"
    ]
  },
  {
    "objectID": "2024/R/day12.html#part-2",
    "href": "2024/R/day12.html#part-2",
    "title": "Day 12",
    "section": "Part 2",
    "text": "Part 2\nUsed a hint from reddit: the number of corners is equal to the number of sides.\nA plot can have a convex corner or a concave corner.\n\nA cell has a convex corner for each pair of adjacent borders\nA cell has a concave corner if it has two adjacent cells of its same group, but its diagonal cell between the two has a different group.\n\nGet the original row/column input and join on the group output from the graph:\n\ngroups &lt;- left_join(\n  input,\n  imap_dfr(dg, \\(g, grp_idx) tibble(grp = grp_idx, idx = V(g)$name)),\n  join_by(idx)\n) |&gt; \n  select(idx, grp, row, col)\n\nFor each of a cell’s neighbors, flag if they’re in the same group:\n\nneighbors &lt;- groups |&gt; \n  \n  # Get group number of each adjacent cell (N/S/E/W)\n  left_join(transmute(groups, n = grp, row = row + 1, col), join_by(row, col)) |&gt; \n  left_join(transmute(groups, w = grp, col = col + 1, row), join_by(row, col)) |&gt; \n  left_join(transmute(groups, s = grp, row = row - 1, col), join_by(row, col)) |&gt; \n  left_join(transmute(groups, e = grp, col = col - 1, row), join_by(row, col)) |&gt; \n  \n  # Get group number of each diagonal cell (NW/NE/SW/SE)\n  left_join(\n    transmute(groups, nw = grp, row = row + 1, col = col + 1), \n    join_by(row, col)\n  ) |&gt; \n  left_join(\n    transmute(groups, ne = grp, row = row + 1, col = col - 1), \n    join_by(row, col)\n  ) |&gt; \n  left_join(\n    transmute(groups, sw = grp, row = row - 1, col = col + 1), \n    join_by(row, col)\n  ) |&gt; \n  left_join(\n    transmute(groups, se = grp, row = row - 1, col = col - 1), \n    join_by(row, col)\n  ) |&gt; \n  select(-c(row, col)) |&gt; \n  \n  # Compare group numbers of adjacent/diagonal cells to the current cell\n  mutate(across(c(n, w, s, e, nw, ne, sw, se), ~ replace_na(.x == grp, FALSE)))\n\nCompute the total number of concave/convex corners for each cell:\n\ncorners &lt;- neighbors |&gt; \n  mutate(\n    convex = (!n & !w) + (!s & !w) + (!s & !e) + (!n & !e),\n    concave = (n & w & !nw) + (s & w & !sw) + (s & e & !se) + (n & e & !ne)\n  )\n\nTotal the number of corners per group and multiply by the group’s area to get the total cost:\n\ncorners |&gt; \n  summarize(\n    area = n(),\n    num_sides = sum(convex + concave), \n    .by = grp\n  ) |&gt; \n  mutate(cost = area * num_sides) |&gt; \n  pull(cost) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 12"
    ]
  },
  {
    "objectID": "2024/R/day02.html",
    "href": "2024/R/day02.html",
    "title": "Day 2",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file into a list of numeric vectors:\n\ninput &lt;- read_lines(\"../input/day02.txt\") |&gt; \n  str_split(\" \") |&gt; \n  map(parse_number)",
    "crumbs": [
      "2024",
      "Day 2"
    ]
  },
  {
    "objectID": "2024/R/day02.html#setup",
    "href": "2024/R/day02.html#setup",
    "title": "Day 2",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file into a list of numeric vectors:\n\ninput &lt;- read_lines(\"../input/day02.txt\") |&gt; \n  str_split(\" \") |&gt; \n  map(parse_number)",
    "crumbs": [
      "2024",
      "Day 2"
    ]
  },
  {
    "objectID": "2024/R/day02.html#part-1",
    "href": "2024/R/day02.html#part-1",
    "title": "Day 2",
    "section": "Part 1",
    "text": "Part 1\nDefine a function to determine whether a sequence is valid (all values are increasing or all are decreasing, with integer differences between 1 and 3):\n\nis_valid &lt;- function(seq) {\n  gaps &lt;- head(seq, -1) - tail(seq, -1)\n  (all(gaps &lt; 0) | all(gaps &gt; 0)) & all(abs(gaps) &lt;= 3)\n}\n\nCount the number of safe reports in the puzzle input:\n\ninput |&gt; \n  map_lgl(is_valid) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 2"
    ]
  },
  {
    "objectID": "2024/R/day02.html#part-2",
    "href": "2024/R/day02.html#part-2",
    "title": "Day 2",
    "section": "Part 2",
    "text": "Part 2\nFor each report in the input, create a set of variants where a single level from the report is removed at a time. Then, check the validity of each of these altered reports (and the original) & count how many reports are or can become valid:\n\ninput |&gt; \n  map(\\(seq) c(list(seq), map(1:length(seq), \\(n) discard_at(seq, n)))) |&gt; \n  map_lgl(\\(set) any(map_lgl(set, is_valid))) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 2"
    ]
  },
  {
    "objectID": "2024/R/day17.html",
    "href": "2024/R/day17.html",
    "title": "Day 17",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(bit64)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day17.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue_data(\"{label}: {value}\")",
    "crumbs": [
      "2024",
      "Day 17"
    ]
  },
  {
    "objectID": "2024/R/day17.html#setup",
    "href": "2024/R/day17.html#setup",
    "title": "Day 17",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(bit64)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day17.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue_data(\"{label}: {value}\")",
    "crumbs": [
      "2024",
      "Day 17"
    ]
  },
  {
    "objectID": "2024/R/day17.html#part-1",
    "href": "2024/R/day17.html#part-1",
    "title": "Day 17",
    "section": "Part 1",
    "text": "Part 1\nInitialize the machine from the text input:\n\nprogram &lt;- input |&gt; \n  filter(label == \"Program\") |&gt; \n  pull(value) |&gt; \n  str_split_1(\",\") |&gt; \n  as.integer()\n\nA &lt;- input |&gt; \n  filter(label == \"Register A\") |&gt; \n  pull(value) |&gt; \n  as.integer()\n\nB &lt;- input |&gt; \n  filter(label == \"Register B\") |&gt; \n  pull(value) |&gt; \n  as.integer()\n\nC &lt;- input |&gt; \n  filter(label == \"Register C\") |&gt; \n  pull(value) |&gt; \n  as.integer()\n\nmachine &lt;- list(\n  program = program, \n  A = A, \n  B = B, \n  C = C, \n  pointer = 0L, \n  output = NULL\n)\n\nDefine machine’s helper functions:\n\ncombo &lt;- function(machine, operand) {\n  case_match(operand,\n    0 ~ 0,\n    1 ~ 1,\n    2 ~ 2,\n    3 ~ 3,\n    4 ~ machine$A,\n    5 ~ machine$B,\n    6 ~ machine$C\n   )\n}\n\nrun_opcode &lt;- function(machine, opcode, operand) {\n  func &lt;- case_match(opcode, \n    0 ~ \"adv\",\n    1 ~ \"bxl\",\n    2 ~ \"bst\",\n    3 ~ \"jnz\",\n    4 ~ \"bxc\",\n    5 ~ \"out\",\n    6 ~ \"bdv\",\n    7 ~ \"cdv\"\n  )\n  \n  get(func)(machine, operand)\n}\n\nrun_machine &lt;- function(machine) {\n  while (machine$pointer &lt; length(machine$program)) {\n    opcode  &lt;- machine$program[machine$pointer + 1]\n    operand &lt;- machine$program[machine$pointer + 2]\n    machine &lt;- run_opcode(machine, opcode, operand)\n  }\n  \n  machine$output\n}\n\nNeed to define custom bitwise XOR function to handle very large integers without error:\n\nbitwXor64 &lt;- function(x, y) {\n  x &lt;- as.bitstring(as.integer64(x))\n  y &lt;- as.bitstring(as.integer64(y))\n  \n  base::xor(\n    as.integer(str_split_1(x, \"\")), \n    as.integer(str_split_1(y, \"\"))\n  ) |&gt; \n    as.integer() |&gt; \n    str_c(collapse = \"\") |&gt; \n    structure(class = \"bitstring\") |&gt; \n    as.integer64() |&gt; \n    as.numeric()\n}\n\nDefine the opcode functions:\n\nadv &lt;- function(machine, operand) {\n  machine$A &lt;- floor(machine$A / 2^combo(machine, operand))\n  machine$pointer &lt;- machine$pointer + 2\n  machine\n}\n\nbxl &lt;- function(machine, operand) {\n  machine$B &lt;- bitwXor64(machine$B, operand)\n  machine$pointer &lt;- machine$pointer + 2\n  machine\n}\n\nbst &lt;- function(machine, operand) {\n  machine$B &lt;- combo(machine, operand) %% 8\n  machine$pointer &lt;- machine$pointer + 2\n  machine\n}\n\njnz &lt;- function(machine, operand) {\n  if (machine$A != 0) \n    machine$pointer &lt;- operand\n  else \n    machine$pointer &lt;- machine$pointer + 2\n  machine\n}\n\nbxc &lt;- function(machine, operand) {\n  machine$B &lt;- bitwXor64(machine$B, machine$C)\n  machine$pointer &lt;- machine$pointer + 2\n  machine\n}\n\nout &lt;- function(machine, operand) {\n  machine$output &lt;- c(machine$output, combo(machine, operand) %% 8)\n  machine$pointer &lt;- machine$pointer + 2\n  machine\n}\n\nbdv &lt;- function(machine, operand) {\n  machine$B &lt;- floor(machine$A / 2^combo(machine, operand))\n  machine$pointer &lt;- machine$pointer + 2\n  machine\n}\n\ncdv &lt;- function(machine, operand) {\n  machine$C &lt;- floor(machine$A / 2^combo(machine, operand))\n  machine$pointer &lt;- machine$pointer + 2\n  machine\n}\n\nRun on puzzle input:\n\nmachine |&gt; \n  run_machine() |&gt; \n  str_flatten(\",\")",
    "crumbs": [
      "2024",
      "Day 17"
    ]
  },
  {
    "objectID": "2024/R/day17.html#part-2",
    "href": "2024/R/day17.html#part-2",
    "title": "Day 17",
    "section": "Part 2",
    "text": "Part 2\nReverse engineer, testing sequences of 3 bits at a time. Thanks to hints from Reddit:\n\nrun_machine_a &lt;- function(a) {\n  run_machine(list(\n    program = program, \n    A = a, \n    B = B, \n    C = C, \n    pointer = 0L, \n    output = NULL\n  ))\n}\n\nreveng &lt;- function(program, digit = 1, a = 0) {\n  if (digit &gt; length(program))\n    return(a)\n  \n  df &lt;- tibble(candidates = 8 * a + 0:7) |&gt; \n    mutate(\n      output = map(candidates, run_machine_a),\n      output = map(output, head, n = 1)\n    ) |&gt; \n    filter(output == rev(program)[digit]) |&gt; \n    mutate(res = map_dbl(candidates, ~ reveng(program, digit + 1, .x))) |&gt; \n    filter(!is.na(res))\n  \n  if (nrow(df) == 0) \n    return(Inf)\n  else \n    return(min(df$res))\n}\n\nreveng(program)",
    "crumbs": [
      "2024",
      "Day 17"
    ]
  },
  {
    "objectID": "2024/R/day15.html",
    "href": "2024/R/day15.html",
    "title": "Day 15",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day15.txt\")\n\nSeparate text input into moves versus the warehouse map:\n\ninput_wh &lt;- keep(input, ~ str_detect(.x, \"#\"))\ninput_mv &lt;- keep(input, ~ str_detect(.x, \"&lt;|&gt;|\\\\^|v\"))\n\nConvert warehouse input to a matrix:\n\nmtx &lt;- input_wh |&gt;\n  str_split(\"\") |&gt; \n  matrix() |&gt; \n  unlist() |&gt; \n  matrix(byrow = TRUE, nrow = length(input_wh))\n\nConvert movement sequence to a seq of characters:\n\nmove_seq &lt;- input_mv |&gt; \n  str_c(collapse = \"\") |&gt; \n  str_split_1(\"\")",
    "crumbs": [
      "2024",
      "Day 15"
    ]
  },
  {
    "objectID": "2024/R/day15.html#setup",
    "href": "2024/R/day15.html#setup",
    "title": "Day 15",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day15.txt\")\n\nSeparate text input into moves versus the warehouse map:\n\ninput_wh &lt;- keep(input, ~ str_detect(.x, \"#\"))\ninput_mv &lt;- keep(input, ~ str_detect(.x, \"&lt;|&gt;|\\\\^|v\"))\n\nConvert warehouse input to a matrix:\n\nmtx &lt;- input_wh |&gt;\n  str_split(\"\") |&gt; \n  matrix() |&gt; \n  unlist() |&gt; \n  matrix(byrow = TRUE, nrow = length(input_wh))\n\nConvert movement sequence to a seq of characters:\n\nmove_seq &lt;- input_mv |&gt; \n  str_c(collapse = \"\") |&gt; \n  str_split_1(\"\")",
    "crumbs": [
      "2024",
      "Day 15"
    ]
  },
  {
    "objectID": "2024/R/day15.html#part-1",
    "href": "2024/R/day15.html#part-1",
    "title": "Day 15",
    "section": "Part 1",
    "text": "Part 1\nDefine a function to update the map based on a single movement of the robot:\n\nmove_robot &lt;- function(mtx, dir) {\n  \n  # Get the current coordinates of the robot\n  robot &lt;- which(mtx == \"@\", arr.ind = TRUE)\n  row &lt;- robot[1, \"row\"]\n  col &lt;- robot[1, \"col\"]\n  \n  # Define the range of matrix values to adjust according to the movement dir\n  row_end &lt;- case_match(dir, c(\"&lt;\", \"&gt;\") ~ row, \"^\" ~ 1, \"v\" ~ nrow(mtx))\n  col_end &lt;- case_match(dir, c(\"^\", \"v\") ~ col, \"&lt;\" ~ 1, \"&gt;\" ~ nrow(mtx))\n  \n  # Using obstacle logic, determine the set of new characters\n  new &lt;- tibble(\n    orig = mtx[row:row_end, col:col_end],\n    lag = lag(orig)\n  ) |&gt; \n    mutate(\n      is_empty = orig == \".\",\n      is_wall  = orig == \"#\",\n      is_blocked = accumulate(is_wall, `|`),\n      is_fillable = is_empty & !is_blocked,\n      first_fillable = is_fillable & !lag(accumulate(is_fillable, `|`)),\n      can_move = accumulate(first_fillable, `|`, .dir = \"backward\"),\n      new = if_else(can_move, coalesce(lag, \".\"), orig)\n    ) |&gt; \n    pull(new)\n  \n  # Replace the affected characters in the matrix and return\n  mtx[row:row_end, col:col_end] &lt;- new\n  \n  mtx\n}\n\nDefine a function to iteratively run the set of movements:\n\nrun_simulation &lt;- function(mtx, move_seq) {\n  mtx_prv &lt;- mtx\n  \n  for (dir in move_seq) {\n    mtx_new &lt;- move_robot(mtx_prv, dir)\n    mtx_prv &lt;- mtx_new\n  }\n  \n  mtx_new\n}\n\nDefine a function to determine the GPS coordinates of all boxes:\n\nget_boxes_gps &lt;- function(mtx) {\n  which(mtx == \"O\", arr.ind = TRUE) |&gt; \n    as_tibble() |&gt; \n    mutate(gps = 100 * (row - 1) + (col - 1)) |&gt; \n    pull(gps)\n}\n\nRun on puzzle input:\n\nmtx |&gt; \n  run_simulation(move_seq) |&gt; \n  get_boxes_gps() |&gt;\n  sum()",
    "crumbs": [
      "2024",
      "Day 15"
    ]
  },
  {
    "objectID": "2024/R/day15.html#part-2",
    "href": "2024/R/day15.html#part-2",
    "title": "Day 15",
    "section": "Part 2",
    "text": "Part 2\nWiden the map:\n\nmtx &lt;- input_wh |&gt; \n  str_replace_all(\"#\", \"##\") |&gt; \n  str_replace_all(\"O\", \"[]\") |&gt; \n  str_replace_all(\"\\\\.\", \"..\") |&gt; \n  str_replace_all(\"@\", \"@.\") |&gt;\n  str_split(\"\") |&gt; \n  matrix() |&gt; \n  unlist() |&gt; \n  matrix(byrow = TRUE, nrow = length(input_wh))\n\nDefine a set of helper functions for moving boxes around the map:\n\nget_box_coords &lt;- function(mtx, box_num) {\n  as_tibble(which(mtx == box_num, arr.ind = TRUE))\n}\n\nget_next_coords &lt;- function(cur_coords, dir = c(\"&lt;\", \"^\", \"&gt;\", \"v\")) {\n  cur_coords |&gt;\n    mutate(\n      row = row + case_match(dir, \"^\" ~ -1, \"v\" ~ 1, .default = 0),\n      col = col + case_match(dir, \"&lt;\" ~ -1, \"&gt;\" ~ 1, .default = 0),\n    )\n}\n\nget_next_chrs &lt;- function(mtx, cur_coords, dir = c(\"&lt;\", \"^\", \"&gt;\", \"v\")) {\n  # Pull the values of the next cells in the intended direction\n  cur_coords |&gt;\n    get_next_coords(dir) |&gt; \n    mutate(chr = map2_chr(row, col, ~ mtx[.x, .y])) |&gt; \n    anti_join(cur_coords, join_by(row, col)) |&gt; \n    pull(chr) |&gt; \n    unique()\n}\n\nis_blocked &lt;- function(mtx, box_num, dir = c(\"&lt;\", \"^\", \"&gt;\", \"v\")) {\n  \n  cur &lt;- get_box_coords(mtx, box_num)\n  nxt_chrs &lt;- get_next_chrs(mtx, cur, dir)\n  \n  # Test if the current box is completely blocked or completely free\n  if (any(nxt_chrs == '#')) \n    return(TRUE)\n  else if (all(nxt_chrs == '.')) \n    return(FALSE)\n  \n  # Recurse across all later boxes \n  nxt_chrs |&gt; \n    keep(~ str_detect(.x, \"^\\\\d+$\")) |&gt; \n    map_lgl(~ is_blocked(mtx, .x, dir)) |&gt; \n    any()\n}\n\nDefine a function to move a box:\n\nmove_box &lt;- function(mtx, box_num, dir = c(\"&lt;\", \"^\", \"&gt;\", \"v\")) {\n  # Get the coordinates of the current box and the place it'll move to\n  cur &lt;- get_box_coords(mtx, box_num)\n  nxt &lt;- get_next_coords(cur, dir)\n  \n  # Move all downstream boxes before moving self\n  next_boxes &lt;- get_next_chrs(mtx, cur, dir) |&gt; \n    keep(~ str_detect(.x, \"^\\\\d+$\"))\n  \n  for (box in next_boxes) {\n    mtx &lt;- move_box(mtx, box, dir)\n  }\n  \n  # Replace the current coords with \".\" and the next coords with the box\n  mtx[cur$row, cur$col] &lt;- \".\"\n  mtx[nxt$row, nxt$col] &lt;- box_num\n  \n  mtx\n}\n\nLoop through puzzle input:\n\nrun_simulation &lt;- function(mtx, move_seq) {\n  \n  # Convert boxes from format \"[]\" into ID numbers unique to each box:\n  coords &lt;- list(l = which(mtx == \"[\"), r = which(mtx == \"]\"))\n  for (i in 1:length(coords$l)) {\n    mtx[coords$l[i]] &lt;- i\n    mtx[coords$r[i]] &lt;- i\n  }\n\n  # Loop through sequence of moves and apply to the map\n  mtx_prv &lt;- mtx\n  for (dir in move_seq) {\n    if (!is_blocked(mtx_prv, box_num = \"@\", dir = dir)) {\n      mtx_new &lt;- move_box(mtx_prv, box_num = \"@\", dir = dir)\n      mtx_prv &lt;- mtx_new\n    } \n  }\n  \n  return(mtx_new)\n}\n\noutput &lt;- run_simulation(mtx, move_seq)\n\nConvert the result to GPS coordinates:\n\noutput |&gt; \n  as_tibble() |&gt; \n  mutate(row = row_number(), .before = everything()) |&gt; \n  pivot_longer(\n    -row, \n    names_to = \"col\", \n    names_prefix = \"V\", \n    names_transform = as.integer\n  ) |&gt; \n  \n  # Select only the leftmost cell of each boxes\n  filter(str_detect(value, \"\\\\d+\")) |&gt; \n  slice_min(col, by = value) |&gt; \n  mutate(\n    dist_top = row - 1,\n    dist_left = col - 1,\n    gps = 100 * dist_top + dist_left\n  ) |&gt; \n  pull(gps) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 15"
    ]
  },
  {
    "objectID": "2024/R/day14.html",
    "href": "2024/R/day14.html",
    "title": "Day 14",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day14.txt\")\n\nExtract numerical values from plaintext input:\n\ndf &lt;- input |&gt;\n  unglue_data(\"p={x},{y} v={vx},{vy}\") |&gt; \n  mutate(\n    across(everything(), parse_number),\n    robot_id = row_number(),\n    .before = everything()\n  )\n\nDefine parameters: dimensions of the room:\n\nroom_w &lt;- 101\nroom_h &lt;- 103",
    "crumbs": [
      "2024",
      "Day 14"
    ]
  },
  {
    "objectID": "2024/R/day14.html#setup",
    "href": "2024/R/day14.html#setup",
    "title": "Day 14",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day14.txt\")\n\nExtract numerical values from plaintext input:\n\ndf &lt;- input |&gt;\n  unglue_data(\"p={x},{y} v={vx},{vy}\") |&gt; \n  mutate(\n    across(everything(), parse_number),\n    robot_id = row_number(),\n    .before = everything()\n  )\n\nDefine parameters: dimensions of the room:\n\nroom_w &lt;- 101\nroom_h &lt;- 103",
    "crumbs": [
      "2024",
      "Day 14"
    ]
  },
  {
    "objectID": "2024/R/day14.html#part-1",
    "href": "2024/R/day14.html#part-1",
    "title": "Day 14",
    "section": "Part 1",
    "text": "Part 1\nDefine a function which gives the location of the robots after n seconds. Multiply n by the velocity, add to the current position, and modulo the room dimensions.\n\npass_time &lt;- function(df, seconds) {\n  df |&gt; \n    mutate(\n      x = (x + vx * seconds) %% room_w,\n      y = (y + vy * seconds) %% room_h\n    )\n}\n\nDefine a function to get the current safety factor by counting the number of robots in each quadrant of the room:\n\nget_safety_score &lt;- function(df) {\n  mid_w &lt;- (room_w - 1) / 2\n  mid_h &lt;- (room_h - 1) / 2\n  \n  df |&gt; \n    mutate(\n      half_w = case_when(x &lt; mid_w ~ 0, x &gt; mid_w ~ 1),\n      half_h = case_when(y &lt; mid_h ~ 0, y &gt; mid_h ~ 1),\n      quadrant = half_w + 2 * half_h\n    ) |&gt; \n    drop_na(quadrant) |&gt; \n    summarize(num_robots = n(), .by = quadrant) |&gt; \n    pull(num_robots) |&gt; \n    prod()\n}\n\nCompute safety score of puzzle input:\n\ndf |&gt; \n  pass_time(100) |&gt; \n  get_safety_score()",
    "crumbs": [
      "2024",
      "Day 14"
    ]
  },
  {
    "objectID": "2024/R/day14.html#part-2",
    "href": "2024/R/day14.html#part-2",
    "title": "Day 14",
    "section": "Part 2",
    "text": "Part 2\nFirst, find the cycle of seconds where the robots’ positions repeat (no more than the least common multiple of the room width and room height)\n\ncycle &lt;- DescTools::LCM(room_w, room_h)\n\nFor each unique snapshot in the cycle, test for randomness vs structure in the X-Y coordinates.\n\nsimulations &lt;- map_dfr(1:cycle, \\(seconds) {\n  new &lt;- pass_time(df, seconds)\n  c(secs = seconds, xvar = var(new$x), yvar = var(new$y))\n})\n\nsimulations |&gt; \n  arrange(xvar, yvar, secs) |&gt; \n  filter(row_number() == 1) |&gt; \n  pull(secs)",
    "crumbs": [
      "2024",
      "Day 14"
    ]
  },
  {
    "objectID": "2024/R/day19.html",
    "href": "2024/R/day19.html",
    "title": "Day 19",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(memoise)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file:\n\navailable &lt;- read_lines(\"../input/day19.txt\", n_max = 1) |&gt; str_split_1(\", \")\ndesired   &lt;- read_lines(\"../input/day19.txt\", skip = 2)",
    "crumbs": [
      "2024",
      "Day 19"
    ]
  },
  {
    "objectID": "2024/R/day19.html#setup",
    "href": "2024/R/day19.html#setup",
    "title": "Day 19",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(memoise)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file:\n\navailable &lt;- read_lines(\"../input/day19.txt\", n_max = 1) |&gt; str_split_1(\", \")\ndesired   &lt;- read_lines(\"../input/day19.txt\", skip = 2)",
    "crumbs": [
      "2024",
      "Day 19"
    ]
  },
  {
    "objectID": "2024/R/day19.html#part-1",
    "href": "2024/R/day19.html#part-1",
    "title": "Day 19",
    "section": "Part 1",
    "text": "Part 1\nConvert all possible available patterns into a regex string:\n\nregex &lt;- str_c(\"^(\", str_c(available, collapse = \"|\"), \")+$\")\n\nTest each desired pattern for a regex match and count the number of matches:\n\ndesired |&gt; \n  str_detect(regex) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 19"
    ]
  },
  {
    "objectID": "2024/R/day19.html#part-2",
    "href": "2024/R/day19.html#part-2",
    "title": "Day 19",
    "section": "Part 2",
    "text": "Part 2\nUse recursion to check for total possible values, and cache results with memoisation to speed up the process:\n\n# Recursively remove matches from the beginning of the string and sum result\nnum_matches &lt;- function(str) {\n  if (str_length(str) == 0)\n    return(1)\n  \n  available |&gt; \n    keep(~ str_starts(str, .x)) |&gt; \n    map_chr(~ str_remove(str, .x)) |&gt; \n    map_dbl(num_matches) |&gt; \n    sum()\n}\n\n# Memoize the recursive function for performance\nnum_matches &lt;- memoise(num_matches)\n\nRun on puzzle input:\n\ndesired |&gt; \n  map_dbl(num_matches) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 19"
    ]
  },
  {
    "objectID": "2024/R/day24.html",
    "href": "2024/R/day24.html",
    "title": "Day 24",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day24.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2024",
      "Day 24"
    ]
  },
  {
    "objectID": "2024/R/day24.html#setup",
    "href": "2024/R/day24.html#setup",
    "title": "Day 24",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day24.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2024",
      "Day 24"
    ]
  },
  {
    "objectID": "2024/R/day24.html#part-1",
    "href": "2024/R/day24.html#part-1",
    "title": "Day 24",
    "section": "Part 1",
    "text": "Part 1\nConvert input to lists of gates and wires:\n\ninit &lt;- input |&gt; \n  unglue_data(\"{wire}: {value}\", convert = TRUE) |&gt; \n  filter(!is.na(wire))\n\ngates &lt;- input |&gt; \n  unglue_data(\"{src1} {gate} {src2} -&gt; {target}\") |&gt; \n  filter(!is.na(gate)) |&gt; \n  mutate(gate = case_match(gate, \"AND\" ~ \"&\", \"OR\" ~ \"|\", \"XOR\" ~ \"xor\"))\n\nwires &lt;- init |&gt; \n  complete(wire = unique(c(gates$src1, gates$src2, gates$target))) |&gt; \n  deframe()\n\nLoop through the lists of gates and wires, and whenever a new gate can be activated, get its resulting value. Repeat until all wires have a final output.\n\ndf &lt;- wires |&gt; \n  enframe(name = \"wire\") |&gt;\n  left_join(gates, join_by(wire == target))\n\nrepeat {\n\n  cur_values &lt;- df |&gt; \n    select(wire, value) |&gt; \n    deframe()\n  \n  df &lt;- df |&gt; \n    mutate(\n      val1 = cur_values[src1], \n      val2 = cur_values[src2],\n      value = coalesce(\n        value,\n        pmap_int(list(gate, val1, val2), \\(gate, val1, val2) {\n          if (!is.na(gate) & !is.na(val1) & !is.na(val2))\n            get(gate)(val1, val2)\n          else \n            NA_integer_\n        })\n      )\n    )\n  \n  if (all(!is.na(df$value))) break\n}\n\nConvert the Z-coded wires to a binary number:\n\ndf |&gt; \n  filter(str_starts(wire, \"z\")) |&gt; \n  arrange(wire) |&gt; \n  pull(value) |&gt; \n  imap_dbl(\\(x, i) x * 2^(i - 1)) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 24"
    ]
  },
  {
    "objectID": "2024/R/day24.html#part-2",
    "href": "2024/R/day24.html#part-2",
    "title": "Day 24",
    "section": "Part 2",
    "text": "Part 2\nThanks to hint from Reddit: this method of binary addition using only AND, OR, XOR gates without negation is a “ripple-carry adder.”\nThe gates follow a consistent algorithm, where “Z” digits are the final output digits, and “C” values are carried over to the next digit:\n\nSTEP 00: \n\nZ00 = X00 XOR Y00  (Final output: Z00)\n\nC01 = X00 AND Y00  (Carry forward to next step)\n\nSTEP 01: \n\nZ01A = X01  XOR Y01  (Intermediate step)\nZ01  = Z01A XOR C01  (Final output: Z01)\n\nC02A = X01  AND Y01  (Intermediate step)\nC02B = Z01A AND C01  (Intermediate step)\nC02  = C02A OR  C02B (Carry forward to next step)\n\n(...)\n\nC44  = C44A OR C44B  (Carry forward to next step)\n\nSTEP 44:\n\nZ44A = X44  XOR Y44  (Intermediate step)\nZ44  = Z44A XOR C44  (Final output: Z45)\n\nC45A = X44  AND Y44  (Intermediate step)\nC45B = Z44A AND C44  (Intermediate step)\nC45  = C45A OR  C45B (No further steps to carry over. Set as final output: Z45)\nWe can compare the expected versus actual logic to find steps that don’t match this algorithm.\n\n# Pull lists of all wires of x, y, z, and other types for quick reference\nnlist &lt;- discard(names(wires), ~ str_starts(.x, \"x|y|z\"))\nxlist &lt;- keep(names(wires), ~ str_starts(.x, \"x\"))\nylist &lt;- keep(names(wires), ~ str_starts(.x, \"y\"))\nzlist &lt;- keep(names(wires), ~ str_starts(.x, \"z\"))\nxylist &lt;- c(xlist, ylist)\nzmax  &lt;- max(zlist)\n\n# Put source gates in alphabetical order for easier comparison\ngates &lt;- gates |&gt; \n  mutate(src = map2(src1, src2, ~ sort(c(.x, .y)))) |&gt; \n  select(-c(src1, src2)) |&gt; \n  unnest_wider(src, names_sep = \"\")\n\nPull invalid outputs according to their gate type and inputs:\n\ninvalid_by_gate &lt;- gates |&gt; \n  pmap_lgl(\\(gate, target, src1, src2) {\n    case_when(\n      # All z-target cases:\n      target == \"z00\"   ~ src1 == \"x00\" & src2 == \"y00\" & gate == \"xor\",\n      target == zmax    ~ src1 %in% nlist & src2 %in% nlist & gate == \"|\",\n      target %in% zlist ~ src1 %in% nlist & src2 %in% nlist & gate == \"xor\",\n      # N-target cases by gate type:\n      gate == \"xor\" ~ src1 %in% xylist & src2 %in% xylist,\n      gate == \"|\"   ~ src1 %in% nlist  & src2 %in% nlist\n    )\n  }) |&gt; \n  set_names(gates$target) |&gt; \n  keep(~ !is.na(.x) & .x == FALSE) |&gt; \n  names()\n\nIdentify invalid outputs by following their logic trail forward and checking the gate types of the logic they are used as later input for:\n\ninvalid_by_path &lt;- gates |&gt; \n  left_join(\n    select(gates, src1, gate), \n    join_by(x$target == y$src1), \n    suffix = c(\"\", \"1\")\n  ) |&gt; \n  left_join(\n    select(gates, src2, gate), \n    join_by(x$target == y$src2), \n    suffix = c(\"\", \"2\")\n  ) |&gt; \n  nest(nxt = c(gate1, gate2), .by = -c(gate1, gate2)) |&gt; \n  mutate(nxt = map(nxt, ~ .x |&gt; unlist() |&gt; discard(is.na) |&gt; unname())) |&gt; \n  unnest_wider(nxt, names_sep = \"_\") |&gt; \n  mutate(\n    valid = case_when(\n      target %in% zlist \n        ~ NA,\n      gate == \"xor\" \n        ~ nxt_1 %in% c(\"xor\", \"&\") & \n          nxt_2 %in% c(\"xor\", \"&\") & \n          nxt_1 != nxt_2 & \n          !is.na(nxt_1) & \n          !is.na(nxt_2),\n      gate == \"|\" \n        ~ nxt_1 %in% c(\"xor\", \"&\") & \n          nxt_2 %in% c(\"xor\", \"&\") & \n          nxt_1 != nxt_2 & \n          !is.na(nxt_1) & \n          !is.na(nxt_2),\n      gate == \"&\" & !(src1 %in% c(\"x00\", \"y00\"))\n        ~ nxt_1 == \"|\" | nxt_2 == \"|\"\n    )\n  ) |&gt; \n  filter(!valid) |&gt; \n  pull(target)\n\nConcatenate all invalid gates alphabetically:\n\nc(invalid_by_gate, invalid_by_path) |&gt; \n  unique() |&gt; \n  sort() |&gt; \n  str_flatten(\",\")",
    "crumbs": [
      "2024",
      "Day 24"
    ]
  },
  {
    "objectID": "2024/R/day22.html",
    "href": "2024/R/day22.html",
    "title": "Day 22",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from txt file into a numeric vector:\n\ninput &lt;- scan(\"../input/day22.txt\")",
    "crumbs": [
      "2024",
      "Day 22"
    ]
  },
  {
    "objectID": "2024/R/day22.html#setup",
    "href": "2024/R/day22.html#setup",
    "title": "Day 22",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from txt file into a numeric vector:\n\ninput &lt;- scan(\"../input/day22.txt\")",
    "crumbs": [
      "2024",
      "Day 22"
    ]
  },
  {
    "objectID": "2024/R/day22.html#part-1",
    "href": "2024/R/day22.html#part-1",
    "title": "Day 22",
    "section": "Part 1",
    "text": "Part 1\nR only has bitwise operations for integers up to 32 bits. First, we have to define functions to convert between large numeric values and 64-“bit” 1/0 vectors:\n\nbase64 &lt;- 2^(63:0)  # (pre-compute this vector to reduce runtime)\n\nas_b64 &lt;- \\(x) x %/% base64 %% 2\nas_num &lt;- \\(x) sum(x * base64)\n\nDefine a function to perform xor operations on large integers:\n\nb64xor &lt;- \\(x, y) as_num(base::xor(as_b64(x), as_b64(y)))\n\nDefine the algorithm for producing a sequence of “secret” numbers:\n\nprune &lt;- \\(x) x %% 16777216\n\nsecret_alg &lt;- function(x0) {\n  x1 &lt;- prune(b64xor(x0, x0 * 64))\n  x2 &lt;- prune(b64xor(x1, x1 %/% 32))\n  x3 &lt;- prune(b64xor(x2, x2 * 2048))\n  \n  x3\n}\n\nsecret_seq &lt;- function(init, n) {\n  map(init, \\(init) accumulate(1:n, \\(x, y) secret_alg(x), .init = init))\n}\n\nGenerate 2000 “secret numbers” for each initial value in the puzzle input:\n\nsecret_nums &lt;- secret_seq(input, n = 2000)\n\nSum the 2000th “secret number” for each value in our input:\n\nsecret_nums |&gt; \n  map_dbl(~ tail(.x, n = 1)) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 22"
    ]
  },
  {
    "objectID": "2024/R/day22.html#part-2",
    "href": "2024/R/day22.html#part-2",
    "title": "Day 22",
    "section": "Part 2",
    "text": "Part 2\nConvert the set of secret number sequences to a dataframe organized by buyer and time:\n\ndiffs &lt;- secret_nums |&gt; \n  enframe(name = \"buyer_id\", value = \"secret_number\") |&gt; \n  unnest_longer(secret_number, indices_to = \"time\") |&gt; \n  mutate(\n    \n    # Get the price at each time by taking the ones digit of each secret number\n    price = secret_number %% 10L,\n    \n    # Compute the difference in price at the current time vs the previous time\n    diff = price - lag(price),\n    \n    # Compute the sequence of 4 price changes preceeding the current price\n    lag1 = lag(diff, n = 1L),\n    lag2 = lag(diff, n = 2L),\n    lag3 = lag(diff, n = 3L),\n    diff_seq = str_c(lag3, lag2, lag1, diff, sep = \",\"),\n    \n    .by = buyer_id\n  ) |&gt; \n  arrange(buyer_id, time)\n\nFor each price change sequence, compute the bananas you will get from each buyer:\n\nbananas_by_seq &lt;- diffs |&gt; \n  filter(!is.na(diff_seq)) |&gt; \n  summarize(\n    bananas = head(price, 1),\n    .by = c(buyer_id, diff_seq)\n  )\n\nFind the most advantageous sequence:\n\nbananas_by_seq |&gt; \n  summarize(bananas = sum(bananas), .by = diff_seq) |&gt; \n  slice_max(bananas) |&gt; \n  pull(bananas)",
    "crumbs": [
      "2024",
      "Day 22"
    ]
  },
  {
    "objectID": "2024/R/day20.html",
    "href": "2024/R/day20.html",
    "title": "Day 20",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file into a data frame:\n\ninput &lt;- read_table(\"../input/day20.txt\", col_names = \"char\") |&gt; \n  mutate(\n    row = row_number(),\n    char = str_split(char, \"\")\n  ) |&gt; \n  unnest_longer(char, indices_to = \"col\")",
    "crumbs": [
      "2024",
      "Day 20"
    ]
  },
  {
    "objectID": "2024/R/day20.html#setup",
    "href": "2024/R/day20.html#setup",
    "title": "Day 20",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file into a data frame:\n\ninput &lt;- read_table(\"../input/day20.txt\", col_names = \"char\") |&gt; \n  mutate(\n    row = row_number(),\n    char = str_split(char, \"\")\n  ) |&gt; \n  unnest_longer(char, indices_to = \"col\")",
    "crumbs": [
      "2024",
      "Day 20"
    ]
  },
  {
    "objectID": "2024/R/day20.html#part-1",
    "href": "2024/R/day20.html#part-1",
    "title": "Day 20",
    "section": "Part 1",
    "text": "Part 1\nExtract the sequence of tiles in the original path:\n\n# Compute coordinates of each tile and extract the path sequence, ignoring walls\ndf &lt;- input |&gt; \n  filter(row &gt; 1 & row &lt; max(row) & col &gt; 1 & col &lt; max(col)) |&gt; \n  mutate(\n    id = row_number(),\n    row = row - 1, \n    col = col - 1\n  ) |&gt; \n  filter(char %in% c(\"S\", \"E\", \".\")) |&gt; \n  arrange(col, row)\n\n# Re-number the tiles on the path by their ordering from start to finish\npath_seq &lt;- df |&gt; \n  filter(char == \"S\") |&gt; \n  pull(id)\n\nwhile (length(path_seq) &lt; nrow(df)) {\n  path_seq &lt;- c(\n    path_seq, \n    df |&gt; \n      filter(id == tail(path_seq, 1)) |&gt; \n      cross_join(df) |&gt; \n      filter(\n        (abs(col.x - col.y) == 1 & abs(row.x - row.y) == 0) |\n        (abs(col.x - col.y) == 0 & abs(row.x - row.y) == 1)\n      ) |&gt; \n      filter(!(id.y %in% path_seq)) |&gt; \n      pull(id.y)\n  )\n}\n\n# Attach path order onto the list of path tiles with their coordinates\ndf_path &lt;- left_join(\n  df, \n  enframe(path_seq, name = \"path_idx\", value = \"id\"), \n  join_by(id)\n) |&gt; \n  select(path_idx, row, col) |&gt; \n  arrange(path_idx)\n\nCount the total seconds saved when collision is disabled for n seconds. Possible cheat end locations, and the time it takes to arrive there, can be calculated using Manhattan distance.\n\nmanhattan_dist &lt;- function(a_row, a_col, b_row, b_col) {\n  abs(a_row - b_row) + abs(a_col - b_col)\n}\n\ncount_cheats &lt;- function(cheat_length) {\n\n  df_path |&gt; \n    # Find all possible time-saving cheats if collision is disabled for n secs\n    left_join(df_path, join_by(x$path_idx &lt; y$path_idx)) |&gt; \n    mutate(dist = manhattan_dist(row.x, col.x, row.y, col.y)) |&gt; \n    filter(dist &lt;= cheat_length) |&gt; \n    mutate(saved = path_idx.y - path_idx.x - dist) |&gt; \n    summarize(n = n(), .by = saved) |&gt; \n    arrange(saved) |&gt; \n    \n    # Count the total number of cheats that save at least 100 seconds\n    filter(saved &gt;= 100) |&gt; \n    pull(n) |&gt;\n    sum()\n  \n}\n\nRun on puzzle input:\n\ncount_cheats(2)",
    "crumbs": [
      "2024",
      "Day 20"
    ]
  },
  {
    "objectID": "2024/R/day20.html#part-2",
    "href": "2024/R/day20.html#part-2",
    "title": "Day 20",
    "section": "Part 2",
    "text": "Part 2\nRe-run with length 20, rather than 2:\n\ncount_cheats(20)",
    "crumbs": [
      "2024",
      "Day 20"
    ]
  },
  {
    "objectID": "2024/R/day09.html",
    "href": "2024/R/day09.html",
    "title": "Day 9",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file into a vector of integers:\n\ninput &lt;- read_lines(\"../input/day09.txt\") |&gt; \n  str_split_1(\"\") |&gt; \n  as.integer()",
    "crumbs": [
      "2024",
      "Day 9"
    ]
  },
  {
    "objectID": "2024/R/day09.html#setup",
    "href": "2024/R/day09.html#setup",
    "title": "Day 9",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead input from file into a vector of integers:\n\ninput &lt;- read_lines(\"../input/day09.txt\") |&gt; \n  str_split_1(\"\") |&gt; \n  as.integer()",
    "crumbs": [
      "2024",
      "Day 9"
    ]
  },
  {
    "objectID": "2024/R/day09.html#part-1",
    "href": "2024/R/day09.html#part-1",
    "title": "Day 9",
    "section": "Part 1",
    "text": "Part 1\nDefine a function to move the file blocks:\n\nmove_files &lt;- function(filesys) {\n  repeat {\n    first_blank &lt;- min(which(is.na(filesys)))\n    last_file   &lt;- max(which(!is.na(filesys)))\n    \n    # If all files have been compressed, exit\n    if (first_blank &gt; last_file) break\n    \n    # Otherwise, move the last file into the first blank location\n    filesys[first_blank] &lt;- filesys[last_file]\n    filesys[last_file]   &lt;- NA_integer_\n  }\n  filesys\n}\n\nDefine a function to compute the checksum of the file system:\n\nchecksum &lt;- function(filesys) {\n  filesys |&gt; \n    imap_int(\\(x, idx) if_else(is.na(x), 0, x * (idx - 1))) |&gt; \n    sum()\n}\n\nUncompress the given file layout, interpreting even entries as files and odd entries as spaces:\n\nfilesys &lt;- input|&gt; \n  imap(function(x, idx) {\n    file_id &lt;- if_else(idx %% 2 == 1, floor(idx / 2), NA_integer_)\n    rep(file_id, x)\n  }) |&gt; \n  unlist()\n\nMove the files and compute the checksum:\n\nfilesys |&gt; \n  move_files() |&gt; \n  checksum()",
    "crumbs": [
      "2024",
      "Day 9"
    ]
  },
  {
    "objectID": "2024/R/day09.html#part-2",
    "href": "2024/R/day09.html#part-2",
    "title": "Day 9",
    "section": "Part 2",
    "text": "Part 2\nUpdate the compression function:\n\nmove_blocks &lt;- function(filesys) {\n  for (file_id in max(na.omit(filesys)):1) {\n    \n    # Pull the location and length of the file block for the current ID\n    file_block &lt;- which(filesys == file_id)\n    n &lt;- length(file_block)\n    \n    # Pull indices of all empty values before the current file block\n    empty_idx &lt;- which(is.na(filesys[1:min(file_block)]))\n    \n    # Pull all valid starting indices of empty blocks of the right length\n    if (n == 1) {\n      valid_idx &lt;- empty_idx\n    } else {\n      valid_block &lt;- replace_na(lead(empty_idx, n - 1) - empty_idx == n - 1, FALSE)\n      valid_idx &lt;- empty_idx[valid_block]\n    }\n    \n    # If valid indices exist, move the file block to the first valid location\n    if (length(valid_idx) &gt; 0) {\n      idx_start &lt;- min(valid_idx)\n      filesys[idx_start:(idx_start + n - 1)] &lt;- file_id\n      filesys[file_block] &lt;- NA_integer_\n    }\n  }\n  \n  filesys\n}\n\nRe-run input with new compression function:\n\nfilesys |&gt; \n  move_blocks() |&gt; \n  checksum()",
    "crumbs": [
      "2024",
      "Day 9"
    ]
  },
  {
    "objectID": "2023/R/day04.html",
    "href": "2023/R/day04.html",
    "title": "Day 4",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day04.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 4"
    ]
  },
  {
    "objectID": "2023/R/day04.html#setup",
    "href": "2023/R/day04.html#setup",
    "title": "Day 4",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day04.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 4"
    ]
  },
  {
    "objectID": "2023/R/day04.html#part-1",
    "href": "2023/R/day04.html#part-1",
    "title": "Day 4",
    "section": "Part 1",
    "text": "Part 1\nReformat input into lists of winning numbers vs chosen numbers for each card, then score each card:\n\ncards &lt;- input |&gt; \n  \n  # Reformat as a data frame of winning vs chosen numbers per card\n  str_remove(\"Card .*:\") |&gt; \n  enframe(name = \"card_id\", value = \"txt\") |&gt; \n  separate(txt, into = c(\"winning\", \"chosen\"), sep = \"\\\\|\") |&gt; \n  mutate(across(c(winning, chosen), \\(vec) {\n    vec |&gt; \n      trimws() |&gt; \n      str_split(\"\\\\s+\") |&gt; \n      map(parse_number)\n  })) |&gt; \n  \n  # Count the number of overlapping chosen & winning numbers per card:\n  mutate(\n    n_common = map2_int(winning, chosen, ~ length(intersect(.x, .y))),\n    score = if_else(n_common == 0, 0, 2^(n_common - 1))\n  )\n\nSum all cards’ scores:\n\nsum(cards$score)",
    "crumbs": [
      "2023",
      "Day 4"
    ]
  },
  {
    "objectID": "2023/R/day04.html#part-2",
    "href": "2023/R/day04.html#part-2",
    "title": "Day 4",
    "section": "Part 2",
    "text": "Part 2\nCreate a reference table of the outputs received for each winning card:\n\nrewards &lt;- cards |&gt; \n  mutate(\n    reward_start = card_id + 1,\n    reward_end = pmin(card_id + n_common, max(card_id)),\n    reward = pmap(list(reward_start, reward_end, n_common), \\(start, end, n) {\n      if (n == 0) \n        rep(0, nrow(cards))\n      else \n        rep(0, nrow(cards)) |&gt; \n        modify_at(.at = seq(start, end), ~1)\n    })\n  ) |&gt; \n  pull(reward)\n\nLoop through each card in the inventory, accumulate rewards at each step, then sum the final total number of cards:\n\ncollect_reward &lt;- \\(inventory, i) inventory + inventory[[i]] * rewards[[i]]\n\nreduce(1:nrow(cards), collect_reward, .init = rep(1, nrow(cards))) |&gt; \n  sum()",
    "crumbs": [
      "2023",
      "Day 4"
    ]
  },
  {
    "objectID": "2023/R/day11.html",
    "href": "2023/R/day11.html",
    "title": "Day 11",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day11.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 11"
    ]
  },
  {
    "objectID": "2023/R/day11.html#setup",
    "href": "2023/R/day11.html#setup",
    "title": "Day 11",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day11.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 11"
    ]
  },
  {
    "objectID": "2023/R/day11.html#part-1",
    "href": "2023/R/day11.html#part-1",
    "title": "Day 11",
    "section": "Part 1",
    "text": "Part 1\nConvert text input to a matrix:\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  map(partial(matrix, nrow = 1)) |&gt; \n  reduce(rbind)\n\nDetermine the initial indices of each galaxy:\n\ngalaxies &lt;- which(mtx == '#', arr.ind = TRUE) |&gt; \n  as_tibble() |&gt; \n  mutate(id = row_number(), .before = everything())\n\nGet the indices of the rows and columns that contain only empty space:\n\nempty_rows &lt;- split(mtx, row(mtx))  |&gt; \n  map_lgl(~ all(.x == '.')) |&gt; \n  which() |&gt; \n  unname()\n\nempty_cols &lt;- split(mtx, col(mtx))  |&gt; \n  map_lgl(~ all(.x == '.')) |&gt; \n  which() |&gt; \n  unname()\n\nAdjust the coordinates of the galaxies by doubling the empty rows and columns:\n\ngalaxies &lt;- galaxies |&gt; \n  mutate(\n    empty_pre_rows = map_int(row, ~ sum(empty_rows &lt; .x)),\n    empty_pre_cols = map_int(col, ~ sum(empty_cols &lt; .x))\n  )\n\nDefine a function that adjusts the coordinates of each galaxy by expanding all empty rows and columns by n, computes the manhattan distance between each resulting pair of galaxies, and sums the result:\n\nexpanded_galaxy_dist &lt;- function(n) {\n  \n  new_galaxies &lt;- galaxies |&gt; \n    mutate(\n      new_row = row + empty_pre_rows * (n - 1),\n      new_col = col + empty_pre_cols * (n - 1)\n    )\n  \n  left_join(\n    select(new_galaxies, id, row = new_row, col = new_col),\n    select(new_galaxies, id, row = new_row, col = new_col),\n    join_by(x$id &lt; y$id)\n  ) |&gt; \n    mutate(dist = abs(row.x - row.y) + abs(col.x - col.y)) |&gt; \n    pull(dist) |&gt; \n    sum(na.rm = TRUE)\n  \n}\n\nRun on puzzle input:\n\nexpanded_galaxy_dist(2)",
    "crumbs": [
      "2023",
      "Day 11"
    ]
  },
  {
    "objectID": "2023/R/day11.html#part-2",
    "href": "2023/R/day11.html#part-2",
    "title": "Day 11",
    "section": "Part 2",
    "text": "Part 2\n\nexpanded_galaxy_dist(1000000)",
    "crumbs": [
      "2023",
      "Day 11"
    ]
  },
  {
    "objectID": "2023/R/day13.html",
    "href": "2023/R/day13.html",
    "title": "Day 13",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day13.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 13"
    ]
  },
  {
    "objectID": "2023/R/day13.html#setup",
    "href": "2023/R/day13.html#setup",
    "title": "Day 13",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day13.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 13"
    ]
  },
  {
    "objectID": "2023/R/day13.html#part-1",
    "href": "2023/R/day13.html#part-1",
    "title": "Day 13",
    "section": "Part 1",
    "text": "Part 1\nConvert each set of input strings into its own matrix:\n\nmtx &lt;- tibble(chr = input) |&gt; \n  group_split(cumsum(chr == \"\")) |&gt; \n  map(~ pull(.x, chr)) |&gt; \n  map(\n    ~ str_split(.x, \"\") |&gt; \n      unlist() |&gt; \n      matrix(nrow = sum(.x != \"\"), byrow = TRUE)\n  )\n\nDefine a function that checks for a mirror along the given dimension (rows vs columns) of a given matrix:\n\nmirror_idx &lt;- function(mtx, dim = c(\"row\", \"col\")) {\n  vecs &lt;- split(mtx, get(case_match(dim, \"row\" ~ \"col\", \"col\" ~ \"row\"))(mtx))\n  len  &lt;- get(str_c(\"n\", dim))(mtx)\n  \n  refl_idx &lt;- c(0)\n  \n  for (idx in 1:(len - 1)) {\n    n_trim &lt;- min(idx, len - idx)\n    \n    is_mirror &lt;- vecs |&gt; \n      map_lgl(\\(vec) {\n        h1 &lt;- rev(vec[1:idx])[1:n_trim]\n        h2 &lt;- vec[(idx + 1):(idx + n_trim)]\n        all(h1 == h2)\n      }) |&gt; \n      all()\n    \n    if (is_mirror) \n      refl_idx &lt;- c(refl_idx, idx)\n  }\n  \n  refl_idx\n}\n\nFor each matrix in the list, add the column indices of each vertical reflection line with 100 times the row indices of each horizontal reflection line:\n\nscore_matrices &lt;- function(mtx_list) {\n  mtx_list |&gt; \n    map_dbl(~ sum(mirror_idx(.x, \"col\")) + sum(mirror_idx(.x, \"row\") * 100)) |&gt; \n    sum()\n}\n\nscore_matrices(mtx)",
    "crumbs": [
      "2023",
      "Day 13"
    ]
  },
  {
    "objectID": "2023/R/day13.html#part-2",
    "href": "2023/R/day13.html#part-2",
    "title": "Day 13",
    "section": "Part 2",
    "text": "Part 2\nDefine a function that finds the row or column index of the single smudge for a given matrix:\n\nsmudge_idx &lt;- function(mtx, dim = c(\"row\", \"col\")) {\n  \n  vecs &lt;- split(mtx, get(case_match(dim, \"row\" ~ \"col\", \"col\" ~ \"row\"))(mtx))\n  len  &lt;- get(str_c(\"n\", dim))(mtx)\n  \n  for (idx in 1:(len - 1)) {\n    n_trim &lt;- min(idx, len - idx)\n    \n    noteq &lt;- vecs |&gt; \n      map(\\(vec) {\n        h1 &lt;- rev(vec[1:idx])[1:n_trim]\n        h2 &lt;- vec[(idx + 1):(idx + n_trim)]\n        which(h1 != h2)\n      })\n    \n    if (length(unlist(noteq)) == 1) return(idx)\n  }\n  return(0)\n}\n\nRe-score the input:\n\nscore_unsmudged &lt;- function(mtx_list) {\n  mtx_list |&gt; \n    map_dbl(~ sum(smudge_idx(.x, \"col\")) + sum(smudge_idx(.x, \"row\") * 100)) |&gt; \n    sum()\n}\n\nscore_unsmudged(mtx)",
    "crumbs": [
      "2023",
      "Day 13"
    ]
  },
  {
    "objectID": "2023/R/day06.html",
    "href": "2023/R/day06.html",
    "title": "Day 6",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day06.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 6"
    ]
  },
  {
    "objectID": "2023/R/day06.html#setup",
    "href": "2023/R/day06.html#setup",
    "title": "Day 6",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day06.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 6"
    ]
  },
  {
    "objectID": "2023/R/day06.html#part-1",
    "href": "2023/R/day06.html#part-1",
    "title": "Day 6",
    "section": "Part 1",
    "text": "Part 1\nConvert input text into a set of time/distance vectors for each race:\n\nraces &lt;- c(\"time\" = 1, \"distance\" = 2) |&gt; \n  imap(\\(i, name) {\n    input[[i]] |&gt;\n      str_remove(regex(str_c(name, \":\\\\s+\"), ignore_case = T)) |&gt;\n      str_split_1(\"\\\\s+\") |&gt;\n      as.numeric()\n  }) |&gt; \n  pmap(\\(time, distance) list(time = time, record = distance))\n\nDefine a function to compute your traveled distance in each race, given the amount of time you hold the button:\n\nrace_dist &lt;- function(time_race, time_hold) {\n  (time_race - time_hold) * time_hold\n}\n\nFor each race, count the number of record-beating ways to win:\n\nraces |&gt; \n  map_int(\\(race) sum(race_dist(race$time, 0:race$time) &gt; race$record)) |&gt; \n  prod()",
    "crumbs": [
      "2023",
      "Day 6"
    ]
  },
  {
    "objectID": "2023/R/day06.html#part-2",
    "href": "2023/R/day06.html#part-2",
    "title": "Day 6",
    "section": "Part 2",
    "text": "Part 2\nCombine the individual race numbers into one single race:\n\nrace &lt;- races |&gt; \n  enframe(name = \"pos\") |&gt; \n  unnest_wider(value) |&gt; \n  summarize(across(c(time, record), ~ as.numeric(str_c(.x, collapse = \"\")))) |&gt; \n  pivot_longer(everything()) |&gt; \n  deframe() |&gt; \n  as.list()\n\nCompute roots of the race distance function using the quadratic equation to determine the range of record-winning hold times:\n\nwinning_methods &lt;- function(time_race, record) {\n  root1 &lt;- (time_race + sqrt(time_race^2 - 4 * record)) / 2\n  root2 &lt;- (time_race - sqrt(time_race^2 - 4 * record)) / 2\n  \n  bnd_l &lt;- ceiling(max(min(root1, root2), 0))\n  bnd_r &lt;- floor(min(max(root1, root2), time_race))\n  \n  bnd_l &lt;- if_else(race_dist(time_race, bnd_l) == record, bnd_l + 1, bnd_l)\n  bnd_r &lt;- if_else(race_dist(time_race, bnd_r) == record, bnd_r - 1, bnd_r)\n  \n  bnd_r - bnd_l + 1\n}\n\nRun on puzzle input:\n\nwinning_methods(race$time, race$record)",
    "crumbs": [
      "2023",
      "Day 6"
    ]
  },
  {
    "objectID": "2023/R/day16.html",
    "href": "2023/R/day16.html",
    "title": "Day 16",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 16"
    ]
  },
  {
    "objectID": "2023/R/day16.html#setup",
    "href": "2023/R/day16.html#setup",
    "title": "Day 16",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 16"
    ]
  },
  {
    "objectID": "2023/R/day16.html#part-1",
    "href": "2023/R/day16.html#part-1",
    "title": "Day 16",
    "section": "Part 1",
    "text": "Part 1\nConvert text input to a character matrix:\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  map(~ matrix(.x, nrow = 1)) |&gt; \n  reduce(rbind)\n\nDefine a function that converts a direction, direction index, and sublocation along that direction into standard row/column form, then into a single ID value:\n\nmtx_id &lt;- function(dir, vec_idx, loc_idx) {\n  row &lt;- case_match(dir, c('W', 'E') ~ vec_idx, c('N', 'S') ~ loc_idx)\n  col &lt;- case_match(dir, c('W', 'E') ~ loc_idx, c('N', 'S') ~ vec_idx)\n  \n  (row - 1) * ncol(mtx) + col\n}\n\nDefine a function that tracks the beam through the matrix and returns the IDs of the elements visited:\n\nbeam &lt;- function(dir, vec_idx = 1, start_idx, visited) {\n  \n  if (!between(start_idx, 1, nrow(mtx))) return(visited)\n  \n  # Initialize\n  vec &lt;- if (dir %in% c('W', 'E')) mtx[vec_idx,] else mtx[,vec_idx]\n\n  end_idx      &lt;- case_match(dir, c('E', 'S') ~ length(vec), c('N', 'W') ~ 1)\n  chr_split    &lt;- case_match(dir, c('W', 'E') ~ '|',         c('N', 'S') ~ '-')\n  chr_turn_neg &lt;- case_match(dir, c('N', 'W') ~ '\\\\',        c('S', 'E') ~ '/')\n  chr_turn_pos &lt;- case_match(dir, c('N', 'W') ~ '/',         c('S', 'E') ~ '\\\\')\n  dir_split_1  &lt;- case_match(dir, c('W', 'E') ~ 'N',         c('N', 'S') ~ 'W')\n  dir_split_2  &lt;- case_match(dir, c('W', 'E') ~ 'S',         c('N', 'S') ~ 'E')\n  dir_turn_neg &lt;- case_match(dir, c('N', 'S') ~ 'W',         c('W', 'E') ~ 'N')\n  dir_turn_pos &lt;- case_match(dir, c('N', 'S') ~ 'E',         c('W', 'E') ~ 'S')\n  \n  for (i in start_idx:end_idx) {\n    \n    id &lt;- mtx_id(dir, vec_idx, i)\n    \n    if (id %in% visited[[dir]])\n      return(visited)\n    else\n      visited[[dir]] &lt;- c(visited[[dir]], id)\n    \n    if (vec[[i]] == chr_split) {\n      visited &lt;- beam(dir_split_1, i, vec_idx - 1, visited)\n      visited &lt;- beam(dir_split_2, i, vec_idx + 1, visited)\n      break\n    }\n    else if (vec[[i]] == chr_turn_neg) {\n      visited &lt;- beam(dir_turn_neg, i, vec_idx - 1, visited)\n      break\n    }\n    else if (vec[[i]] == chr_turn_pos) {\n      visited &lt;- beam(dir_turn_pos, i, vec_idx + 1, visited)\n      break\n    }\n  }\n  \n  visited\n}\n\nStarting from upper left, loop through the matrix and count the number of energized tiles:\n\ninit_visited &lt;- map(set_names(c(\"N\", \"S\", \"W\", \"E\")), ~ c())\n\nbeam(\"E\", vec_idx = 1, start_idx = 1, visited = init_visited) |&gt; \n  unlist() |&gt; \n  unique() |&gt; \n  length()",
    "crumbs": [
      "2023",
      "Day 16"
    ]
  },
  {
    "objectID": "2023/R/day16.html#part-2",
    "href": "2023/R/day16.html#part-2",
    "title": "Day 16",
    "section": "Part 2",
    "text": "Part 2\nIf the beam can enter from any edge, find the maximum number of energizable tiles:\n\nenergize_from &lt;- function(dir, vec_idx, start_idx) {\n  beam(dir, vec_idx, start_idx, init_visited) |&gt; \n    unlist() |&gt; \n    unique() |&gt; \n    length()\n}\n\nexpand_grid(dir = c('N', 'S', 'W', 'E'), vec = 1:nrow(mtx)) |&gt; \n  mutate(start = case_match(dir, c('S', 'E') ~ 1, c('N', 'W') ~ nrow(mtx))) |&gt; \n  pmap_dbl(\\(dir, vec, start) energize_from(dir, vec, start)) |&gt; \n  max()",
    "crumbs": [
      "2023",
      "Day 16"
    ]
  },
  {
    "objectID": "2023/R/day03.html",
    "href": "2023/R/day03.html",
    "title": "Day 3",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day03.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 3"
    ]
  },
  {
    "objectID": "2023/R/day03.html#setup",
    "href": "2023/R/day03.html#setup",
    "title": "Day 3",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day03.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 3"
    ]
  },
  {
    "objectID": "2023/R/day03.html#part-1",
    "href": "2023/R/day03.html#part-1",
    "title": "Day 3",
    "section": "Part 1",
    "text": "Part 1\nConvert the input strings into a character matrix for ease of indexing:\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  unlist() |&gt; \n  matrix(nrow = length(input), byrow = TRUE)\n\nmax_row &lt;- nrow(mtx)\nmax_col &lt;- ncol(mtx)\n\nIdentify all candidates for part numbers and their coordinates in the matrix representation of the input:\n\n# Pull all candidates from the text input\nparts &lt;- input |&gt; \n  str_extract_all(\"\\\\d+\") |&gt; \n  map(unique)\n\n# Compute the indices of each candidate within each input string\nparts_locations &lt;- map2(input, parts, \\(chr_row, row_parts) {\n  chr_row |&gt; \n    str_locate_all(str_c(\"\\\\b\", row_parts, \"\\\\b\")) |&gt;\n    map(partial(asplit, MARGIN = 1))\n})\n\nIdentify all neighbors of each part number candidate:\n\nparts_df &lt;- parts_locations |&gt; \n  \n  # Combine all candidates and their indices into a data frame of coordiantes\n  enframe(name = \"row\") |&gt; \n  unnest_longer(value, values_to = \"locations\", indices_to = \"part_id\") |&gt; \n  unnest_longer(locations, values_to = \"col_seq\", indices_to = \"loc_id\") |&gt; \n  mutate(col_seq = map(col_seq, partial(full_seq, period = 1))) |&gt; \n  left_join(\n    parts |&gt; \n      enframe(name = \"row\") |&gt; \n      unnest_longer(\n        value, \n        values_to = \"part_int\", \n        indices_to = \"part_id\", \n        transform = as.integer\n      ),\n    join_by(row, part_id)\n  ) |&gt; \n  mutate(part_id = cur_group_id(), .by = c(row, part_id, loc_id)) |&gt; \n  \n  # Pull the neighboring characters for every part in the input\n  mutate(\n    search_rows = map(row, \\(row) {\n      c(row - 1, row, row + 1) |&gt; \n        keep(partial(between, left = 1, right = max_row))\n    }),\n    search_cols = map(col_seq, \\(col_seq) {\n      c(min(col_seq) - 1, col_seq, max(col_seq) + 1) |&gt; \n        keep(partial(between, left = 1, right = max_row))\n    }),\n    neighbor = map2(search_rows, search_cols, \\(rows, cols) {\n      expand_grid(row = rows, col = cols) |&gt; \n        mutate(chr = map2_chr(row, col, \\(row, col) mtx[row, col]))\n    })\n  ) |&gt; \n  unnest(neighbor, names_sep = \"_\") |&gt; \n  \n  # Simplify into a list of part IDs, integer values, and neighboring chars\n  select(row, part_id, part_int, starts_with(\"neighbor\")) |&gt; \n  mutate(\n    neighbor_id = cur_group_id(), \n    .by = c(neighbor_row, neighbor_col),\n    .before = neighbor_chr\n  )\n\nPull all candidates that are true part numbers (have a neighboring symbol) and sum their values:\n\nparts_df |&gt; \n  filter(!str_detect(neighbor_chr, \"[0-9.]\")) |&gt; \n  distinct(part_id, part_int) |&gt; \n  pull(part_int) |&gt; \n  sum()",
    "crumbs": [
      "2023",
      "Day 3"
    ]
  },
  {
    "objectID": "2023/R/day03.html#part-2",
    "href": "2023/R/day03.html#part-2",
    "title": "Day 3",
    "section": "Part 2",
    "text": "Part 2\nPull symbols with exactly two adjacent parts, multiply the part integers to get each gear ratio, and sum the total of the gear ratios:\n\nparts_df |&gt; \n  filter(!str_detect(neighbor_chr, \"[0-9.]\")) |&gt; \n  filter(n() == 2, .by = neighbor_id) |&gt; \n  summarize(gear_ratio = prod(part_int), .by = neighbor_id) |&gt; \n  pull(gear_ratio) |&gt; \n  sum()",
    "crumbs": [
      "2023",
      "Day 3"
    ]
  },
  {
    "objectID": "2023/R/day01.html",
    "href": "2023/R/day01.html",
    "title": "Day 1",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day01.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 1"
    ]
  },
  {
    "objectID": "2023/R/day01.html#setup",
    "href": "2023/R/day01.html#setup",
    "title": "Day 1",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day01.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 1"
    ]
  },
  {
    "objectID": "2023/R/day01.html#part-1",
    "href": "2023/R/day01.html#part-1",
    "title": "Day 1",
    "section": "Part 1",
    "text": "Part 1\nExtract numbers from the text strings using regex and sum:\n\ninput |&gt; \n  str_extract_all(\"\\\\d\") |&gt; \n  map(as.integer) |&gt; \n  map_int(~ head(.x, 1) * 10 + tail(.x, 1)) |&gt; \n  sum()",
    "crumbs": [
      "2023",
      "Day 1"
    ]
  },
  {
    "objectID": "2023/R/day01.html#part-2",
    "href": "2023/R/day01.html#part-2",
    "title": "Day 1",
    "section": "Part 2",
    "text": "Part 2\nAdd patterns to the regex for spelled-out digits. Search from the front of the string as usual, but for the last digit, search from the end by reversing all strings. Otherwise, regex will only recognize the first match in case of an overlap: “eightwo” needs to be recognized as 82, not just 8.\n\ndigits &lt;- c(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\npattern_fwd &lt;- str_c(c(\"\\\\d\", digits), collapse = \"|\")\npattern_bwd &lt;- str_c(c(\"\\\\d\", stringi::stri_reverse(digits)), collapse = \"|\")\n\n# Match the first digit from the front of the string\nd1 &lt;- input |&gt; \n  str_extract(pattern_fwd)\n\n# Match the second digit from the end of the string\nd2 &lt;- input |&gt; \n  stringi::stri_reverse() |&gt; \n  str_extract(pattern_bwd) |&gt; \n  stringi::stri_reverse()\n\n# Convert to integer values and sum\nmap2(d1, d2, c) |&gt; \n  map(~ coalesce(parse_number(.x, na = digits), match(.x, digits))) |&gt; \n  map_int(~ head(.x, 1) * 10 + tail(.x, 1)) |&gt; \n  sum()",
    "crumbs": [
      "2023",
      "Day 1"
    ]
  },
  {
    "objectID": "2023/R/day25.html",
    "href": "2023/R/day25.html",
    "title": "Day 25",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day25.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 25"
    ]
  },
  {
    "objectID": "2023/R/day25.html#setup",
    "href": "2023/R/day25.html#setup",
    "title": "Day 25",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day25.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 25"
    ]
  },
  {
    "objectID": "2023/R/day25.html#part-1",
    "href": "2023/R/day25.html#part-1",
    "title": "Day 25",
    "section": "Part 1",
    "text": "Part 1\nConvert text input to a graph:\n\nwires &lt;- input |&gt; \n  str_split(\":? \") |&gt; \n  unlist() |&gt; \n  unique()\n\nedges &lt;- input |&gt; \n  unglue_data(\"{name}: {conn}\") |&gt; \n  mutate(conn = str_split(conn, \" \")) |&gt; \n  unnest_longer(conn) |&gt; \n  mutate(across(c(name, conn), ~ match(.x, wires))) |&gt; \n  pmap(\\(name, conn) c(name, conn)) |&gt; \n  unlist()\n\ng &lt;- make_graph(edges, directed = FALSE)\n\nCompute the betweenness of each edge and pull the three with the maximum values:\n\nscores &lt;- edge_betweenness(g)\nidx &lt;- scores |&gt; \n  sort(decreasing = TRUE) |&gt; \n  head(3) |&gt; \n  match(scores)\n\nPlot for visual confirmation:\n\nedge_colors &lt;- E(g) |&gt; \n  as.numeric() |&gt; \n  case_match(idx ~ \"blue\", .default = \"grey\")\n\nplot(g, vertex.size = 4, vertex.label = NA, edge.color = edge_colors)\n\n\n\n\n\n\n\n\nRemove the selected vertices from the graph, then calculate the product of the size of its two disconnected groups:\n\ng |&gt; \n  delete_edges(idx) |&gt; \n  components() |&gt; \n  pluck(\"csize\") |&gt; \n  prod()",
    "crumbs": [
      "2023",
      "Day 25"
    ]
  },
  {
    "objectID": "2023/R/day18.html",
    "href": "2023/R/day18.html",
    "title": "Day 18",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(sf)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day18.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\"{dir} {meters} ({color})\", convert = TRUE)",
    "crumbs": [
      "2023",
      "Day 18"
    ]
  },
  {
    "objectID": "2023/R/day18.html#setup",
    "href": "2023/R/day18.html#setup",
    "title": "Day 18",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(sf)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day18.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\"{dir} {meters} ({color})\", convert = TRUE)",
    "crumbs": [
      "2023",
      "Day 18"
    ]
  },
  {
    "objectID": "2023/R/day18.html#part-1",
    "href": "2023/R/day18.html#part-1",
    "title": "Day 18",
    "section": "Part 1",
    "text": "Part 1\nConvert the instruction input into list of corners that define the trench polygon:\n\ntrench &lt;- input |&gt;\n  mutate(\n    x = case_match(dir, c('U', 'D') ~ 0, 'L' ~ -1, 'R' ~ 1) * meters,\n    y = case_match(dir, c('L', 'R') ~ 0, 'D' ~ -1, 'U' ~ 1) * meters\n  ) |&gt; \n  pmap(\\(x, y, ...) c(x = x, y = y)) |&gt; \n  accumulate(`+`, .init = c(x = 0, y = 0))\n\nConvert the polygon’s boundary to a spatial object using SF:\n\npolygon &lt;- trench |&gt;\n  reduce(rbind) |&gt; \n  list() |&gt; \n  st_polygon() |&gt; \n  st_buffer(dist = 0.5, joinStyle = 'MITRE', mitreLimit = sqrt(2))\n\nggplot(polygon) + \n  geom_sf() +\n  theme_void()\n\n\n\n\n\n\n\n\nCompute the polygon’s area:\n\nst_area(polygon)",
    "crumbs": [
      "2023",
      "Day 18"
    ]
  },
  {
    "objectID": "2023/R/day18.html#part-2",
    "href": "2023/R/day18.html#part-2",
    "title": "Day 18",
    "section": "Part 2",
    "text": "Part 2\nConvert the hex codes to new trench instructions:\n\ntrench &lt;- input |&gt; \n  mutate(\n    meters = strtoi(str_sub(color, 2L, -2L), base = 16L),\n    dir = case_match(\n      str_sub(color, start = -1L),\n      '0' ~ 'R', '1' ~ 'D', '2' ~ 'L', '3' ~ 'U'\n    ),\n    x = case_match(dir, c('U', 'D') ~ 0, 'L' ~ -1, 'R' ~ 1) * meters,\n    y = case_match(dir, c('L', 'R') ~ 0, 'D' ~ -1, 'U' ~ 1) * meters\n  ) |&gt; \n  pmap(\\(x, y, ...) c(x = x, y = y)) |&gt; \n  accumulate(`+`, .init = c(x = 0, y = 0))\n\nConvert to a new polygon:\n\npolygon &lt;- trench |&gt;\n  reduce(rbind) |&gt; \n  list() |&gt; \n  st_polygon() |&gt; \n  st_buffer(dist = 0.5, joinStyle = 'MITRE', mitreLimit = sqrt(2))\n\nggplot(polygon) + \n  geom_sf() +\n  theme_void()\n\n\n\n\n\n\n\n\nCompute the polygon’s area:\n\nst_area(polygon) |&gt; \n  format(scientific = FALSE)",
    "crumbs": [
      "2023",
      "Day 18"
    ]
  },
  {
    "objectID": "2023/R/day23.html",
    "href": "2023/R/day23.html",
    "title": "Day 23",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day23.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 23"
    ]
  },
  {
    "objectID": "2023/R/day23.html#setup",
    "href": "2023/R/day23.html#setup",
    "title": "Day 23",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day23.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 23"
    ]
  },
  {
    "objectID": "2023/R/day23.html#part-1",
    "href": "2023/R/day23.html#part-1",
    "title": "Day 23",
    "section": "Part 1",
    "text": "Part 1\nConvert text input to a directed graph:\n\n# Convert to a dataframe with IDs and coordinates per cell\ndf &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  enframe(name = \"row\") |&gt; \n  unnest_longer(value, indices_to = \"col\") |&gt; \n  mutate(id = row_number()) |&gt; \n  filter(value != '#') |&gt; \n  relocate(id, value, row, col)\n\n# Compute the list of directed edges between cells\nedges &lt;- df |&gt; \n  mutate(\n    row_n = row - 1,\n    row_s = row + 1,\n    col_w = col - 1,\n    col_e = col + 1\n  ) |&gt; \n  left_join(df, join_by(x$row_n == y$row, col), suffix = c(\"\", \"_n\")) |&gt; \n  left_join(df, join_by(x$row_s == y$row, col), suffix = c(\"\", \"_s\")) |&gt; \n  left_join(df, join_by(x$col_w == y$col, row), suffix = c(\"\", \"_w\")) |&gt; \n  left_join(df, join_by(x$col_e == y$col, row), suffix = c(\"\", \"_e\")) |&gt; \n  select(-starts_with(c(\"row\", \"col\", \"value_\"))) |&gt; \n  pivot_longer(\n    starts_with(\"id_\"),\n    names_to = \"dir\",\n    values_to = \"neighbor\",\n    names_prefix = \"id_\"\n  ) |&gt; \n  \n  # For slope tiles, remove any non-downhill neighbors\n  filter(\n    (value == \".\" & !is.na(neighbor)) |\n      (value == \"^\" & dir == \"n\") | \n      (value == \"v\" & dir == \"s\") |\n      (value == \"&lt;\" & dir == \"w\") | \n      (value == \"&gt;\" & dir == \"e\") \n  ) |&gt; \n  pmap(\\(id, neighbor, ...) c(id, neighbor)) |&gt; \n  unlist()\n\n# Convert to a graph\ng &lt;- make_graph(edges)\n\nFind the longest possible path from the start point to the end point:\n\nsource &lt;- min(df$id)\ntarget &lt;- max(df$id)\n\nmax_hike &lt;- function(g, from = source, to = target) {\n  all_simple_paths(g, from, to) |&gt; \n    map_dbl(~ length(.x) - 1) |&gt; \n    sort(decreasing = TRUE) |&gt; \n    max()\n}\n\nmax_hike(g)",
    "crumbs": [
      "2023",
      "Day 23"
    ]
  },
  {
    "objectID": "2023/R/day23.html#part-2",
    "href": "2023/R/day23.html#part-2",
    "title": "Day 23",
    "section": "Part 2",
    "text": "Part 2\nConvert to an undirected graph to remove the slope constraint:\n\ng &lt;- as_undirected(g)\nV(g)$name &lt;- V(g)\n\nThe graph is too large to simply run the hike length function again – an overflow results.\nInstead, we notice that the input maze consists of relatively few intersections. Most of the maze input is simple corridors with no path decisions. We can reduce the graph complexity/size by trimming away our non-choice verftices and converting the length of those paths to an edge weight.\n\nv_zero_edges   &lt;- names(which(degree(g) == 0))\nv_two_edges    &lt;- names(which(degree(g) == 2))\nv_nontwo_edges &lt;- names(which(degree(g) != 2))\n\n# Extract all corridor vertices\ng_corridors &lt;- delete_vertices(g, v_nontwo_edges)\ncorridors &lt;- components(g_corridors)\n\n# Determine which edges to add to replace the corridors and their weight\nnew_weights &lt;- corridors$csize + 1\nnew_edges &lt;- corridors$membership |&gt; \n  keep_at(names(which(degree(g_corridors) == 1))) |&gt; \n  enframe(name = \"vtx\", value = \"group\") |&gt; \n  mutate(vtx = map_chr(vtx, ~ setdiff(names(neighbors(g, .x)), v_two_edges))) |&gt; \n  summarize(edge = list(vtx), .by = group) |&gt; \n  arrange(group) |&gt; \n  pull(edge)\n\n# Create a new graph without the corridor vertices, then add its new edges\ng_new &lt;- reduce2(\n  .x = new_edges,\n  .y = new_weights,\n  .f = \\(g, e, w) add_edges(g, e, weight = w),\n  .init = delete_vertices(g, c(v_zero_edges, v_two_edges))\n)\n\nView a plot of the resulting simplified graph:\n\nvtx_labels &lt;- g_new |&gt; \n  V() |&gt; \n  names() |&gt; \n  case_match(\n    as.character(source) ~ \"S\", \n    as.character(target) ~ \"E\", \n    .default = \"\"\n  )\n\nplot(\n  g_new, \n  vertex.size = 8,\n  vertex.label = vtx_labels, \n  edge.label = E(g_new)$weight\n)\n\n\n\n\n\n\n\n\nCompute all paths from the start to the end using our smaller graph:\n\nall_paths &lt;- g_new |&gt; \n  all_simple_paths(as.character(source), as.character(target))\n\nUsing the edge weights of our graph, compute the total length of each path and select the longest:\n\nall_paths |&gt; \n  map(\n    ~ .x |&gt; \n      as_ids() |&gt; \n      rep(each = 2) |&gt; \n      head(-1) |&gt; \n      tail(-1) |&gt; \n      get_edge_ids(graph = g_new)\n  ) |&gt; \n  map(~ E(g_new)$weight[.x]) |&gt; \n  map_dbl(sum) |&gt; \n  max()",
    "crumbs": [
      "2023",
      "Day 23"
    ]
  },
  {
    "objectID": "2023/R/day08.html",
    "href": "2023/R/day08.html",
    "title": "Day 8",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day08.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 8"
    ]
  },
  {
    "objectID": "2023/R/day08.html#setup",
    "href": "2023/R/day08.html#setup",
    "title": "Day 8",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day08.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 8"
    ]
  },
  {
    "objectID": "2023/R/day08.html#part-1",
    "href": "2023/R/day08.html#part-1",
    "title": "Day 8",
    "section": "Part 1",
    "text": "Part 1\nParse input text into sets of left/right instructions and the maps of the node network:\n\ninstructions &lt;- input |&gt; \n  head(1) |&gt; \n  str_split_1(\"\")\n\nnetwork &lt;- input |&gt; \n  tail(-1) |&gt; \n  unglue_data(\"{node} = ({L}, {R})\") |&gt; \n  nest(LR = c(L, R)) |&gt; \n  mutate(LR = map(LR, as.list)) |&gt; \n  deframe()\n\nStarting at the AAA node, advance through the list of instructions until the ZZZ node is reached:\n\n# Initialize\nn_rep    &lt;- length(instructions)\ncur_node &lt;- \"AAA\"\ni        &lt;- 0\n\nrepeat {\n  if (cur_node == \"ZZZ\") break\n  \n  cur_dir  &lt;- instructions[i %% n_rep + 1]\n  cur_node &lt;- network[[cur_node]][[cur_dir]]\n  i &lt;- i + 1\n}\n\ni",
    "crumbs": [
      "2023",
      "Day 8"
    ]
  },
  {
    "objectID": "2023/R/day08.html#part-2",
    "href": "2023/R/day08.html#part-2",
    "title": "Day 8",
    "section": "Part 2",
    "text": "Part 2\nFor each node ending with ‘A’, compute the number of necessary steps until it reaches a node ending with ‘Z’ and loops.\n\nsteps_to_z &lt;- function(node_start) {\n\n  # Initialize\n  cur_node &lt;- node_start\n  i        &lt;- 0\n  \n  repeat {\n    if (str_ends(cur_node, \"Z\")) return(i)\n    \n    cur_dir  &lt;- instructions[i %% n_rep + 1]\n    cur_node &lt;- network[[cur_node]][[cur_dir]]\n    i &lt;- i + 1\n  }\n}\n\ncycles &lt;- names(network) |&gt; \n  keep(~ str_ends(.x, \"A\")) |&gt; \n  map_dbl(steps_to_z)\n\nTake the least common multiple of the result:\n\nreduce(cycles, numbers::LCM) |&gt; \n  format(scientific = FALSE)",
    "crumbs": [
      "2023",
      "Day 8"
    ]
  },
  {
    "objectID": "2023/R/day21.html",
    "href": "2023/R/day21.html",
    "title": "Day 21",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day21.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 21"
    ]
  },
  {
    "objectID": "2023/R/day21.html#setup",
    "href": "2023/R/day21.html#setup",
    "title": "Day 21",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day21.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 21"
    ]
  },
  {
    "objectID": "2023/R/day21.html#part-1",
    "href": "2023/R/day21.html#part-1",
    "title": "Day 21",
    "section": "Part 1",
    "text": "Part 1\nConvert text input to a graph:\n\n# Convert text input to grid coordinates\ndf &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  enframe(name = \"row\") |&gt; \n  unnest_longer(value, indices_to = \"col\") |&gt; \n  mutate(id = row_number())\n\nvertices &lt;- pull(df, value)\n\n# Compute edges for all cells to convert to a graph\nneighbors &lt;- df |&gt;\n  mutate(\n    n = case_when(lag(value)  != '#' ~ lag(id)),\n    s = case_when(lead(value) != '#' ~ lead(id)),\n    .by = col\n  ) |&gt; \n  mutate(\n    w = case_when(lag(value)  != '#' ~ lag(id)),\n    e = case_when(lead(value) != '#' ~ lead(id)),\n    .by = row\n  ) |&gt; \n  filter(value != '#') |&gt; \n  select(id, n, s, w, e) |&gt; \n  pivot_longer(\n    c(n, s, w, e),\n    names_to = \"dir\", \n    values_to = \"neighbor\", \n    values_drop_na = TRUE\n  ) |&gt; \n  summarize(neighbors = list(neighbor), .by = id) |&gt; \n  complete(id = 1:length(vertices)) |&gt; \n  pull(neighbors) |&gt; \n  map(sort)\n\nFor 64 steps, loop through neighbors to find possible locations:\n\nnum_plots &lt;- function(start, n_steps) {\n  locs &lt;- start\n  for (i in 1:n_steps) {\n    locs &lt;- neighbors |&gt; \n      keep_at(locs) |&gt; \n      unlist() |&gt; \n      unique()\n  }\n  length(locs)\n}\n\nnum_plots(match('S', vertices), 64)",
    "crumbs": [
      "2023",
      "Day 21"
    ]
  },
  {
    "objectID": "2023/R/day21.html#part-2",
    "href": "2023/R/day21.html#part-2",
    "title": "Day 21",
    "section": "Part 2",
    "text": "Part 2\nSince there are no obstacles in the center row or column (where the starting position is), we can easily compute how quickly it takes to enter a given “box” (repeat of the map) and from which direction we enter.\nFirst, we compute the number of steps it takes for a given box to enter a periodic cycle, depending on whether its starting location is from the center starting point, the middle of an edge, or a corner:\n\nfind_cycle &lt;- function(start_vtx) {\n  locs_prv &lt;- NULL\n  locs_cur &lt;- start_vtx\n  i &lt;- 0\n\n  repeat {\n    locs_new &lt;- neighbors |&gt; \n      keep_at(locs_cur) |&gt; \n      unlist() |&gt; \n      unique() |&gt; \n      sort()\n    \n    if (identical(locs_prv, locs_new)) \n      return(i - 1)\n    \n    locs_prv &lt;- locs_cur\n    locs_cur &lt;- locs_new\n    i &lt;- i + 1\n  }\n}\n\nw_max &lt;- max(df$col)\nw_mid &lt;- ceiling(w_max / 2)\n\nstarting_points &lt;- df |&gt; \n  mutate(name = case_when(\n    value == 'S' ~ 'center',\n    col == w_mid & row == 1     ~ 'n',\n    col == w_mid & row == w_max ~ 's',\n    row == w_mid & col == 1     ~ 'w',\n    row == w_mid & col == w_max ~ 'e',\n    col == 1     & row == 1     ~ 'nw',\n    col == w_max & row == 1     ~ 'ne',\n    col == 1     & row == w_max ~ 'sw',\n    col == w_max & row == w_max ~ 'se'\n  )) |&gt; \n  filter(!is.na(name)) |&gt; \n  select(name, id) |&gt; \n  deframe()\n\n# Determine when a cycle first occurs for the center, mid-edge, and corner pieces\ncycles &lt;- map(\n  c(\n    corner   = starting_points[[\"nw\"]],\n    mid_edge = starting_points[[\"n\"]],\n    center   = starting_points[[\"center\"]]\n  ), \n  find_cycle\n)\n\nNext, we split our total map into different box types. Boxes along the same horizontal/vertical lines as the initial starting point will always be entered from a mid-edge plot. All other boxes – those along the diagonal/off-diagonal – will be entered from the corner closest to the origin.\nWe can map the non-straight-line boxes as concentric rings indicating their Manhattan distance from the origin:\n  3X3\n 32X23\n321X123\nXXX.XXX\n321X123\n 32X23\n  3X3\nNote that in each quadrant, there’s 1 box 1 unit from the origin, 2 boxes 2 units away, 3 boxes 3 units away, etc. Meanwhile, for the straight-line boxes, there’s only one box along each axis of its distance from the origin.\nFinally, we also have to take into account the fact that the periodic cycles alternate between odd and even steps. The number of plots in a box at a given step number depends on whether we entered that box on an even or an odd step. Below, all boxes entered on an odd step are labeled as A-type boxes, and those entered on an even step are B-type.\nThe number of plots in a cycling box are straightforward to compute. However, when a box is entered near the last of the steps and doesn’t have enough time to enter a cycle, we have to compute its current number of plots separately at the time the simulation ends.\nWe begin with the diagonal/off-diagonal boxes:\n\nn &lt;- 26501365\n\nrings_reached     &lt;- ceiling(n / w_max - 1)\nrings_cycling     &lt;- ceiling((n - cycles$corner) / w_max - 1)\nrings_in_progress &lt;- (rings_cycling + 1):rings_reached\n\n# Compute the current value for the non-cycling diags\nplots_in_progress &lt;- starting_points |&gt; \n  keep_at(c(\"nw\", \"ne\", \"sw\", \"se\")) |&gt; \n  map(\\(init_idx) {\n    rings_in_progress |&gt; \n      # Compute the step when each ring was entered from its corner\n      map_dbl(~ w_max * .x + 1) |&gt; \n      # Compute how many steps into the cycle each box currently is\n      map_dbl(~ n - .x) |&gt; \n      map_dbl(~ num_plots(init_idx, .x))\n  }) |&gt; \n  map(~ .x * rings_in_progress) |&gt; \n  map_dbl(sum)\n\n# Compute the current value for the cycling diags\ncycling_a &lt;- (1:rings_cycling) |&gt; \n  keep(~ .x %% 2 == 0) |&gt; \n  sum()\n\ncycling_b &lt;- (1:rings_cycling) |&gt; \n  keep(~ .x %% 2 == 1) |&gt; \n  sum()\n\ncycle_steps_even &lt;- cycles$corner + if_else(cycles$corner %% 2 == 0, 0, 1)\ncycle_steps_odd  &lt;- cycles$corner + if_else(cycles$corner %% 2 == 0, 1, 0)\n\nplots_a &lt;- cycling_a * num_plots(1, cycle_steps_even)\nplots_b &lt;- cycling_b * num_plots(1, cycle_steps_odd)\n\nplots_cycling &lt;- plots_a + plots_b\n\n# Compute total value of all diagonal boxes\nplots_diag &lt;- 4 * plots_cycling + sum(plots_in_progress)\n\nNow repeat for the straight-line boxes:\n\nstraights_reached     &lt;- ceiling((n + w_mid) / w_max - 1)\nstraights_cycling     &lt;- ceiling((n + w_mid - cycles$mid_edge) / w_max - 1)\nstraights_in_progress &lt;- (straights_cycling + 1):straights_reached\n\n# Compute the current value for the non-cycling straights\nplots_in_progress &lt;- starting_points |&gt; \n  keep_at(c(\"n\", \"s\", \"w\", \"e\")) |&gt; \n  map_dbl(\\(init_idx) {\n    straights_in_progress |&gt; \n      # Compute the step number when each box was entered from the edge\n      map_dbl(~ w_max * .x - w_mid + 1) |&gt; \n      # Compute how many steps into the cycle each box currently is\n      map_dbl(~ n - .x) |&gt; \n      map_dbl(~ num_plots(init_idx, .x)) |&gt; \n      sum()\n  })\n\n# Compute the current value for the cycling straights\ncycling_a &lt;- (1:straights_cycling) |&gt; \n  keep(~ .x %% 2 == 0) |&gt; \n  length()\n\ncycling_b &lt;- (1:straights_cycling) |&gt; \n  keep(~ .x %% 2 == 1) |&gt; \n  length()\n\ncycle_steps_even &lt;- cycles$mid_edge + if_else(cycles$mid_edge %% 2 == 0, 0, 1)\ncycle_steps_odd  &lt;- cycles$mid_edge + if_else(cycles$mid_edge %% 2 == 0, 1, 0)\n\nplots_a &lt;- cycling_a * num_plots(w_mid, cycle_steps_even)\nplots_b &lt;- cycling_b * num_plots(w_mid, cycle_steps_odd)\n\nplots_cycling  &lt;- plots_a + plots_b\n\n# Compute total value of all straight-line boxes\nplots_straight &lt;- 4 * plots_cycling + sum(plots_in_progress)\n\nFinally, compute the value for the center box:\n\ncycle_steps_odd &lt;- if_else(cycles$center %% 2 == 0, 1, 0) + cycles$center\nplots_center &lt;- num_plots(match('S', vertices), cycle_steps_odd)\n\nSum to get the final result:\n\nformat(plots_center + plots_straight + plots_diag, scientific = FALSE)",
    "crumbs": [
      "2023",
      "Day 21"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advent of Code: Worked Solutions",
    "section": "",
    "text": "Solutions in R to the Advent of Code – a yearly advent calendar of programming puzzles.\nConcepts include:\n\nText parsing (including regex)\nGraph traversal\nPathfinding\nBreadth-first and depth-first search\nMemoization\nOptimization\nBitwise arithmetic\nModular arithmetic"
  },
  {
    "objectID": "2021/R/day10.html",
    "href": "2021/R/day10.html",
    "title": "Day 10",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day10.txt\") |&gt; \n  str_split(\"\")",
    "crumbs": [
      "2021",
      "Day 10"
    ]
  },
  {
    "objectID": "2021/R/day10.html#setup",
    "href": "2021/R/day10.html#setup",
    "title": "Day 10",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day10.txt\") |&gt; \n  str_split(\"\")",
    "crumbs": [
      "2021",
      "Day 10"
    ]
  },
  {
    "objectID": "2021/R/day10.html#part-1",
    "href": "2021/R/day10.html#part-1",
    "title": "Day 10",
    "section": "Part 1",
    "text": "Part 1\nDefine our open/close bracket pairs and the scores for each type:\n\nb_open  &lt;- c(\"(\", \"[\", \"{\", \"&lt;\")\nb_close &lt;- c(\")\", \"]\", \"}\", \"&gt;\")\nb_pairs &lt;- c(set_names(b_close, b_open), set_names(b_open, b_close))\nb_score &lt;- set_names(c(3, 57, 1197, 25137), b_close)\n\nDefine a function to move through a line, add/remove brackets to a stack, and return the first invalid closing bracket found.\n\ncheck_line &lt;- function(x) {\n  stack &lt;- c()\n  for (chr in x) {\n    if (chr %in% b_open)\n      stack &lt;- c(stack, chr)\n    else if (tail(stack, 1) == b_pairs[chr])\n      stack &lt;- head(stack, -1)\n    else\n      return(chr)\n  }\n}\n\nIdentify which lines have mistakes:\n\nscanned &lt;- input |&gt; \n  map(check_line)\n\nSum the total score for all mistakes:\n\nscanned |&gt; \n  unlist() |&gt; \n  map_int(~ b_score[[.x]]) |&gt; \n  sum()",
    "crumbs": [
      "2021",
      "Day 10"
    ]
  },
  {
    "objectID": "2021/R/day10.html#part-2",
    "href": "2021/R/day10.html#part-2",
    "title": "Day 10",
    "section": "Part 2",
    "text": "Part 2\nModify the point values for each closing bracket:\n\nb_score &lt;- set_names(1:4, b_close)\n\nAlter the line-scanning function to return the autocomplete brackets:\n\ncomplete_line &lt;- function(x) {\n  stack &lt;- c()\n  for (chr in x) {\n    if (chr %in% b_open)\n      stack &lt;- c(stack, chr)\n    else if (tail(stack, 1) == b_pairs[chr])\n      stack &lt;- head(stack, -1)\n  }\n  \n  return(unname(b_pairs[rev(stack)]))\n}\n\nDefine a function to score a given completion string:\n\nscore_autocomplete &lt;- \\(x) reduce(x, ~ .x * 5 + b_score[[.y]], .init = 0)\n\nAutocomplete all non-error inputs, score the results, then take the median:\n\nis_incomplete &lt;- map_lgl(scanned, is.null)\n\ninput |&gt; \n  keep(is_incomplete) |&gt; \n  map(complete_line) |&gt; \n  map_dbl(score_autocomplete) |&gt; \n  median()",
    "crumbs": [
      "2021",
      "Day 10"
    ]
  },
  {
    "objectID": "2021/R/day05.html",
    "href": "2021/R/day05.html",
    "title": "Day 5",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day05.txt\")\n\nConvert plain-text input to a dataframe of numeric values:\n\ninput_df &lt;- input |&gt; \n  unglue_data(\"{x1=\\\\d+},{y1=\\\\d+} -&gt; {x2=\\\\d+},{y2=\\\\d+}\", convert = TRUE) |&gt; \n  mutate(id = row_number(), .before = everything())",
    "crumbs": [
      "2021",
      "Day 5"
    ]
  },
  {
    "objectID": "2021/R/day05.html#setup",
    "href": "2021/R/day05.html#setup",
    "title": "Day 5",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day05.txt\")\n\nConvert plain-text input to a dataframe of numeric values:\n\ninput_df &lt;- input |&gt; \n  unglue_data(\"{x1=\\\\d+},{y1=\\\\d+} -&gt; {x2=\\\\d+},{y2=\\\\d+}\", convert = TRUE) |&gt; \n  mutate(id = row_number(), .before = everything())",
    "crumbs": [
      "2021",
      "Day 5"
    ]
  },
  {
    "objectID": "2021/R/day05.html#part-1",
    "href": "2021/R/day05.html#part-1",
    "title": "Day 5",
    "section": "Part 1",
    "text": "Part 1\nFlag each line segment as horizontal, vertical or diagonal. Then, compute the list of all integer points that fall along the line.\n\nlines &lt;- input_df |&gt; \n  mutate(\n    type = case_when(\n      x1 == x2 ~ \"v\",\n      y1 == y2 ~ \"h\",\n      .default = \"d\"\n    ),\n    x = map2(x1, x2, ~ seq(..1, ..2)),\n    y = map2(y1, y2, ~ seq(..1, ..2))\n  ) |&gt; \n  unnest(cols = c(x, y))\n\nCompute the number of points that are covered by at least 2 overlapping horizontal or vertical lines (diagonals excluded):\n\nlines |&gt; \n  filter(type %in% c(\"v\", \"h\")) |&gt; \n  summarize(n = n(), .by = c(x, y)) |&gt; \n  filter(n &gt; 1) |&gt; \n  nrow()",
    "crumbs": [
      "2021",
      "Day 5"
    ]
  },
  {
    "objectID": "2021/R/day05.html#part-2",
    "href": "2021/R/day05.html#part-2",
    "title": "Day 5",
    "section": "Part 2",
    "text": "Part 2\nRepeat the count of overlapping points, now allowing diagonals:\n\nlines |&gt; \n  summarize(n = n(), .by = c(x, y)) |&gt; \n  filter(n &gt; 1) |&gt; \n  nrow()",
    "crumbs": [
      "2021",
      "Day 5"
    ]
  },
  {
    "objectID": "2021/R/day07.html",
    "href": "2021/R/day07.html",
    "title": "Day 7",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- scan(\"../input/day07.txt\", sep = \",\", quiet = TRUE)",
    "crumbs": [
      "2021",
      "Day 7"
    ]
  },
  {
    "objectID": "2021/R/day07.html#setup",
    "href": "2021/R/day07.html#setup",
    "title": "Day 7",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- scan(\"../input/day07.txt\", sep = \",\", quiet = TRUE)",
    "crumbs": [
      "2021",
      "Day 7"
    ]
  },
  {
    "objectID": "2021/R/day07.html#part-1",
    "href": "2021/R/day07.html#part-1",
    "title": "Day 7",
    "section": "Part 1",
    "text": "Part 1\nWe define the cost function as the sum of the absolute differences between our given point and all crabs:\n\ncost &lt;- \\(x) sum(abs(x - input))\n\nWe define the set of candidates for the optimal alignment location:\n\ncandidates &lt;- min(input):max(input)\n\nThe total fuel cost is computed by minimizing the cost function over all candidates:\n\ncandidates |&gt; \n  map_dbl(cost) |&gt; \n  min()",
    "crumbs": [
      "2021",
      "Day 7"
    ]
  },
  {
    "objectID": "2021/R/day07.html#part-2",
    "href": "2021/R/day07.html#part-2",
    "title": "Day 7",
    "section": "Part 2",
    "text": "Part 2\nInstead of the basic absolute difference function, our new distance function for each crab \\(c_i\\) is given by the binomial coefficient:\n\\[\n1 + 2 + \\cdots + |x - c_i| = \\sum_{k = 1}^{|x - c_i|}k  = \\binom{|x - c_i| + 1}{2}\n\\]\n\ncost &lt;- \\(x) sum(choose(abs(x - input) + 1, 2))\n\nRepeating the computation with our new cost function, we get:\n\ncandidates |&gt; \n  map_dbl(cost) |&gt; \n  min()",
    "crumbs": [
      "2021",
      "Day 7"
    ]
  },
  {
    "objectID": "2021/R/day12.html",
    "href": "2021/R/day12.html",
    "title": "Day 12",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_delim(\n  \"../input/day12.txt\", \n  delim = '-', \n  col_names = c(\"source\", \"target\"),\n  show_col_types = FALSE\n)",
    "crumbs": [
      "2021",
      "Day 12"
    ]
  },
  {
    "objectID": "2021/R/day12.html#setup",
    "href": "2021/R/day12.html#setup",
    "title": "Day 12",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_delim(\n  \"../input/day12.txt\", \n  delim = '-', \n  col_names = c(\"source\", \"target\"),\n  show_col_types = FALSE\n)",
    "crumbs": [
      "2021",
      "Day 12"
    ]
  },
  {
    "objectID": "2021/R/day12.html#part-1",
    "href": "2021/R/day12.html#part-1",
    "title": "Day 12",
    "section": "Part 1",
    "text": "Part 1\nConvert input to a data frame of edges for every vertex (disallowing returns to the “start” vertex and departures from the “end” vertex):\n\nadj &lt;- bind_rows(\n  input,\n  select(input, target = source, source = target)\n) |&gt; \n  filter(target != \"start\" & source != \"end\") |&gt; \n  arrange(source, target)\n\nsmall_caves &lt;- adj$source |&gt; \n  keep(~ .x == str_to_lower(.x)) |&gt; \n  discard(~ .x == \"start\") |&gt; \n  unique()\n\nBeginning from the ‘start’ node, expand outward until the ‘end’ node is found in each tree. End the search early if a small cave is visited more than once or no valid options remain.\n\ninvalid &lt;- function(path) {\n  any(duplicated(keep(path, ~ .x %in% small_caves)))\n}\n\nfind_paths &lt;- function(adj, cur_path = \"start\") {\n  \n  src &lt;- tail(cur_path, 1)\n  \n  if (src == \"end\")\n    return(list(cur_path))\n  if (invalid(cur_path))\n    return(list())\n  \n  paths &lt;- list()\n  nxt &lt;- adj |&gt; \n    filter(source == src) |&gt; \n    pull(target)\n  \n  for (vtx in nxt)\n    paths &lt;- c(paths, find_paths(adj, c(cur_path, vtx)))\n  \n  return(paths)\n}\n\nCompute the total number of paths for the puzzle input:\n\nfind_paths(adj) |&gt; \n  length()",
    "crumbs": [
      "2021",
      "Day 12"
    ]
  },
  {
    "objectID": "2021/R/day12.html#part-2",
    "href": "2021/R/day12.html#part-2",
    "title": "Day 12",
    "section": "Part 2",
    "text": "Part 2\nModify the invalid function to allow up to two visits to any one small cave:\n\ninvalid &lt;- function(path) {\n  counts &lt;- path |&gt; \n    keep(~ .x %in% small_caves) |&gt; \n    sort() |&gt; \n    rle()\n  \n  max(counts$lengths) &gt; 2 | sum(counts$lengths == 2) &gt; 1\n}\n\nRe-run on puzzle input:\n\nfind_paths(adj) |&gt; \n  length()",
    "crumbs": [
      "2021",
      "Day 12"
    ]
  },
  {
    "objectID": "2021/R/day02.html",
    "href": "2021/R/day02.html",
    "title": "Day 2",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_delim(\n  \"../input/day02.txt\", \n  delim = \" \", \n  col_names = c(\"dir\", \"value\"),\n  show_col_types = FALSE\n)",
    "crumbs": [
      "2021",
      "Day 2"
    ]
  },
  {
    "objectID": "2021/R/day02.html#setup",
    "href": "2021/R/day02.html#setup",
    "title": "Day 2",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file:\n\ninput &lt;- read_delim(\n  \"../input/day02.txt\", \n  delim = \" \", \n  col_names = c(\"dir\", \"value\"),\n  show_col_types = FALSE\n)",
    "crumbs": [
      "2021",
      "Day 2"
    ]
  },
  {
    "objectID": "2021/R/day02.html#part-1",
    "href": "2021/R/day02.html#part-1",
    "title": "Day 2",
    "section": "Part 1",
    "text": "Part 1\nConvert input values to final horizontal positions and depth values:\n\npos &lt;- input |&gt; \n  transmute(\n    dim   = case_match(dir, \"forward\" ~ \"horiz\", c(\"up\", \"down\") ~ \"depth\"),\n    value = case_match(dir, \"up\" ~ -value, .default = value)\n  ) |&gt; \n  summarize(value = sum(value), .by = dim)\n\nCompute product of final horizontal position and depth:\n\nprod(pos$value)",
    "crumbs": [
      "2021",
      "Day 2"
    ]
  },
  {
    "objectID": "2021/R/day02.html#part-2",
    "href": "2021/R/day02.html#part-2",
    "title": "Day 2",
    "section": "Part 2",
    "text": "Part 2\nCompute final horizontal position and depth value using the modified keyword meanings:\n\npos &lt;- input |&gt; \n  transmute(\n    aim   = cumsum(case_match(dir, \"down\" ~ value, \"up\" ~ -value, .default = 0)),\n    horiz = cumsum(case_match(dir, \"forward\" ~ value,             .default = 0)),\n    depth = cumsum(case_match(dir, \"forward\" ~ value * aim,       .default = 0))\n  ) |&gt; \n  select(horiz, depth) |&gt; \n  tail(n = 1)\n\nCompute product of final horizontal position and depth:\n\npos$horiz * pos$depth",
    "crumbs": [
      "2021",
      "Day 2"
    ]
  },
  {
    "objectID": "2021/R/day17.html",
    "href": "2021/R/day17.html",
    "title": "Day 17",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead input from file:\n\ninput &lt;- read_lines(file = \"../input/day17.txt\")\n\nExtract numeric bounds from text input:\n\ntarget &lt;- unglue_data(\n  input,\n  \"target area: x={xmin}..{xmax}, y={ymin}..{ymax}\", \n  convert = TRUE\n) |&gt; \n  as.list()",
    "crumbs": [
      "2021",
      "Day 17"
    ]
  },
  {
    "objectID": "2021/R/day17.html#setup",
    "href": "2021/R/day17.html#setup",
    "title": "Day 17",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead input from file:\n\ninput &lt;- read_lines(file = \"../input/day17.txt\")\n\nExtract numeric bounds from text input:\n\ntarget &lt;- unglue_data(\n  input,\n  \"target area: x={xmin}..{xmax}, y={ymin}..{ymax}\", \n  convert = TRUE\n) |&gt; \n  as.list()",
    "crumbs": [
      "2021",
      "Day 17"
    ]
  },
  {
    "objectID": "2021/R/day17.html#part-1",
    "href": "2021/R/day17.html#part-1",
    "title": "Day 17",
    "section": "Part 1",
    "text": "Part 1\nThe minimum x velocity is whichever value will cause the probe to come to rest just inside the target region. The maximum x velocity is the greatest x-value of the target (as the probe will get there in 1 step).\nTo compute the minimum starting x velocity, we take the ceiling of the n-value from the following formula:\n\\[\\sum_{i = 1}^n i = \\frac{n(n+1)}{2} = \\mathrm{xmin} \\quad \\rightarrow \\quad \\frac{1}{2}n^2 + \\frac{1}{2}n - \\mathrm{xmin} = 0 \\quad \\rightarrow \\quad n = -\\frac{1}{2} + \\sqrt{\\frac{1}{4} + 2*\\mathrm{xmin}}\\]\n\nx_vmin &lt;- ceiling(-0.5 + sqrt(0.25 + 2 * target$xmin))\nx_vmax &lt;- target$xmax\n\nWe also know that since gravity behaves symmetrically, we can’t have an initial y velocity greater than the ymin boundary. Otherwise by the time it returns to y = 0, it will overshoot the target area in the next step.\n\ny_vmin &lt;- target$ymin\ny_vmax &lt;- abs(target$ymin)\n\nCompute the min/maximum number time steps when the probe is in the target x/y range. Compute x and y ranges separately, first:\n\nx_set &lt;- tibble(v = x_vmin:x_vmax) |&gt; \n  mutate(\n    pos  = map(v, ~ accumulate(.x:1, sum)),\n    xmax  = map_int(pos, ~ tail(.x, 1)),\n    tset = map(pos, \\(x) which(between(x, target$xmin, target$xmax))),\n    tmin = map_dbl(tset, min),\n    tmax = map_dbl(tset, max),\n    tmax = if_else(between(xmax, target$xmin, target$xmax), Inf, tmax)\n  ) |&gt; \n  select(-tset) |&gt; \n  filter(tmin &lt;= tmax)\n\ny_set &lt;- tibble(v = y_vmin:y_vmax) |&gt;\n  mutate(\n    pos  = map(v, \\(v) accumulate(v:(-abs(v) - abs(target$ymin)), sum)),\n    tset = map(pos,  \\(y) which(between(y, target$ymin, target$ymax))),\n    tmin = map_dbl(tset, min),\n    tmax = map_dbl(tset, max),\n    ymax = map2_dbl(pos, tmax, \\(y, t) max(head(y, t)))\n  ) |&gt; \n  select(-tset) |&gt; \n  filter(tmin &lt;= tmax)\n\nCombine the x and y valid ranges to detect when both are in the target at the same time:\n\nvalid_set &lt;- cross_join(x_set, y_set) |&gt; \n  mutate(\n    tmin = pmax(tmin.x, tmin.y),\n    tmax = pmin(tmax.x, tmax.y)\n  ) |&gt; \n  filter(tmin &lt;= tmax)\n\nPull the maximum y value attained by all valid starting velocities:\n\nvalid_set |&gt; \n  pull(ymax) |&gt; \n  max()",
    "crumbs": [
      "2021",
      "Day 17"
    ]
  },
  {
    "objectID": "2021/R/day17.html#part-2",
    "href": "2021/R/day17.html#part-2",
    "title": "Day 17",
    "section": "Part 2",
    "text": "Part 2\nCount the entries in the valid set of starting velocities:\n\nnrow(valid_set)",
    "crumbs": [
      "2021",
      "Day 17"
    ]
  },
  {
    "objectID": "2021/R/day15.html",
    "href": "2021/R/day15.html",
    "title": "Day 15",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(igraph)\n\nRead input from file into a row/column indexed data frame:\n\ninput &lt;- read_lines(file = \"../input/day15.txt\") |&gt; \n  str_split(\"\") |&gt; \n  imap_dfr(\\(vec, idx) {\n    tibble(row = idx, col = 1:length(vec), risk = as.integer(vec))\n  }) |&gt; \n  mutate(id = row_number(), .before = everything())",
    "crumbs": [
      "2021",
      "Day 15"
    ]
  },
  {
    "objectID": "2021/R/day15.html#setup",
    "href": "2021/R/day15.html#setup",
    "title": "Day 15",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(igraph)\n\nRead input from file into a row/column indexed data frame:\n\ninput &lt;- read_lines(file = \"../input/day15.txt\") |&gt; \n  str_split(\"\") |&gt; \n  imap_dfr(\\(vec, idx) {\n    tibble(row = idx, col = 1:length(vec), risk = as.integer(vec))\n  }) |&gt; \n  mutate(id = row_number(), .before = everything())",
    "crumbs": [
      "2021",
      "Day 15"
    ]
  },
  {
    "objectID": "2021/R/day15.html#part-1",
    "href": "2021/R/day15.html#part-1",
    "title": "Day 15",
    "section": "Part 1",
    "text": "Part 1\nConvert input into a directed graph. Define the edge weights to be the risk level of each target vertex.\n\ndf_to_graph &lt;- function(df) {\n  \n  edges &lt;- df |&gt; \n  \n    # Define all neighbors and edge weights to the n/s/w/e of each vertex\n    mutate(n_target =  lag(id), n_weight =  lag(risk), .by = col) |&gt; \n    mutate(s_target = lead(id), s_weight = lead(risk), .by = col) |&gt; \n    mutate(w_target =  lag(id), w_weight =  lag(risk), .by = row) |&gt; \n    mutate(e_target = lead(id), e_weight = lead(risk), .by = row) |&gt; \n    \n    # Convert to a list of formatted vertex pairs for igraph\n    pivot_longer(\n      starts_with(c(\"n_\", \"s_\", \"w_\", \"e_\")), \n      names_to = \".value\", \n      names_pattern = \"._(.*)\",\n      values_drop_na = TRUE\n    ) |&gt; \n    select(src = id, target, weight)\n  \n  # Convert to a weighted graph\n  g &lt;- make_graph(list_c(map2(edges$src, edges$target, ~ c(.x, .y))))\n  E(g)$weight &lt;- edges$weight\n  \n  return(g)\n}\n\nFind the path with the least total risk and compute its risk:\n\nmin_risk &lt;- function(df) {\n  vtx_start &lt;- min(df$id)\n  vtx_end   &lt;- max(df$id)\n \n  graph &lt;- df_to_graph(df)\n  path &lt;- shortest_paths(graph, from = vtx_start, to = vtx_end)$vpath[[1]]\n  \n  df$risk[path] |&gt; \n    tail(n = -1) |&gt; \n    sum()\n}\n\nRun on puzzle input:\n\nmin_risk(input)",
    "crumbs": [
      "2021",
      "Day 15"
    ]
  },
  {
    "objectID": "2021/R/day15.html#part-2",
    "href": "2021/R/day15.html#part-2",
    "title": "Day 15",
    "section": "Part 2",
    "text": "Part 2\nExpand the input X5 in each direction:\n\nnrow &lt;- max(input$row)\nncol &lt;- max(input$col)\n\ndf_big &lt;- accumulate(\n  1:4, \n  \\(df, n) mutate(df, col = col + ncol, risk = pmax(1, (risk + 1) %% 10)), \n  .init = input\n) |&gt; \n  bind_rows() |&gt; \n  accumulate(\n    1:4, \n    \\(df, n) mutate(df, row = row + nrow, risk = pmax(1, (risk + 1) %% 10)), \n    .init = _\n  ) |&gt; \n  bind_rows() |&gt; \n  arrange(row, col) |&gt; \n  mutate(id = row_number())\n\nRe-run the minimum risk function on the expanded input:\n\nmin_risk(df_big)",
    "crumbs": [
      "2021",
      "Day 15"
    ]
  },
  {
    "objectID": "2021/R/day14.html",
    "href": "2021/R/day14.html",
    "title": "Day 14",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day14.txt\", skip_empty_rows = TRUE)\n\nConvert input to a starting sequence and a list of pair insertion rules:\n\ntemplate &lt;- head(input, 1)\n\nrules &lt;- tail(input, -1) |&gt; \n  unglue_data(\"{pair} -&gt; {output}\")\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)",
    "crumbs": [
      "2021",
      "Day 14"
    ]
  },
  {
    "objectID": "2021/R/day14.html#setup",
    "href": "2021/R/day14.html#setup",
    "title": "Day 14",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day14.txt\", skip_empty_rows = TRUE)\n\nConvert input to a starting sequence and a list of pair insertion rules:\n\ntemplate &lt;- head(input, 1)\n\nrules &lt;- tail(input, -1) |&gt; \n  unglue_data(\"{pair} -&gt; {output}\")\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)",
    "crumbs": [
      "2021",
      "Day 14"
    ]
  },
  {
    "objectID": "2021/R/day14.html#part-1",
    "href": "2021/R/day14.html#part-1",
    "title": "Day 14",
    "section": "Part 1",
    "text": "Part 1\nDefine a function to grow the polymer n times, then take the count of the most common character in the string and subtract the count of the least common character:\n\ngrow_n &lt;- function(polymer, n) {\n  \n  # Save the first and last letter for later reference\n  letter_start &lt;- str_sub(polymer,  1L,  1L)\n  letter_final &lt;- str_sub(polymer, -1L, -1L)\n  \n  # Reformat the initial string as a dataframe of pairs and counts\n  polymer &lt;- map2_dfr(\n    .x = head(str_split_1(polymer, \"\"), -1),\n    .y = tail(str_split_1(polymer, \"\"), -1),\n    ~ tibble(pair = str_c(.x, .y))\n  ) |&gt; \n    summarize(n = n(), .by = pair)\n  \n  # Grow the polymer N times, tracking its growth as compact counts of pairs\n  for (i in 1:n) {\n    polymer &lt;- polymer |&gt; \n      left_join(rules, join_by(pair)) |&gt; \n      mutate(\n        pair1 = str_replace(pair, \".$\", output),\n        pair2 = str_replace(pair, \"^.\", output),\n        pair3 = case_when(is.na(output) ~ pair)\n      ) |&gt; \n      select(n, pair1, pair2, pair3) |&gt; \n      pivot_longer(\n        starts_with(\"pair\"), \n        values_to = \"pair\", \n        names_to = NULL, \n        values_drop_na = TRUE\n      ) |&gt; \n      summarize(n = sum(n), .by = pair)\n  }\n  \n  # Count final letters and de-duplicate\n  counts &lt;- polymer |&gt; \n    mutate(letters = str_split(pair, \"\")) |&gt; \n    unnest_longer(letters) |&gt; \n    summarize(n = sum(n), .by = letters) |&gt; \n    \n    # Initial and final letters were not duplicated, so return +1 to them\n    mutate(\n      n = case_when(letters == letter_start ~ n + 1, .default = n),\n      n = case_when(letters == letter_final ~ n + 1, .default = n),\n      n = n / 2\n    ) |&gt; \n    pull(n)\n  \n  # Return the range of greatest - least letter counts\n  max(counts) - min(counts)\n}\n\nRun for 10 steps on puzzle input:\n\ngrow_n(template, 10)",
    "crumbs": [
      "2021",
      "Day 14"
    ]
  },
  {
    "objectID": "2021/R/day14.html#part-2",
    "href": "2021/R/day14.html#part-2",
    "title": "Day 14",
    "section": "Part 2",
    "text": "Part 2\nRun for 40 steps on puzzle input:\n\ngrow_n(template, 40)",
    "crumbs": [
      "2021",
      "Day 14"
    ]
  },
  {
    "objectID": "2021/R/day19.html",
    "href": "2021/R/day19.html",
    "title": "Day 19",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day19.txt\")\n\nConvert plaintext input into sets of numeric coordinates by scanner:\n\ndf &lt;- input |&gt; \n  unglue_data(\n    patterns = c(\"--- scanner {scanner} ---\", \"{x},{y},{z}\"),\n    convert = TRUE\n  ) |&gt; \n  mutate(across(c(x, y, z), as.numeric)) |&gt; \n  fill(scanner, .direction = \"down\") |&gt; \n  drop_na() |&gt; \n  mutate(id = row_number(), .before = everything())",
    "crumbs": [
      "2021",
      "Day 19"
    ]
  },
  {
    "objectID": "2021/R/day19.html#setup",
    "href": "2021/R/day19.html#setup",
    "title": "Day 19",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead input from file:\n\ninput &lt;- read_lines(\"../input/day19.txt\")\n\nConvert plaintext input into sets of numeric coordinates by scanner:\n\ndf &lt;- input |&gt; \n  unglue_data(\n    patterns = c(\"--- scanner {scanner} ---\", \"{x},{y},{z}\"),\n    convert = TRUE\n  ) |&gt; \n  mutate(across(c(x, y, z), as.numeric)) |&gt; \n  fill(scanner, .direction = \"down\") |&gt; \n  drop_na() |&gt; \n  mutate(id = row_number(), .before = everything())",
    "crumbs": [
      "2021",
      "Day 19"
    ]
  },
  {
    "objectID": "2021/R/day19.html#part-1",
    "href": "2021/R/day19.html#part-1",
    "title": "Day 19",
    "section": "Part 1",
    "text": "Part 1\nDefine the set of all rotation matrices around the x/y/z axes in 90 degree increments:\n\nxrot &lt;- \\(x) matrix(c(1, 0, 0, 0, cos(x), sin(x), 0, -sin(x), cos(x)), nrow = 3)\nyrot &lt;- \\(x) matrix(c(cos(x), 0, -sin(x), 0, 1, 0, sin(x), 0, cos(x)), nrow = 3)\nzrot &lt;- \\(x) matrix(c(cos(x), sin(x), 0, -sin(x), cos(x), 0, 0, 0, 1), nrow = 3)\n\nConvert each combination of unique x/y/z rotations (e.g., 90 degrees around the x axis then 180 degrees around the z axis) into a single rotation matrix:\n\nrot &lt;- lst(x = xrot, y = yrot, z = zrot) |&gt; \n  map(\\(f) map(0:3, ~ round(f(.x * pi / 2)))) |&gt; \n  do.call(what = expand_grid) |&gt; \n  pmap(~ ..1 %*% ..2 %*% ..3) |&gt; \n  unique()\n\nConvert x/y/z coordinate sets from the input into a matrix of coordinate values for each scanner:\n\nmtx &lt;- df |&gt;\n  select(scanner, x, y, z) |&gt; \n  nest(beacons = c(x, y, z)) |&gt; \n  mutate(beacons = map(beacons, ~ t(as.matrix(.x))))\n\nDetermine which scanners have overlapping beacons and define matrix transformations to translate points between various scanner coordinates:\n\ntranslation &lt;- mtx |&gt; \n  \n  # Create pairwise combinations of all scanners\n  cross_join(mtx, suffix = c(\".src\", \".out\")) |&gt; \n  filter(scanner.src != scanner.out) |&gt; \n  \n  # Apply all possible sets of rotations to the source beacons\n  expand_grid(rotate = rot) |&gt; \n  \n  # Find a translation for each pair of scanners that aligns at least 12 beacons\n  mutate(\n    beacons.src = map2(rotate, beacons.src, \\(A, x) A %*% x),\n    shift = map2(beacons.src, beacons.out, \\(src, out) {\n      expand_grid(src = split(src, col(src)), out = split(out, col(out))) |&gt; \n        mutate(shift = map2(src, out, \\(src, out) out - src)) |&gt; \n        mutate(n = n(), .by = shift) |&gt; \n        slice_max(n)\n    }),\n    n = map_int(shift, ~ max(.x$n)),\n  ) |&gt; \n  filter(n &gt;= 12) |&gt; \n  \n  # Convert rotation and translation to a single function that transforms a vec \n  mutate(\n    shift = list_flatten(map(shift, ~ unique(.x$shift))),\n    shift = map(shift, ~ diag(4) + cbind(matrix(0, 4, 3), c(.x, 0))),\n    f = map2(rotate, shift, \\(A, S) function(x) {\n      head(S %*% rbind(A %*% x, matrix(1, 1, ncol(x))), -1)\n    })\n  ) |&gt; \n  select(scanner.src, scanner.out, f)\n\nDefine a function that re-orients a scanner’s beacons into the coordinate system of the zero scanner:\n\nreorient &lt;- function(vecs, path) {\n  if (tail(path, 1) == 0)\n    return(vecs)\n  \n  translation |&gt; \n    filter(scanner.src == tail(path, 1) & !(scanner.out %in% path)) |&gt; \n    pmap(\\(scanner.out, f, ...) reorient(f(vecs), c(path, scanner.out))) |&gt; \n    compact() |&gt; \n    pluck(1)\n}\n\nFor each scanner in the input, convert all coordinates to the zero-scanner system and count the unique resulting beacons:\n\nmap2(mtx$beacons, mtx$scanner, reorient) |&gt; \n  map(~split(.x, col(.x))) |&gt; \n  list_flatten() |&gt; \n  unique() |&gt; \n  length()",
    "crumbs": [
      "2021",
      "Day 19"
    ]
  },
  {
    "objectID": "2021/R/day19.html#part-2",
    "href": "2021/R/day19.html#part-2",
    "title": "Day 19",
    "section": "Part 2",
    "text": "Part 2\nConvert each scanner’s coordinates, which are each centered at (0, 0, 0) in their own coordinate system, to the zero-scanner’s system:\n\nscanners &lt;- map(mtx$scanner, ~ reorient(matrix(0, 3, 1), .x))\n\nCompute the greatest manhattan distance between any two pairs of scanners:\n\nexpand_grid(x = scanners, y = scanners) |&gt; \n  mutate(dist = map2_dbl(x, y, ~ sum(abs(.x - .y)))) |&gt; \n  pull(dist) |&gt; \n  max()",
    "crumbs": [
      "2021",
      "Day 19"
    ]
  },
  {
    "objectID": "2021/R/day24.html",
    "href": "2021/R/day24.html",
    "title": "Day 24",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead and parse text input from file:\n\ninput &lt;- read_lines(\"../input/day24.txt\") |&gt; \n  unglue_data(patterns = c(\"{f=...} {a=.}\", \"{f} {a=.} {b}\"))",
    "crumbs": [
      "2021",
      "Day 24"
    ]
  },
  {
    "objectID": "2021/R/day24.html#setup",
    "href": "2021/R/day24.html#setup",
    "title": "Day 24",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead and parse text input from file:\n\ninput &lt;- read_lines(\"../input/day24.txt\") |&gt; \n  unglue_data(patterns = c(\"{f=...} {a=.}\", \"{f} {a=.} {b}\"))",
    "crumbs": [
      "2021",
      "Day 24"
    ]
  },
  {
    "objectID": "2021/R/day24.html#part-1",
    "href": "2021/R/day24.html#part-1",
    "title": "Day 24",
    "section": "Part 1",
    "text": "Part 1\nBy visual inspection, the instructions are all minor variations on the same repeated set of instructions. Block 1 is interpreted below:\n\n\n\nInstruction\nDescription\nOutput Value\n\n\n\n\ninp w\nRead a new digit into w\nw = {1:9}\n\n\nmul x 0\nZero out x\nx = 0\n\n\nadd x z\nSet x equal to z\nx = 0\n\n\nmod x 26\nModulo x by 26 (0)\nx = 0\n\n\ndiv z 1\nDivide z by 1 (no effect)\nz = 0\n\n\nadd x 14\nAdd 14 to x (14)\nx = 14\n\n\neql x w\nCheck if x equals w\nx = 0\n\n\neql x 0\nCheck if above is true\nx = 1\n\n\nmul y 0\nZero out y\ny = 0\n\n\nadd y 25\nSet y to 25\ny = 25\n\n\nmul y x\nMultiply y by x (either 1 or 0)\ny = 25\n\n\nadd y 1\nAdd 1 to y\ny = 26\n\n\nmul z y\nMultiply z by y\nz = 0\n\n\nmul y 0\nZero out y\ny = 0\n\n\nadd y w\nSet y to w\ny = w\n\n\nadd y 12\nAdd 12 to y\ny = w + 12\n\n\nmul y x\nMultiply y by x (either 1 or 0)\ny = w + 12\n\n\nadd z y\nAdd y to z\nz = w + 12\n\n\n\nIf we represent the set of 3 integers that vary from block to block as “c1[i]”, “c2[i]”, and “c3[i]”, with i indicating the block number ranging from 1:14, this series of instructions is equivalent to the following code:\n\n# Example 14-digit number\nw &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4)  \nz &lt;- 0\n\nfor (i in 1:length(w)) {\n  if (z %% 26 + c2[i] == w[i]) \n    z &lt;- floor(z / c1[i]) \n  else \n    z &lt;- floor(z / c1[i]) * 26 + w[i] + c3[i]\n}\n\nExtract the c1, c2, and c3 values from the input:\n\nconst &lt;- input |&gt; \n  mutate(grp = cumsum(f == \"inp\")) |&gt; \n  mutate(row = row_number(), .by = grp) |&gt; \n  summarize(b = list(b), .by = row) |&gt; \n  pull(b) |&gt; \n  keep_at(c(5, 6, 16)) |&gt; \n  map(parse_number)\n\nc1 &lt;- const[[1]]\nc2 &lt;- const[[2]]\nc3 &lt;- const[[3]]\n\nBelow, we define the set of code blocks as a recursive function to loop through possible input values and find one that ends on zero.\nTo improve performance, we prune branches early on if they can never reach zero in the remaining rounds: - Each round, the best-case scenario for a large z to shrink toward zero is for the if-else statement to be true, which would result in z becoming floor(z / c1[i]). - If z is greater than or equal to the product of the remaining c1 values, it can’t be reduced to zero by the last round. - Example: as a test case, imagine that c1 = 2 in every round. - When there’s 1 round remaining, the final output is 0 if the input z is no greater than 0 or 1. - When there’s 2 rounds remaining, the round’s output can be 0/1 if the input z is no greater than 0/1/2/3. - When there’s 3 rounds remaining, the round’s output can be 0/1/2/3 if the input z is no greater than 0/1/2/3/4/5/6/7, i.e., if the input z &lt; 2^3. - Generalizing, in the 14th round, the input z must be less than c1[14]. In the 13th round, the input z must be less than c1[14] * c1[13], etc.\n\nzmax &lt;- accumulate(c1, prod, .dir = \"backward\")\n\nDefine our recursive search funtion as described above:\n\nf &lt;- function(z = 0, vec = c(), i = 1, digits) {\n  \n  # Check if the last round has been reached. Return success if z is 0.\n  if (i == 15) {\n    if (z == 0) \n      return(vec) \n    else \n      return()\n  }\n  \n  # Abort early if z is too large and can never reach 0 by the end\n  if (z &gt;= zmax[i])\n    return()\n  \n  # Loop through possible input values (in increasing or decreasing order)\n  for (w in digits) {\n    if (z %% 26 + c2[i] == w)\n      result &lt;- f(floor(z / c1[i]), c(vec, w), i + 1, digits)\n    else \n      result &lt;- f(floor(z / c1[i]) * 26 + w + c3[i], c(vec, w), i + 1, digits)\n    \n    if (!is.null(result))\n      return(result)\n  }\n}\n\nSearch in order from highest to lowest input values:\n\ncat(f(digits = 9:1), sep = \"\")",
    "crumbs": [
      "2021",
      "Day 24"
    ]
  },
  {
    "objectID": "2021/R/day24.html#part-2",
    "href": "2021/R/day24.html#part-2",
    "title": "Day 24",
    "section": "Part 2",
    "text": "Part 2\nReverse the search vector from 9:1 to 1:9 to search from lowest to highest values, and re-run:\n\ncat(f(digits = 1:9), sep = \"\")",
    "crumbs": [
      "2021",
      "Day 24"
    ]
  },
  {
    "objectID": "2021/R/day22.html",
    "href": "2021/R/day22.html",
    "title": "Day 22",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sets)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead and parse text input from file:\n\ninput &lt;- read_lines(\"../input/day22.txt\") |&gt; \n  unglue_data(\n    \"{state} x={xmin}..{xmax},y={ymin}..{ymax},z={zmin}..{zmax}\",\n    convert = TRUE\n  ) |&gt; \n  mutate(\n    id = row_number(), \n    state = case_match(state, \"on\" ~ 1, \"off\" ~ 0), \n    .before = everything()\n  )",
    "crumbs": [
      "2021",
      "Day 22"
    ]
  },
  {
    "objectID": "2021/R/day22.html#setup",
    "href": "2021/R/day22.html#setup",
    "title": "Day 22",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sets)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead and parse text input from file:\n\ninput &lt;- read_lines(\"../input/day22.txt\") |&gt; \n  unglue_data(\n    \"{state} x={xmin}..{xmax},y={ymin}..{ymax},z={zmin}..{zmax}\",\n    convert = TRUE\n  ) |&gt; \n  mutate(\n    id = row_number(), \n    state = case_match(state, \"on\" ~ 1, \"off\" ~ 0), \n    .before = everything()\n  )",
    "crumbs": [
      "2021",
      "Day 22"
    ]
  },
  {
    "objectID": "2021/R/day22.html#part-1",
    "href": "2021/R/day22.html#part-1",
    "title": "Day 22",
    "section": "Part 1",
    "text": "Part 1\nThis part of the problem has a small enough total area that it runs with a simple approach.\nInitialize the cuboid to a 101x101x101 array (representing x/z/y values from -50 to 50) where all values are “off” (zero):\n\ncuboid &lt;- array(rep(0, 101^3), c(101, 101, 101))\n\nDefine a function to modify a cuboid at the given coordinates:\n\nmodify_cuboid &lt;- function(cuboid, x, y, z, state) {\n  cuboid[x, y, z] &lt;- state\n  cuboid\n}\n\nFor each step in the input, turn the designated cubes on/off:\n\ninput |&gt; \n  \n  # Bound the input indices between -50 and 50, then translate to R indices\n  mutate(\n    across(ends_with(\"min\"), ~ pmax(.x, -50)),\n    across(ends_with(\"max\"), ~ pmin(.x,  50)),\n    across(ends_with(c(\"min\", \"max\")), ~ .x + 51)\n  ) |&gt; \n  \n  # Remove any out-of-bounds indices\n  filter((xmin &lt;= xmax) & (ymin &lt;= ymax) & (zmin &lt;= zmax)) |&gt; \n  \n  # Apply steps to the cuboid\n  pmap(\\(id, state, xmin, xmax, ymin, ymax, zmin, zmax) {\n    list(state = state, x = xmin:xmax, y = ymin:ymax, z = zmin:zmax)\n  }) |&gt; \n  reduce(\n    .f = ~ do.call(what = modify_cuboid, args = c(.y, cuboid = list(.x))),\n    .init = cuboid\n  ) |&gt; \n  sum()",
    "crumbs": [
      "2021",
      "Day 22"
    ]
  },
  {
    "objectID": "2021/R/day22.html#part-2",
    "href": "2021/R/day22.html#part-2",
    "title": "Day 22",
    "section": "Part 2",
    "text": "Part 2\nThe full region of interest is now too large. We now use set intervals to store our cuboids rather than storing each voxel individually.\nNudge from the Reddit daily megathread: rather than storing the state of the full cuboid at each step, compute the change in volume at each step instead, and work in reverse order.\nWith this approach, every new ‘on’ step in reverse order adds the total volume of any ‘on’ cuboid, minus any intersection with any ‘off’ or ‘on’ cuboid later in the step sequence. When an ‘off’ cuboid is encountered, it can be ignored.\nDefine a helper function to subtract one cuboid from another, breaking down to up to six non-overlapping sub-cuboids if necessary:\n\ncuboid_difference &lt;- function(a, b) {\n  diff &lt;- map2(a, b, ~ as.list(interval_complement(.y, .x)))\n  intr &lt;- map2(a, b, interval_intersection)\n  c(\n    map(diff$z, \\(z) lst(x = a$x, y = a$y,    z = z)),\n    map(diff$y, \\(y) lst(x = a$x, y = y,      z = intr$z)),\n    map(diff$x, \\(x) lst(x = x,   y = intr$y, z = intr$z))\n  )\n}\n\nDefine a helper function to compute the volume of a cuboid:\n\ncuboid_size &lt;- function(cuboid) {\n  if (any(map_lgl(cuboid, interval_is_empty)))\n    return(0)\n  cuboid |&gt; \n    map_dbl(~ max(.x) - min(.x) + 1) |&gt; \n    prod()\n}\n\nConver the input cuboids into a set of integer intervals for each step:\n\nsteps &lt;- input |&gt; \n  mutate(\n    x = map2(xmin, xmax, integers),\n    y = map2(ymin, ymax, integers),\n    z = map2(zmin, zmax, integers),\n    cuboid = pmap(lst(x, y, z), lst)\n  ) |&gt;\n  select(id, state, cuboid)\n\nFor each ‘on’ cuboid, compute the regions of intersection with any later-step cuboid:\n\nto_rm &lt;- inner_join(steps, steps, join_by(x$id &lt; y$id)) |&gt;\n  filter(state.x == 1) |&gt; \n  mutate(\n    overlap = map2(cuboid.x, cuboid.y, ~ map2(.x, .y, interval_intersection)),\n    empty = map_lgl(overlap, \\(cuboid) any(map_lgl(cuboid, interval_is_empty))),\n    id = id.x\n  ) |&gt; \n  filter(!empty) |&gt; \n  summarize(overlap = list(overlap), .by = id)\n\nRemove the overlapping regions from the step’s original cuboid:\n\nres &lt;- steps |&gt; \n  inner_join(to_rm, join_by(id)) |&gt; \n  mutate(\n    new = map2(cuboid, overlap, \\(base, intr) {\n      reduce(intr, .init = list(base), \\(acc, nxt) {\n        list_flatten(map(acc, ~ cuboid_difference(.x, nxt)))\n      })\n    })\n  )\n\nCompute the volume of each final ‘on’ cuboid, and sum to get the final result:\n\nsteps |&gt; \n  filter(state == 1) |&gt; \n  left_join(select(res, id, new), join_by(id)) |&gt; \n  mutate(\n    uniq = map2(new, cuboid, ~ if (is.null(.x)) list(.y) else .x),\n    size = map_dbl(uniq, \\(cuboid_set) sum(map_dbl(cuboid_set, cuboid_size)))\n  ) |&gt; \n  pull(size) |&gt; \n  sum()",
    "crumbs": [
      "2021",
      "Day 22"
    ]
  },
  {
    "objectID": "2021/R/day20.html",
    "href": "2021/R/day20.html",
    "title": "Day 20",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file, converting “#”/“.” characters to 1/0 integers:\n\ninput &lt;- read_lines(\"../input/day20.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split(\"\") |&gt; \n  map(~ case_match(.x, \".\" ~ 0, \"#\" ~ 1))\n\nSeparate the input into the algorithm sequence and image matrix:\n\nalg &lt;- pluck(input, 1)\nimg &lt;- tail(input, -1) |&gt; do.call(what = rbind)",
    "crumbs": [
      "2021",
      "Day 20"
    ]
  },
  {
    "objectID": "2021/R/day20.html#setup",
    "href": "2021/R/day20.html#setup",
    "title": "Day 20",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead input from file, converting “#”/“.” characters to 1/0 integers:\n\ninput &lt;- read_lines(\"../input/day20.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split(\"\") |&gt; \n  map(~ case_match(.x, \".\" ~ 0, \"#\" ~ 1))\n\nSeparate the input into the algorithm sequence and image matrix:\n\nalg &lt;- pluck(input, 1)\nimg &lt;- tail(input, -1) |&gt; do.call(what = rbind)",
    "crumbs": [
      "2021",
      "Day 20"
    ]
  },
  {
    "objectID": "2021/R/day20.html#part-1",
    "href": "2021/R/day20.html#part-1",
    "title": "Day 20",
    "section": "Part 1",
    "text": "Part 1\nPrint the starting image:\n\nprint_img &lt;- \\(img) {\n  image(\n    t(img)[, nrow(img):1],\n    col = c(\"black\", \"white\"), \n    asp = nrow(img) / ncol(img),\n    axes = FALSE\n  )\n}\n\nprint_img(img)\n\n\n\n\n\n\n\n\nDefine a function to enhance the given image. Since the character representing the infinte expansion in all directions can change from enhancement to enhancement, we track its current value in the inf argument.\n\nenhance &lt;- function(mtx, inf = 0) {\n  \n  # Expand the borders of the image so that all 3x3 subsets are accessible\n  mtx &lt;- rbind(inf, inf, cbind(inf, inf, mtx, inf, inf), inf, inf)\n  \n  # Generate the full set of output coords\n  mtx_out &lt;- expand_grid(\n    row = 1:(nrow(mtx) - 2),\n    col = 1:(ncol(mtx) - 2) \n  ) |&gt; \n    \n    # Convert output coords to 3x3 ranges of the input and get the output value\n    mutate(\n      bin = map2_chr(row, col, ~ str_flatten(t(mtx[.x + 0:2, .y + 0:2]), \"\")),\n      idx = strtoi(bin, base = 2) + 1,\n      out = alg[idx]\n    ) |&gt; \n    \n    # Compress back down into matrix format\n    pull(out) |&gt; \n    matrix(nrow = nrow(mtx) - 2, byrow = TRUE)\n  \n  # Determine the new value of the infinite grid\n  inf_out &lt;- alg[strtoi(str_flatten(rep(inf, 9), \"\"), base = 2) + 1]\n  \n  lst(mtx = mtx_out, inf = inf_out)\n}\n\nDefine a function that enhances the image a given number of times:\n\nenhance_n &lt;- function(img, n) {\n  lst(mtx = img, inf = 0) |&gt; \n    reduce(1:n, .f = ~ do.call(what = enhance, args = .x), .init = _) |&gt; \n    pluck(\"mtx\")\n}\n\nEnhance the image twice, then count how many pixels are lit in the result:\n\nresult &lt;- enhance_n(img, n = 2)\n\nsum(result)\n\n\nprint_img(result)",
    "crumbs": [
      "2021",
      "Day 20"
    ]
  },
  {
    "objectID": "2021/R/day20.html#part-2",
    "href": "2021/R/day20.html#part-2",
    "title": "Day 20",
    "section": "Part 2",
    "text": "Part 2\nEnhance the image 50 times:\n\nresult &lt;- enhance_n(img, n = 50)\n\nsum(result)\n\n\nprint_img(result)",
    "crumbs": [
      "2021",
      "Day 20"
    ]
  },
  {
    "objectID": "2021/R/day09.html",
    "href": "2021/R/day09.html",
    "title": "Day 9",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(igraph)\n\nRead input from file:\n\ninput &lt;- scan(file = \"../input/day09.txt\", what = character(), quiet = TRUE)\n\nConvert input from plaintext to an integer matrix:\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  list_c() |&gt; \n  as.integer() |&gt; \n  matrix(nrow = length(input), byrow = TRUE)",
    "crumbs": [
      "2021",
      "Day 9"
    ]
  },
  {
    "objectID": "2021/R/day09.html#setup",
    "href": "2021/R/day09.html#setup",
    "title": "Day 9",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(igraph)\n\nRead input from file:\n\ninput &lt;- scan(file = \"../input/day09.txt\", what = character(), quiet = TRUE)\n\nConvert input from plaintext to an integer matrix:\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  list_c() |&gt; \n  as.integer() |&gt; \n  matrix(nrow = length(input), byrow = TRUE)",
    "crumbs": [
      "2021",
      "Day 9"
    ]
  },
  {
    "objectID": "2021/R/day09.html#part-1",
    "href": "2021/R/day09.html#part-1",
    "title": "Day 9",
    "section": "Part 1",
    "text": "Part 1\nCreate shifted versions of our matrix to get the values above, below, to the left, and to the right of any given cell:\n\nmtx_above &lt;- lag(mtx)\nmtx_below &lt;- lead(mtx)\nmtx_left  &lt;- t(lag(t(mtx)))\nmtx_right &lt;- t(lead(t(mtx)))\n\nFind all low points:\n\nlow &lt;- (\n  mtx &lt; mtx_above & \n  mtx &lt; mtx_below & \n  mtx &lt; mtx_left  & \n  mtx &lt; mtx_right\n)\n\nlow[is.na(low)] &lt;- TRUE\n\nCompute the risk level of each low point:\n\nsum(mtx[low] + 1)",
    "crumbs": [
      "2021",
      "Day 9"
    ]
  },
  {
    "objectID": "2021/R/day09.html#part-2",
    "href": "2021/R/day09.html#part-2",
    "title": "Day 9",
    "section": "Part 2",
    "text": "Part 2\nFor each applicable point on the map, determine its smallest surrounding coordinate(s) where smoke will flow:\n\nneighbors &lt;- pmap(\n  list(mtx, mtx_left, mtx_right, mtx_above, mtx_below),\n  \\(i, l, r, u, d) {\n    dirs &lt;- c(\"I\" = i, \"L\" = l, \"R\" = r, \"U\" = u, \"D\" = d)\n    flow &lt;- dirs[dirs == min(dirs, na.rm = TRUE)] |&gt; \n      discard(is.na) |&gt; \n      discard_at(\"I\") |&gt; \n      names()\n    if (i != 9) flow else character(0)\n  }\n) |&gt; \n  enframe(name = \"loc_id\", value = \"neighbor\") |&gt; \n  unnest_longer(neighbor) |&gt; \n  mutate(\n    neighbor = case_match(neighbor,\n      \"U\" ~ loc_id - 1,\n      \"D\" ~ loc_id + 1,\n      \"L\" ~ loc_id - nrow(mtx),\n      \"R\" ~ loc_id + nrow(mtx)\n    )\n  )\n\nConvert list of neighbors to a graph:\n\ng &lt;- neighbors |&gt; \n  pmap(~ c(..1, ..2)) |&gt; \n  list_c() |&gt; \n  make_graph()\n\nFor each low point, compute the size of its basin from its graph neighborhood:\n\nbasin_ids  &lt;- components(g)$membership[which(low)]\nbasin_size &lt;- components(g)$csize[basin_ids]\n\nMultiply together the sizes of the three largest basins:\n\nbasin_size |&gt; \n  sort(decreasing = TRUE) |&gt; \n  head(3) |&gt; \n  prod()",
    "crumbs": [
      "2021",
      "Day 9"
    ]
  },
  {
    "objectID": "2020/R/day04.html",
    "href": "2020/R/day04.html",
    "title": "Day 4",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file and separate into lists of key-value pairs:\n\ninput &lt;- read_lines(\"../input/day04.txt\")",
    "crumbs": [
      "2020",
      "Day 4"
    ]
  },
  {
    "objectID": "2020/R/day04.html#setup",
    "href": "2020/R/day04.html#setup",
    "title": "Day 4",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file and separate into lists of key-value pairs:\n\ninput &lt;- read_lines(\"../input/day04.txt\")",
    "crumbs": [
      "2020",
      "Day 4"
    ]
  },
  {
    "objectID": "2020/R/day04.html#part-1",
    "href": "2020/R/day04.html#part-1",
    "title": "Day 4",
    "section": "Part 1",
    "text": "Part 1\nConvert text input to a data frame of key value-pairs, enumerated according to the blank lines, and determine whether each passport has all requied fields (ignoring “cid”):\nbyr (Birth Year)\niyr (Issue Year)\neyr (Expiration Year)\nhgt (Height)\nhcl (Hair Color)\necl (Eye Color)\npid (Passport ID)\ncid (Country ID)\n\nrequired_keys &lt;- c(\"byr\", \"iyr\", \"eyr\", \"hgt\", \"hcl\", \"ecl\", \"pid\")\n\ndf &lt;- input |&gt; \n  \n  # Convert text lines to data frame\n  str_flatten(collapse = \"\\n\") |&gt; \n  str_split_1(\"\\n\\n\") |&gt; \n  str_split(\"\\\\s\") |&gt; \n  imap_dfr(\\(str, idx) {\n    str |&gt; \n      unglue_data(\"{key}:{value}\") |&gt; \n      mutate(idx = idx)\n  }) |&gt; \n  \n  # Flag whether each passpord is valid or not\n  mutate(\n    is_valid = sum(key %in% required_keys) == 7, \n    .by = idx\n  )\n\nCount the total valid passpords:\n\ndf |&gt; \n  filter(is_valid) |&gt; \n  distinct(idx) |&gt; \n  nrow()",
    "crumbs": [
      "2020",
      "Day 4"
    ]
  },
  {
    "objectID": "2020/R/day04.html#part-2",
    "href": "2020/R/day04.html#part-2",
    "title": "Day 4",
    "section": "Part 2",
    "text": "Part 2\nFilter to the passports with all required fields, validate those fields, and count the final number of valid results:\n\ndf |&gt; \n  filter(is_valid & key %in% required_keys) |&gt; \n  mutate(\n    is_valid = (\n      (\n        key == \"byr\" \n          & str_length(value) == 4 \n          & between(parse_number(value), 1920, 2002)\n      ) | (\n        key == \"iyr\" \n          & str_length(value) == 4 \n          & between(parse_number(value), 2010, 2020)\n      ) | (\n        key == \"eyr\" \n          & str_length(value) == 4 \n          & between(parse_number(value), 2020, 2030)\n      ) | (\n        key == \"hgt\" \n          & str_detect(value, \"^\\\\d+cm$\")\n          & between(parse_number(value), 150, 193)\n      ) | (\n        key == \"hgt\" \n          & str_detect(value, \"^\\\\d+in$\")\n          & between(parse_number(value), 59, 76)\n      ) | (\n        key == \"hcl\" \n          & str_detect(value, \"^#[0-9a-f]{6}$\")\n      ) | (\n        key == \"ecl\" \n          & value %in% c(\"amb\", \"blu\", \"brn\", \"gry\", \"grn\", \"hzl\", \"oth\")\n      ) | (\n        key == \"pid\" \n          & str_detect(value, \"^\\\\d{9}$\")\n      )\n    )\n  ) |&gt; \n  filter(all(is_valid), .by = idx) |&gt; \n  distinct(idx) |&gt; \n  nrow()",
    "crumbs": [
      "2020",
      "Day 4"
    ]
  },
  {
    "objectID": "2020/R/day11.html",
    "href": "2020/R/day11.html",
    "title": "Day 11",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file into a 1/0 matrix. “.” values are read in as NA.\n\ninput &lt;- read_lines(\"../input/day11.txt\") |&gt; \n  str_split(\"\") |&gt; \n  map(\\(x) case_match(x, \"L\" ~ 0, \"#\" ~ 1)) |&gt; \n  reduce(rbind) |&gt; \n  unname()",
    "crumbs": [
      "2020",
      "Day 11"
    ]
  },
  {
    "objectID": "2020/R/day11.html#setup",
    "href": "2020/R/day11.html#setup",
    "title": "Day 11",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file into a 1/0 matrix. “.” values are read in as NA.\n\ninput &lt;- read_lines(\"../input/day11.txt\") |&gt; \n  str_split(\"\") |&gt; \n  map(\\(x) case_match(x, \"L\" ~ 0, \"#\" ~ 1)) |&gt; \n  reduce(rbind) |&gt; \n  unname()",
    "crumbs": [
      "2020",
      "Day 11"
    ]
  },
  {
    "objectID": "2020/R/day11.html#part-1",
    "href": "2020/R/day11.html#part-1",
    "title": "Day 11",
    "section": "Part 1",
    "text": "Part 1\nThe base R functions ‘row’ and ‘col’ generate a row/column index for every element of the supplied matrix. Create a helper function that generates an equivalent mapping for the diagonals of a matrix:\n\ndiag &lt;- function(mtx, direction = c(\"up\", \"down\")) {\n  map2_int(\n    rep(1:nrow(mtx), times = ncol(mtx)), \n    rep(1:ncol(mtx), each  = nrow(mtx)), \n    \\(i, j) {\n      if (direction == \"up\")\n        i + j - 1\n      else if (direction == \"down\")\n        i - j + ncol(mtx)\n    }\n  ) |&gt; \n    matrix(nrow(mtx), ncol(mtx))\n}\n\nDefine a helper function which, for each element of our supplied matrix, counts how many adjacent seats are occupied in each direction:\n\ncounts &lt;- function(mtx) {\n  lst(\n    input_rows  = row(mtx), \n    input_cols  = col(mtx), \n    input_diag1 = diag(mtx, \"up\"), \n    input_diag2 = diag(mtx, \"down\")\n  ) |&gt; \n    map(\\(mapping) {\n      mtx |&gt; \n        split(mapping) |&gt; \n        map(\\(x) coalesce(x, 0)) |&gt;\n        map(\\(x) lead(x, default = 0) + lag(x, default = 0)) |&gt; \n        unsplit(mapping) |&gt; \n        matrix(nrow(mtx), ncol(mtx))\n    }) |&gt; \n    reduce(`+`)\n}\n\nDefine a helper function to iteratively adjust the seating until now changes are found, then return the number of occupied seats:\n\nshift_seating &lt;- function(init, limit) {\n  neighbors &lt;- counts(init)\n  init |&gt; \n    replace(init == 0 & neighbors == 0, 1) |&gt; \n    replace(init == 1 & neighbors &gt;= limit, 0) \n}\n\nLoop until equilibrium & count output:\n\ncur &lt;- input \nnxt &lt;- input\n\nrepeat {\n  nxt &lt;- shift_seating(cur, limit = 4)\n  if (all(nxt == cur | (is.na(cur) & is.na(nxt))))\n    break\n  cur &lt;- nxt\n}\n\nsum(cur, na.rm = TRUE)",
    "crumbs": [
      "2020",
      "Day 11"
    ]
  },
  {
    "objectID": "2020/R/day11.html#part-2",
    "href": "2020/R/day11.html#part-2",
    "title": "Day 11",
    "section": "Part 2",
    "text": "Part 2\nAdjust the neighbor counting functions such that rather than just looking at the adjacent seats, it look at all seats in the line of sight:\n\ncounts &lt;- function(mtx) {\n  lst(\n    input_rows  = row(mtx), \n    input_cols  = col(mtx), \n    input_diag1 = diag(mtx, \"up\"), \n    input_diag2 = diag(mtx, \"down\")\n  ) |&gt; \n    map(\\(mapping) {\n      mtx |&gt; \n        split(mapping) |&gt; \n        map(\\(x) {\n          fwd &lt;- x |&gt;\n            accumulate(\\(x, y) coalesce(y, x), .dir = \"forward\") |&gt;\n            lag(default = 0) |&gt; \n            coalesce(0)\n          bwd &lt;- x |&gt;\n            accumulate(\\(x, y) coalesce(x, y), .dir = \"backward\") |&gt;\n            lead(default = 0) |&gt; \n            coalesce(0)\n          fwd + bwd\n        }) |&gt; \n        unsplit(mapping) |&gt; \n        matrix(nrow(mtx), ncol(mtx))\n    }) |&gt; \n    reduce(`+`)\n}\n\nLoop until equilibrium & count output:\n\ncur &lt;- input \nnxt &lt;- input\n\nrepeat {\n  nxt &lt;- shift_seating(cur, limit = 5)\n  if (all(nxt == cur | (is.na(cur) & is.na(nxt))))\n    break\n  cur &lt;- nxt\n}\n\nsum(cur, na.rm = TRUE)",
    "crumbs": [
      "2020",
      "Day 11"
    ]
  },
  {
    "objectID": "2020/R/day13.html",
    "href": "2020/R/day13.html",
    "title": "Day 13",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(numbers)\nlibrary(bit64)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day13.txt\")\n\nSeparate text input into the core timestamp and the bus list:\n\ntimestamp &lt;- input[[1]] |&gt; as.numeric()\nbus &lt;- input[[2]] |&gt; str_split_1(\",\")",
    "crumbs": [
      "2020",
      "Day 13"
    ]
  },
  {
    "objectID": "2020/R/day13.html#setup",
    "href": "2020/R/day13.html#setup",
    "title": "Day 13",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(numbers)\nlibrary(bit64)\n\nDisable scientific formatting when displaying large numbers:\n\noptions(scipen = 999)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day13.txt\")\n\nSeparate text input into the core timestamp and the bus list:\n\ntimestamp &lt;- input[[1]] |&gt; as.numeric()\nbus &lt;- input[[2]] |&gt; str_split_1(\",\")",
    "crumbs": [
      "2020",
      "Day 13"
    ]
  },
  {
    "objectID": "2020/R/day13.html#part-1",
    "href": "2020/R/day13.html#part-1",
    "title": "Day 13",
    "section": "Part 1",
    "text": "Part 1\nUsing only the non-x values on the bus list, find the earliest departure of each bus on or after our estimated departure time:\n\nbus_valid &lt;- bus |&gt; \n  discard(~ .x == \"x\") |&gt; \n  as.numeric()\n\ndepartures &lt;- ceiling(timestamp / bus_valid) * bus_valid\n\nMultiply the wait time for the earliest bus by its ID:\n\n(min(departures) - timestamp) * bus_valid[which.min(departures)]",
    "crumbs": [
      "2020",
      "Day 13"
    ]
  },
  {
    "objectID": "2020/R/day13.html#part-2",
    "href": "2020/R/day13.html#part-2",
    "title": "Day 13",
    "section": "Part 2",
    "text": "Part 2\nConvert the input into a bus schedule. This schedule can be expressed as a system of modular equations. Using the provided example:\n\\[\n\\begin{cases}\nt + 0 = 7n_1  \\\\\nt + 1 = 13n_2 \\\\\nt + 4 = 59n_3 \\\\\nt + 6 = 31n_4 \\\\\nt + 7 = 19n_5\n\\end{cases}\n\\quad\\rightarrow\\quad\n\\begin{cases}\nt \\equiv  0 &\\pmod{7}  \\\\\nt \\equiv -1 &\\pmod{13} \\\\\nt \\equiv -4 &\\pmod{59} \\\\\nt \\equiv -6 &\\pmod{31} \\\\\nt \\equiv -7 &\\pmod{19}\n\\end{cases}\n\\]\n\nschedule &lt;- bus |&gt;\n  enframe(name = NULL, value = \"bus\") |&gt;\n  mutate(time = row_number() - 1) |&gt;\n  filter(bus != \"x\") |&gt;\n  mutate(\n    bus = as.integer(bus),\n    remainder = (bus - time) %% bus\n  )\n\nWe can use the Chinese Remainder Theorem (CRT) to solve this system of equations. However, we must first confirm that all our bus numbers are relatively prime to one another:\n\ncrossing(bus1 = schedule$bus, bus2 = schedule$bus) |&gt; \n  filter(bus1 &lt; bus2) |&gt; \n  mutate(is_coprime = map2_lgl(bus1, bus2, coprime)) |&gt; \n  pull(is_coprime) |&gt; \n  all()\n\nOur bus numbers are relatively prime. Now, we leverage the CRT to compute \\(t\\). The function chinese in the numbers package works on small examples, but it does not work for large integers, so we adjust this implementation to work with bigints (integer64).\nFirst, we define a multiplicative modular inverse function that will work with int64 inputs:\n\nmodinv64 &lt;- function(a, n) {\n  \n  cur &lt;- lst(t = 0, r = n)\n  nxt &lt;- lst(t = 1, r = a)\n  \n  while (nxt$r != 0) {\n      prv &lt;- cur\n      cur &lt;- nxt\n      \n      quo &lt;- prv$r %/% cur$r\n      nxt &lt;- map2(prv, cur, \\(prv, cur) prv - quo * cur)\n  }\n  \n  r &lt;- cur$r\n  t &lt;- cur$t\n\n  if (r &gt; 1)\n      NA\n  else if (t &lt; 0)\n      t + n\n  else\n      t\n}\n\nNext, we define a CRT function that converts its inputs to int64s and executes the CRT algorithm:\n\ncrt64 &lt;- function(a, m) {\n  \n  a &lt;- as.integer64(a)\n  m &lt;- as.integer64(m)\n  \n  M &lt;- prod(m)\n  x &lt;- pmap_vec(lst(a, m, n = M / m), \\(a, m, n) {\n    a * n * modinv64(n, m)\n  })\n  \n  sum(x) %% M\n}\n\nFinally, we run the CRT on our input:\n\ncrt64(schedule$remainder, schedule$bus)",
    "crumbs": [
      "2020",
      "Day 13"
    ]
  },
  {
    "objectID": "2020/R/day06.html",
    "href": "2020/R/day06.html",
    "title": "Day 6",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day06.txt\")\n\nSplit input into separate groups of character sets wherever we encounter an empty newline:\n\ngroups &lt;- input |&gt; \n  split(cumsum(input == \"\")) |&gt; \n  map(\\(vec) {\n    vec |&gt; \n      discard(~ .x == \"\") |&gt; \n      str_split(\"\")\n  })",
    "crumbs": [
      "2020",
      "Day 6"
    ]
  },
  {
    "objectID": "2020/R/day06.html#setup",
    "href": "2020/R/day06.html#setup",
    "title": "Day 6",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day06.txt\")\n\nSplit input into separate groups of character sets wherever we encounter an empty newline:\n\ngroups &lt;- input |&gt; \n  split(cumsum(input == \"\")) |&gt; \n  map(\\(vec) {\n    vec |&gt; \n      discard(~ .x == \"\") |&gt; \n      str_split(\"\")\n  })",
    "crumbs": [
      "2020",
      "Day 6"
    ]
  },
  {
    "objectID": "2020/R/day06.html#part-1",
    "href": "2020/R/day06.html#part-1",
    "title": "Day 6",
    "section": "Part 1",
    "text": "Part 1\nCount the total unique characters in every group and sum the result:\n\ngroups |&gt; \n  map_int(\n    ~ .x |&gt; \n      unlist() |&gt; \n      unique() |&gt; \n      length()\n  ) |&gt; \n  sum()",
    "crumbs": [
      "2020",
      "Day 6"
    ]
  },
  {
    "objectID": "2020/R/day06.html#part-2",
    "href": "2020/R/day06.html#part-2",
    "title": "Day 6",
    "section": "Part 2",
    "text": "Part 2\nIn each group, count the number of characters in common over every line in the group. Sum the result.\n\ngroups |&gt; \n  map_int(\n    ~ .x |&gt; \n      reduce(intersect) |&gt; \n      length()\n  ) |&gt; \n  sum()",
    "crumbs": [
      "2020",
      "Day 6"
    ]
  },
  {
    "objectID": "2020/R/day16.html",
    "href": "2020/R/day16.html",
    "title": "Day 16",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE)\n\nParse raw text input into lists of rules, your ticket, and nearby tickets:\n\nrules &lt;- input |&gt; \n  head_while(\\(x) x != \"your ticket:\") |&gt; \n  unglue_data(\"{rule}: {min1}-{max1} or {min2}-{max2}\", convert = TRUE) |&gt; \n  pivot_longer(\n    c(min1, max1, min2, max2), \n    names_pattern = \"(min|max)(1|2)\", \n    names_to = c(\".value\", \"option\"),\n    names_transform = list(option = as.integer)\n  )\n\ntickets &lt;- input |&gt; \n  tail_while(\\(x) x != \"your ticket:\") |&gt; \n  discard(\\(x) x == \"nearby tickets:\") |&gt; \n  enframe(name = \"ticket_id\", value = \"ticket\") |&gt; \n  mutate(\n    owner = case_when(ticket_id == 1 ~ \"mine\", .default = \"nearby\"),\n    ticket = map(str_split(ticket, \",\"), parse_integer)\n  ) |&gt; \n  unnest_longer(ticket, indices_to = \"field_id\", values_to = \"field_value\")",
    "crumbs": [
      "2020",
      "Day 16"
    ]
  },
  {
    "objectID": "2020/R/day16.html#setup",
    "href": "2020/R/day16.html#setup",
    "title": "Day 16",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE)\n\nParse raw text input into lists of rules, your ticket, and nearby tickets:\n\nrules &lt;- input |&gt; \n  head_while(\\(x) x != \"your ticket:\") |&gt; \n  unglue_data(\"{rule}: {min1}-{max1} or {min2}-{max2}\", convert = TRUE) |&gt; \n  pivot_longer(\n    c(min1, max1, min2, max2), \n    names_pattern = \"(min|max)(1|2)\", \n    names_to = c(\".value\", \"option\"),\n    names_transform = list(option = as.integer)\n  )\n\ntickets &lt;- input |&gt; \n  tail_while(\\(x) x != \"your ticket:\") |&gt; \n  discard(\\(x) x == \"nearby tickets:\") |&gt; \n  enframe(name = \"ticket_id\", value = \"ticket\") |&gt; \n  mutate(\n    owner = case_when(ticket_id == 1 ~ \"mine\", .default = \"nearby\"),\n    ticket = map(str_split(ticket, \",\"), parse_integer)\n  ) |&gt; \n  unnest_longer(ticket, indices_to = \"field_id\", values_to = \"field_value\")",
    "crumbs": [
      "2020",
      "Day 16"
    ]
  },
  {
    "objectID": "2020/R/day16.html#part-1",
    "href": "2020/R/day16.html#part-1",
    "title": "Day 16",
    "section": "Part 1",
    "text": "Part 1\nDetermine which tickets have values that are not valid for any field:\n\nticket_validity &lt;- tickets |&gt; \n  filter(owner == \"nearby\") |&gt; \n  cross_join(rules) |&gt; \n  mutate(valid = between(field_value, min, max)) |&gt; \n  summarize(valid = any(valid), .by = c(ticket_id, field_id, field_value))\n\nCompute the ticket scanning error rate:\n\nticket_validity |&gt; \n  filter(!valid) |&gt; \n  pull(field_value) |&gt; \n  sum()",
    "crumbs": [
      "2020",
      "Day 16"
    ]
  },
  {
    "objectID": "2020/R/day16.html#part-2",
    "href": "2020/R/day16.html#part-2",
    "title": "Day 16",
    "section": "Part 2",
    "text": "Part 2\nDiscard invalid tickets:\n\ntickets_valid &lt;- anti_join(\n  tickets,\n  ticket_validity |&gt; \n    summarize(valid = all(valid), .by = ticket_id) |&gt; \n    filter(!valid),\n  join_by(ticket_id)\n)\n\nAmong the valid tickets, determine which rules are valid for the same fields across every ticket:\n\nn_max &lt;- n_distinct(tickets_valid$ticket_id)\n\nfield_options &lt;- tickets_valid |&gt; \n  cross_join(rules) |&gt; \n  filter(between(field_value, min, max)) |&gt; \n  summarize(n_tickets = n_distinct(ticket_id), .by = c(field_id, rule)) |&gt; \n  filter(n_tickets == n_max) |&gt; \n  select(-n_tickets)\n\nIf there’s only one field that a certain rule is valid for, then that mapping must be the true mapping. Similarly, if there’s only rule that a certain field can have, that must also be the true mapping. Iteratively pull out the valid mappings until all have been determined:\n\nmapping &lt;- tibble(field_id = integer(), rule = character())\n\nwhile (nrow(field_options &gt; 1)) {\n  \n  mapping &lt;- field_options |&gt; \n    mutate(valid1 = n() == 1, .by = field_id) |&gt; \n    mutate(valid2 = n() == 1, .by = rule) |&gt; \n    filter(valid1 | valid2) |&gt; \n    select(field_id, rule) |&gt; \n    bind_rows(mapping)\n  \n  field_options &lt;- field_options |&gt; \n    anti_join(mapping, join_by(field_id)) |&gt; \n    anti_join(mapping, join_by(rule))\n}\n\nNow that the mapping has been determined for each field, join back to the tickets and multiply the departure field values together:\n\ntickets |&gt; \n  filter(owner == \"mine\") |&gt; \n  left_join(mapping, join_by(field_id)) |&gt; \n  filter(str_detect(rule, \"departure\")) |&gt; \n  pull(field_value) |&gt; \n  prod()",
    "crumbs": [
      "2020",
      "Day 16"
    ]
  },
  {
    "objectID": "2020/R/day03.html",
    "href": "2020/R/day03.html",
    "title": "Day 3",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day03.txt\")\n\nParse character strings and convert into a 1/0 matrix:\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  map(~ case_match(.x, \".\" ~ 0, \"#\" ~ 1)) |&gt; \n  reduce(rbind) |&gt; \n  unname()",
    "crumbs": [
      "2020",
      "Day 3"
    ]
  },
  {
    "objectID": "2020/R/day03.html#setup",
    "href": "2020/R/day03.html#setup",
    "title": "Day 3",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day03.txt\")\n\nParse character strings and convert into a 1/0 matrix:\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  map(~ case_match(.x, \".\" ~ 0, \"#\" ~ 1)) |&gt; \n  reduce(rbind) |&gt; \n  unname()",
    "crumbs": [
      "2020",
      "Day 3"
    ]
  },
  {
    "objectID": "2020/R/day03.html#part-1",
    "href": "2020/R/day03.html#part-1",
    "title": "Day 3",
    "section": "Part 1",
    "text": "Part 1\nDefine a function that converts a slope to indices:\n\nslope_to_idx &lt;- function(mtx, right, down) {\n  rows &lt;- seq.int(1, nrow(mtx), by = down)\n  cols &lt;- ((1:length(rows) - 1) * right) %% ncol(mtx) + 1\n  \n  array(c(rows, cols), dim = c(length(rows), 2))\n}\n\nDefine a function to count the encountered trees, given a slope:\n\ncount_trees &lt;- function(mtx, right, down) {\n  sum(mtx[slope_to_idx(mtx, right, down)])\n}\n\nCount the encountered trees for a slope of right 3, down 1:\n\ncount_trees(mtx, 3, 1)",
    "crumbs": [
      "2020",
      "Day 3"
    ]
  },
  {
    "objectID": "2020/R/day03.html#part-2",
    "href": "2020/R/day03.html#part-2",
    "title": "Day 3",
    "section": "Part 2",
    "text": "Part 2\nCompare the encountered trees when using the following slopes and take their product:\nRight 1, down 1\nRight 3, down 1\nRight 5, down 1\nRight 7, down 1\nRight 1, down 2\n\nright &lt;- c(1, 3, 5, 7, 1)\ndown  &lt;- c(1, 1, 1, 1, 2)\n\nmap2_dbl(right, down, \\(right, down) count_trees(mtx, right, down)) |&gt; \n  prod()",
    "crumbs": [
      "2020",
      "Day 3"
    ]
  },
  {
    "objectID": "2020/R/day01.html",
    "href": "2020/R/day01.html",
    "title": "Day 1",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead and parse text input from file:\n\ninput &lt;- scan(\"../input/day01.txt\")",
    "crumbs": [
      "2020",
      "Day 1"
    ]
  },
  {
    "objectID": "2020/R/day01.html#setup",
    "href": "2020/R/day01.html#setup",
    "title": "Day 1",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead and parse text input from file:\n\ninput &lt;- scan(\"../input/day01.txt\")",
    "crumbs": [
      "2020",
      "Day 1"
    ]
  },
  {
    "objectID": "2020/R/day01.html#part-1",
    "href": "2020/R/day01.html#part-1",
    "title": "Day 1",
    "section": "Part 1",
    "text": "Part 1\nCreate every combination of numbers, determine which sum to 2020, and take their product:\n\ncombn(input, m = 2, simplify = FALSE) |&gt; \n  keep(~ sum(.x) == 2020) |&gt; \n  map_dbl(prod)",
    "crumbs": [
      "2020",
      "Day 1"
    ]
  },
  {
    "objectID": "2020/R/day01.html#part-2",
    "href": "2020/R/day01.html#part-2",
    "title": "Day 1",
    "section": "Part 2",
    "text": "Part 2\nRepeat as above, but take combinations 3 at a time:\n\ncombn(input, m = 3, simplify = FALSE) |&gt; \n  keep(~ sum(.x) == 2020) |&gt; \n  map_dbl(prod)",
    "crumbs": [
      "2020",
      "Day 1"
    ]
  },
  {
    "objectID": "2020/R/day25.html",
    "href": "2020/R/day25.html",
    "title": "Day 25",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\npublic_keys &lt;- read_lines(\"../input/day25.txt\") |&gt; \n  as.numeric() |&gt; \n  set_names(c(\"card\", \"door\"))",
    "crumbs": [
      "2020",
      "Day 25"
    ]
  },
  {
    "objectID": "2020/R/day25.html#setup",
    "href": "2020/R/day25.html#setup",
    "title": "Day 25",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\npublic_keys &lt;- read_lines(\"../input/day25.txt\") |&gt; \n  as.numeric() |&gt; \n  set_names(c(\"card\", \"door\"))",
    "crumbs": [
      "2020",
      "Day 25"
    ]
  },
  {
    "objectID": "2020/R/day25.html#part-1",
    "href": "2020/R/day25.html#part-1",
    "title": "Day 25",
    "section": "Part 1",
    "text": "Part 1\nDefine a function which, given a subject number and a public key, determines the loop size:\n\nget_loop_size &lt;- function(public_key, subject_number) {\n  \n  n &lt;- 0\n  value &lt;- 1\n  \n  while (value != public_key) {\n    value &lt;- (value * subject_number) %% 20201227\n    n &lt;- n + 1\n  }\n  \n  n\n}\n\nRun on puzzle input to get the loop size for the card & door:\n\nloop_size &lt;- public_keys |&gt; \n  map_int(\\(x) get_loop_size(x, subject_number = 7))\n\nDefine a function to get the encryption key given a public key and loop size:\n\nencrypt &lt;- function(public_key, loop_size) {\n  reduce(1:loop_size, \\(x, n) (x * public_key) %% 20201227, .init = 1)\n}\n\nRun on puzzle input:\n\nmap2_dbl(public_keys, rev(loop_size), \\(x, y) encrypt(x, y))",
    "crumbs": [
      "2020",
      "Day 25"
    ]
  },
  {
    "objectID": "2020/R/day18.html",
    "href": "2020/R/day18.html",
    "title": "Day 18",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nDisable scientific notation to display large integers:\n\noptions(scipen = 999)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day18.txt\")",
    "crumbs": [
      "2020",
      "Day 18"
    ]
  },
  {
    "objectID": "2020/R/day18.html#setup",
    "href": "2020/R/day18.html#setup",
    "title": "Day 18",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nDisable scientific notation to display large integers:\n\noptions(scipen = 999)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day18.txt\")",
    "crumbs": [
      "2020",
      "Day 18"
    ]
  },
  {
    "objectID": "2020/R/day18.html#part-1",
    "href": "2020/R/day18.html#part-1",
    "title": "Day 18",
    "section": "Part 1",
    "text": "Part 1\nDefine a function that converts the plain text to a nested list, using parentheses as signals to nest:\n\nnest_eqn &lt;- function(x) {\n  x |&gt; \n    str_replace_all(\" \", \",\") |&gt; \n    str_replace_all(\"(\\\\d|\\\\+|\\\\*)\", \"'\\\\1'\") |&gt; \n    str_replace_all(\"\\\\(\", \"list(\") |&gt; \n    str_replace_all(\"^\", \"list(\") |&gt; \n    str_replace_all(\"$\", \")\") |&gt; \n    parse(text = _) |&gt; \n    eval()\n}\n\nDefine a function which takes a nested list of single-digit integers and +/* operators and performs the operations without precedence:\n\nparse_eqn &lt;- function(x) {\n  cur &lt;- 0\n  op  &lt;- '+'\n  \n  for (item in x) {\n    if (typeof(item) == \"list\")\n      item &lt;- parse_eqn(item)\n    \n    if (item %in% c(\"*\", \"+\"))\n      op &lt;- item\n    else\n      cur &lt;- get(op)(cur, as.numeric(item))\n  }\n  \n  cur\n}\n\nRun on puzzle input:\n\ninput |&gt; \n  map(nest_eqn) |&gt; \n  map_dbl(parse_eqn) |&gt; \n  sum()",
    "crumbs": [
      "2020",
      "Day 18"
    ]
  },
  {
    "objectID": "2020/R/day18.html#part-2",
    "href": "2020/R/day18.html#part-2",
    "title": "Day 18",
    "section": "Part 2",
    "text": "Part 2\nTo apply operator precedence, we re-nest our list one level deeper whenever we encounter our character with precedence. Here, whenever we see a ‘+’ character, we nest it one level deeper alongside the items preceeding and following it.\n\nnest_precedence &lt;- function(x) {\n  for (i in 1:length(x)) {\n    if (typeof(x[[i]]) == \"list\")\n      x[[i]] &lt;- nest_precedence(x[[i]])\n  }\n  \n  i &lt;- 2\n\n  while (i &lt; length(x)) {\n    if (typeof(x[[i]]) == \"character\" && x[[i]] == \"+\") {\n      x[[i - 1]] &lt;- list(x[[i - 1]], x[[i]], x[[i + 1]])\n      x &lt;- x[-c(i, i + 1)]\n      i &lt;- i - 1\n    }\n    i &lt;- i + 1\n  }\n  \n  x\n}\n\nRun on puzzle input:\n\ninput |&gt; \n  map(nest_eqn) |&gt; \n  map(nest_precedence) |&gt; \n  map_dbl(parse_eqn) |&gt;\n  sum()",
    "crumbs": [
      "2020",
      "Day 18"
    ]
  },
  {
    "objectID": "2020/R/day23.html",
    "href": "2020/R/day23.html",
    "title": "Day 23",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day23.txt\") |&gt; \n  str_split_1(\"\") |&gt; \n  as.numeric()",
    "crumbs": [
      "2020",
      "Day 23"
    ]
  },
  {
    "objectID": "2020/R/day23.html#setup",
    "href": "2020/R/day23.html#setup",
    "title": "Day 23",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day23.txt\") |&gt; \n  str_split_1(\"\") |&gt; \n  as.numeric()",
    "crumbs": [
      "2020",
      "Day 23"
    ]
  },
  {
    "objectID": "2020/R/day23.html#part-1",
    "href": "2020/R/day23.html#part-1",
    "title": "Day 23",
    "section": "Part 1",
    "text": "Part 1\nDefine a game function which uses a linked list structure to quickly identify and reorder neighbors:\n\nrun_game &lt;- function(init, n_moves) {\n  \n  # Convert ordered vector to linked list\n  cur    &lt;- head(init, 1)\n  linked &lt;- lead(init, default = cur)[order(init)]\n  \n  # For the specified number of rounds, reorder the linked list by game rules\n  for (n in 1:n_moves) {\n  \n    clockwise &lt;- cur\n    pickup &lt;- c()\n    \n    for (i in 1:3) {\n      clockwise &lt;- linked[clockwise]\n      pickup &lt;- c(pickup, clockwise)\n    }\n    \n    dest &lt;- setdiff(((cur - (1:4) - 1) %% length(linked)) + 1, pickup)[1]\n  \n    linked[cur]       &lt;- linked[pickup[3]]\n    linked[pickup[3]] &lt;- linked[dest]\n    linked[dest]      &lt;- pickup[1]\n  \n    cur &lt;- linked[cur]\n  }\n  \n  linked\n}\n\nRun 100 rounds on the puzzle input:\n\noutput &lt;- run_game(input, 100)\n\nGather the labels of all cups after cup 1, in order:\n\nvec &lt;- 1\n\nfor (n in 2:length(output)) {\n  vec &lt;- c(vec, output[tail(vec, 1)])\n}\n\nvec |&gt; \n  tail(-1) |&gt; \n  str_flatten(\"\")",
    "crumbs": [
      "2020",
      "Day 23"
    ]
  },
  {
    "objectID": "2020/R/day23.html#part-2",
    "href": "2020/R/day23.html#part-2",
    "title": "Day 23",
    "section": "Part 2",
    "text": "Part 2\nExpand the puzzle input up to 1,000,000, then run 10,000,000 rounds on the new input:\n\noutput &lt;- run_game(c(input, (max(input) + 1):1000000), 10000000)\n\nMultiply the values of first two clockwise cups in the final output following cup 1:\n\noutput[1] * output[output[1]]",
    "crumbs": [
      "2020",
      "Day 23"
    ]
  },
  {
    "objectID": "2020/R/day08.html",
    "href": "2020/R/day08.html",
    "title": "Day 8",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file and parse into a dataframe of character operations and integer arguments:\n\ninput &lt;- read_lines(\"../input/day08.txt\") |&gt; \n  unglue_data(\"{op} {arg}\", convert = TRUE) |&gt; \n  deframe()",
    "crumbs": [
      "2020",
      "Day 8"
    ]
  },
  {
    "objectID": "2020/R/day08.html#setup",
    "href": "2020/R/day08.html#setup",
    "title": "Day 8",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file and parse into a dataframe of character operations and integer arguments:\n\ninput &lt;- read_lines(\"../input/day08.txt\") |&gt; \n  unglue_data(\"{op} {arg}\", convert = TRUE) |&gt; \n  deframe()",
    "crumbs": [
      "2020",
      "Day 8"
    ]
  },
  {
    "objectID": "2020/R/day08.html#part-1",
    "href": "2020/R/day08.html#part-1",
    "title": "Day 8",
    "section": "Part 1",
    "text": "Part 1\nDefine a function to loop through the instructions in the input, break whenever an instruction is visited for a second time, and return the accumulator value at that time:\n\nfind_loop &lt;- function(instructions) {\n  \n  visited &lt;- rep(FALSE, length(instructions))\n  acc &lt;- 0\n  i &lt;- 1\n  \n  while (i &lt;= length(instructions)) {\n    if (visited[i]) {\n      return(acc)\n    } else {\n      visited[i] &lt;- TRUE\n    }\n    \n    op  &lt;- names(instructions)[[i]]\n    arg &lt;- instructions[[i]]\n    \n    if (op == \"nop\") {\n      i &lt;- i + 1\n    } else if (op == \"acc\") {\n      acc &lt;- acc + arg\n      i &lt;- i + 1\n    } else if (op == \"jmp\") {\n      i &lt;- i + arg\n    }\n  }\n  \n  return(NA)\n}\n\nRun on puzzle input:\n\nfind_loop(input)",
    "crumbs": [
      "2020",
      "Day 8"
    ]
  },
  {
    "objectID": "2020/R/day08.html#part-2",
    "href": "2020/R/day08.html#part-2",
    "title": "Day 8",
    "section": "Part 2",
    "text": "Part 2\nSwap each jmp and nop operation one-by-one and see which swap results in a valid output (no loop):\n\ninstr_mod &lt;- map(\n  which(names(input) %in% c(\"jmp\", \"nop\")),\n  \\(idx) {\n    input |&gt; \n      set_names(modify_at(\n        names(input), \n        idx, \n        ~ case_match(.x, \"jmp\" ~ \"nop\", \"nop\" ~ \"jmp\")\n      ))\n  }\n)\n\nidx_mod &lt;- instr_mod |&gt; \n  map_dbl(find_loop) |&gt; \n  detect_index(is.na)\n\nModify the find_loop function to run the instructions and return the final value of the accumulator:\n\nrun_instr &lt;- function(instructions) {\n  acc &lt;- 0\n  i &lt;- 1\n  \n  while (i &lt;= length(instructions)) {\n    op  &lt;- names(instructions)[[i]]\n    arg &lt;- instructions[[i]]\n    \n    if (op == \"nop\") {\n      i &lt;- i + 1\n    } else if (op == \"acc\") {\n      acc &lt;- acc + arg\n      i &lt;- i + 1\n    } else if (op == \"jmp\") {\n      i &lt;- i + arg\n    }\n  }\n  \n  return(acc)\n}\n\nRun on the valid modified index:\n\nrun_instr(instr_mod[[idx_mod]])",
    "crumbs": [
      "2020",
      "Day 8"
    ]
  },
  {
    "objectID": "2020/R/day21.html",
    "href": "2020/R/day21.html",
    "title": "Day 21",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day21.txt\", skip_empty_rows = TRUE)\n\nConvert plain text input into lists of ingredients and allergens:\n\ndf &lt;- input |&gt; \n  unglue_data(\"{ingredient} (contains {allergen})\") |&gt; \n  mutate(\n    food_id = row_number(),\n    ingredient = str_split(ingredient, \" \"),\n    allergen = str_split(allergen, \", \")\n  ) |&gt; \n  unnest_longer(ingredient) |&gt; \n  unnest_longer(allergen)",
    "crumbs": [
      "2020",
      "Day 21"
    ]
  },
  {
    "objectID": "2020/R/day21.html#setup",
    "href": "2020/R/day21.html#setup",
    "title": "Day 21",
    "section": "",
    "text": "Import libraries:\n\nlibrary(tidyverse)\nlibrary(unglue)\n\nRead text input from file:\n\ninput &lt;- read_lines(\"../input/day21.txt\", skip_empty_rows = TRUE)\n\nConvert plain text input into lists of ingredients and allergens:\n\ndf &lt;- input |&gt; \n  unglue_data(\"{ingredient} (contains {allergen})\") |&gt; \n  mutate(\n    food_id = row_number(),\n    ingredient = str_split(ingredient, \" \"),\n    allergen = str_split(allergen, \", \")\n  ) |&gt; \n  unnest_longer(ingredient) |&gt; \n  unnest_longer(allergen)",
    "crumbs": [
      "2020",
      "Day 21"
    ]
  },
  {
    "objectID": "2020/R/day21.html#part-1",
    "href": "2020/R/day21.html#part-1",
    "title": "Day 21",
    "section": "Part 1",
    "text": "Part 1\nIteratively pull ingredient-allergen pairs where one ingredient is the only option for a given allergen:\n\nidentified &lt;- tibble(allergen = character(0), ingredient = character(0))\n\nn_prv &lt;- -1\n\nwhile(n_prv != nrow(identified)) {\n  n_prv &lt;- nrow(identified)\n  \n  identified &lt;- df |&gt; \n    anti_join(identified, join_by(allergen)) |&gt; \n    anti_join(identified, join_by(ingredient)) |&gt; \n    summarize(n = n(), .by = c(allergen, ingredient)) |&gt; \n    arrange(allergen, desc(n)) |&gt; \n    slice_max(order_by = n, by = allergen) |&gt; \n    filter(n() == 1, .by = allergen) |&gt; \n    select(allergen, ingredient) |&gt; \n    bind_rows(identified)\n}\n\nCount the number of times that non-allergen ingredients appear in the list:\n\ndf |&gt; \n  anti_join(identified, join_by(ingredient)) |&gt; \n  distinct(ingredient, food_id) |&gt; \n  nrow()",
    "crumbs": [
      "2020",
      "Day 21"
    ]
  },
  {
    "objectID": "2020/R/day21.html#part-2",
    "href": "2020/R/day21.html#part-2",
    "title": "Day 21",
    "section": "Part 2",
    "text": "Part 2\nArrange the allergen-containing ingredients alphabetically by allergen, then convert to a CSV string:\n\nidentified |&gt; \n  arrange(allergen) |&gt; \n  pull(ingredient) |&gt; \n  str_flatten(\",\")",
    "crumbs": [
      "2020",
      "Day 21"
    ]
  }
]