[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advent of Code: Worked Solutions",
    "section": "",
    "text": "Worked solutions in R to the Advent of Code – a yearly advent calendar of programming puzzles.\n\nSOLUTION INDEX\n★★ = Parts 1 & 2; ★☆ = Part 1 Only\n\n\n\n2024\n2023\n2022\n\n\n\n\nDay 1\n★★\n★★\n★★\n\n\nDay 2\n★★\n★★\n★★\n\n\nDay 3\n★★\n★★\n★★\n\n\nDay 4\n★★\n★★\n★★\n\n\nDay 5\n★★\n★★\n★★\n\n\nDay 6\n★★\n★★\n★★\n\n\nDay 7\n★★\n★★\n★★\n\n\nDay 8\n★★\n★★\n★★\n\n\nDay 9\n★★\n★★\n★★\n\n\nDay 10\n★★\n★★\n★★\n\n\nDay 11\n★★\n★★\n★★\n\n\nDay 12\n★★\n★★\n★★\n\n\nDay 13\n★★\n★★\n★★\n\n\nDay 14\n★★\n★★\n★★\n\n\nDay 15\n★★\n★★\n★★\n\n\nDay 16\n★★\n★★\n★★\n\n\nDay 17\n★★\n★★\n★★\n\n\nDay 18\n★★\n★★\n★★\n\n\nDay 19\n★★\n★★\n★★\n\n\nDay 20\n★★\n★★\n★★\n\n\nDay 21\n★★\n\n★★\n\n\nDay 22\n★★\n\n★★\n\n\nDay 23\n★★\n\n★★\n\n\nDay 24\n★★\n\n★★\n\n\nDay 25\n★★\n\n★★"
  },
  {
    "objectID": "2023/R/day20.html",
    "href": "2023/R/day20.html",
    "title": "Day 20",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day20.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 20"
    ]
  },
  {
    "objectID": "2023/R/day20.html#setup",
    "href": "2023/R/day20.html#setup",
    "title": "Day 20",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day20.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 20"
    ]
  },
  {
    "objectID": "2023/R/day20.html#part-1",
    "href": "2023/R/day20.html#part-1",
    "title": "Day 20",
    "section": "Part 1",
    "text": "Part 1\nConvert text input into a nested list of modules:\n\ndf &lt;- input |&gt; \n  unglue_data(\"{prefix=(%|&)?}{name} -&gt; {destinations}\") |&gt; \n  mutate(destinations = str_split(destinations, \",\\\\s*\"))\n\nsources &lt;- df |&gt; \n  unnest_longer(destinations) |&gt; \n  summarize(sources = list(name), .by = destinations)\n\nblank_add &lt;- sources |&gt; \n  anti_join(df, join_by(x$destinations == y$name)) |&gt; \n  transmute(name = destinations, prefix = '')\n\nmodules &lt;- df |&gt; \n  left_join(sources, join_by(x$name == y$destinations)) |&gt; \n  add_row(name = \"button\", prefix = '', destinations = list(\"broadcaster\")) |&gt; \n  bind_rows(blank_add) |&gt; \n  mutate(\n    state = case_when(prefix == '%' ~ FALSE),\n    memories = case_when(\n      prefix == '&' ~ map(sources, ~ set_names(rep(FALSE, length(.x)), .x))\n    ),\n    n_lo = 0,\n    n_hi = 0\n  ) |&gt; \n  transmute(\n    name,\n    value = pmap(lst(prefix, destinations, state, memories, n_lo, n_hi), lst)\n  ) |&gt; \n  deframe()\n\nDefine a function that modifies a set of modules when the button is pushed:\n\npush_button &lt;- function(modules) {\n  queue &lt;- list(list(source = \"button\", target = \"broadcaster\", pulse = FALSE))\n  modules$button$n_lo &lt;- modules$button$n_lo + 1\n  \n  while (length(queue) &gt; 0) {\n    signal &lt;- queue[[1]]\n    queue  &lt;- queue[-1]\n    module &lt;- modules[[signal$target]]\n    output &lt;- NULL\n    \n    if (signal$target == \"broadcaster\") {\n      output &lt;- signal$pulse\n    } else if (module$prefix == '%' & signal$pulse == FALSE) {\n      modules[[signal$target]]$state &lt;- !module$state\n      output &lt;- !module$state\n    } else if (module$prefix == '&') {\n      modules[[signal$target]]$memories[[signal$source]] &lt;- signal$pulse\n      output &lt;- !all(modules[[signal$target]]$memories == TRUE)\n    }\n    \n    if (!is.null(output)) {\n      queue_add &lt;- module$destinations |&gt; \n        map(~ list(source = signal$target, target = .x, pulse = output))\n      queue &lt;- c(queue, queue_add)\n      \n      n &lt;- length(module$destinations)\n      \n      if (output == TRUE)\n        modules[[signal$target]]$n_hi &lt;- modules[[signal$target]]$n_hi + n\n      else\n        modules[[signal$target]]$n_lo &lt;- modules[[signal$target]]$n_lo + n \n    }\n  }\n  \n  modules\n}\n\nDefine a function that sums the total low vs high buttons sent at a given state of the modules:\n\ncount_pulses &lt;- function(modules) {\n  c(\n    lo = sum(map_int(modules, ~ .x$n_lo)),\n    hi = sum(map_int(modules, ~ .x$n_hi))\n  )\n}\n\nRun on puzzle input:\n\noutput &lt;- modules\n\nfor (i in 1:1000) {\n  output &lt;- push_button(output)\n}\n\ncount_pulses(output) |&gt; \n  prod()\n\n[1] 818649769",
    "crumbs": [
      "2023",
      "Day 20"
    ]
  },
  {
    "objectID": "2023/R/day20.html#part-2",
    "href": "2023/R/day20.html#part-2",
    "title": "Day 20",
    "section": "Part 2",
    "text": "Part 2\nExamining the input, tj sends a low pulse to rx if its last memories (kk, xc, sk, vt) are all high pulses. For each of those memories, we just check when it first sends a high pulse to compute its cycle length, then take the LCM:\n\npushes_until_sent &lt;- function(modules, name, pulse = c(\"hi\", \"lo\")) {\n  pulse &lt;- c(\"n_\", pulse)\n  i &lt;- 0\n  \n  while (pluck(modules, name, \"n_hi\") == 0) {\n    modules &lt;- push_button(modules)\n    i &lt;- i + 1\n  }\n  \n  return(i)\n}\n\nc(\"kk\", \"xc\", \"sk\", \"vt\") |&gt; \n  map_dbl(~ pushes_until_sent(modules, .x, \"hi\")) |&gt; \n  numbers::mLCM() |&gt; \n  format(scientific = FALSE)\n\n[1] \"246313604784977\"",
    "crumbs": [
      "2023",
      "Day 20"
    ]
  },
  {
    "objectID": "2023/R/day18.html",
    "href": "2023/R/day18.html",
    "title": "Day 18",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(sf)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day18.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\"{dir} {meters} ({color})\", convert = TRUE)",
    "crumbs": [
      "2023",
      "Day 18"
    ]
  },
  {
    "objectID": "2023/R/day18.html#setup",
    "href": "2023/R/day18.html#setup",
    "title": "Day 18",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(sf)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day18.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\"{dir} {meters} ({color})\", convert = TRUE)",
    "crumbs": [
      "2023",
      "Day 18"
    ]
  },
  {
    "objectID": "2023/R/day18.html#part-1",
    "href": "2023/R/day18.html#part-1",
    "title": "Day 18",
    "section": "Part 1",
    "text": "Part 1\nConvert the instruction input into list of corners that define the trench polygon:\n\ntrench &lt;- input |&gt;\n  mutate(\n    x = case_match(dir, c('U', 'D') ~ 0, 'L' ~ -1, 'R' ~ 1) * meters,\n    y = case_match(dir, c('L', 'R') ~ 0, 'D' ~ -1, 'U' ~ 1) * meters\n  ) |&gt; \n  pmap(\\(x, y, ...) c(x = x, y = y)) |&gt; \n  accumulate(`+`, .init = c(x = 0, y = 0))\n\nConvert the polygon’s boundary to a spatial object using SF:\n\npolygon &lt;- trench |&gt;\n  reduce(rbind) |&gt; \n  list() |&gt; \n  st_polygon() |&gt; \n  st_buffer(dist = 0.5, joinStyle = 'MITRE', mitreLimit = sqrt(2))\n\nggplot(polygon) + \n  geom_sf() +\n  theme_void()\n\n\n\n\n\n\n\n\nCompute the polygon’s area:\n\nst_area(polygon)\n\n[1] 53844",
    "crumbs": [
      "2023",
      "Day 18"
    ]
  },
  {
    "objectID": "2023/R/day18.html#part-2",
    "href": "2023/R/day18.html#part-2",
    "title": "Day 18",
    "section": "Part 2",
    "text": "Part 2\nConvert the hex codes to new trench instructions:\n\ntrench &lt;- input |&gt; \n  mutate(\n    meters = strtoi(str_sub(color, 2L, -2L), base = 16L),\n    dir = case_match(\n      str_sub(color, start = -1L),\n      '0' ~ 'R', '1' ~ 'D', '2' ~ 'L', '3' ~ 'U'\n    ),\n    x = case_match(dir, c('U', 'D') ~ 0, 'L' ~ -1, 'R' ~ 1) * meters,\n    y = case_match(dir, c('L', 'R') ~ 0, 'D' ~ -1, 'U' ~ 1) * meters\n  ) |&gt; \n  pmap(\\(x, y, ...) c(x = x, y = y)) |&gt; \n  accumulate(`+`, .init = c(x = 0, y = 0))\n\nConvert to a new polygon:\n\npolygon &lt;- trench |&gt;\n  reduce(rbind) |&gt; \n  list() |&gt; \n  st_polygon() |&gt; \n  st_buffer(dist = 0.5, joinStyle = 'MITRE', mitreLimit = sqrt(2))\n\nggplot(polygon) + \n  geom_sf() +\n  theme_void()\n\n\n\n\n\n\n\n\nCompute the polygon’s area:\n\nst_area(polygon) |&gt; \n  format(scientific = FALSE)\n\n[1] \"42708339569950\"",
    "crumbs": [
      "2023",
      "Day 18"
    ]
  },
  {
    "objectID": "2023/R/day14.html",
    "href": "2023/R/day14.html",
    "title": "Day 14",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day14.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 14"
    ]
  },
  {
    "objectID": "2023/R/day14.html#setup",
    "href": "2023/R/day14.html#setup",
    "title": "Day 14",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day14.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 14"
    ]
  },
  {
    "objectID": "2023/R/day14.html#part-1",
    "href": "2023/R/day14.html#part-1",
    "title": "Day 14",
    "section": "Part 1",
    "text": "Part 1\nConvert the input text into a matrix:\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  unlist() |&gt; \n  matrix(nrow = length(input), byrow = TRUE)\n\nFrom Reddit hints: can use matrix transforms and regex to make the tilting computations more efficient.\n\n# For a set of string vectors, shift all rocks in them to the left. \nshift &lt;- function(str) {\n  repeat {\n    new &lt;- str_replace_all(str, \"\\\\.O\", \"O\\\\.\")\n\n    if (all(str == new))\n      return(str)\n    else\n      str &lt;- new\n  }\n}\n\n# Tilt the entire matrix in a given direction (N/S/W/E)\ntilt &lt;- function(mtx, dir = 'N') {\n  \n  if (dir %in% c('W', 'E'))\n    mtx &lt;- t(mtx)\n  if (dir %in% c('S', 'E'))\n    mtx &lt;- apply(mtx, 2, rev)\n  \n  # Split the matrix into columns, shift the rocks, and recombine\n  mtx &lt;- split(mtx, col(mtx)) |&gt; \n    map(str_flatten) |&gt; \n    shift() |&gt; \n    str_split(\"\") |&gt; \n    do.call(args = _, what = cbind)\n  \n  if (dir %in% c('S', 'E'))\n    mtx &lt;- apply(mtx, 2, rev)\n  if (dir %in% c('W', 'E'))\n    mtx &lt;- t(mtx)\n  \n  mtx\n}\n\nTilt the matrix and sum up the load:\n\ncompute_load &lt;- function(mtx) {\n  split(mtx, col(mtx)) |&gt; \n    map(~ which(rev(.x) == \"O\")) |&gt; \n    unlist() |&gt; \n    sum()\n}\n\nmtx |&gt; \n  tilt() |&gt; \n  compute_load()\n\n[1] 109661",
    "crumbs": [
      "2023",
      "Day 14"
    ]
  },
  {
    "objectID": "2023/R/day14.html#part-2",
    "href": "2023/R/day14.html#part-2",
    "title": "Day 14",
    "section": "Part 2",
    "text": "Part 2\nLook for a cycle, then jump ahead to the 1000000000th state\n\ncycle &lt;- \\(mtx) reduce(c('N', 'W', 'S', 'E'), tilt, .init = mtx)\n\n# Initialize\ncur  &lt;- mtx\nloop &lt;- list()\ni &lt;- 0\n\n# Loop through cycles until a repeating loop is found\nrepeat {\n  i &lt;- i + 1\n  cur &lt;- cycle(cur)\n  loop[[i]] &lt;- cur\n  \n  if (any(duplicated(loop)))\n    break\n}\n\n# Compute the length of the cycle and its starting point\ncycle_rep   &lt;- which(duplicated(loop) | duplicated(loop, fromLast = TRUE))\ncycle_len   &lt;- max(cycle_rep) - min(cycle_rep)\ncycle_start &lt;- min(cycle_rep)\n\n# Compute an equivalent index to find the state at the 1000000000th cycle\nidx &lt;- (1000000000 - cycle_start) %% cycle_len + cycle_start\n\nloop[[idx]] |&gt; \n  compute_load()\n\n[1] 90176",
    "crumbs": [
      "2023",
      "Day 14"
    ]
  },
  {
    "objectID": "2023/R/day15.html",
    "href": "2023/R/day15.html",
    "title": "Day 15",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day15.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split_1(\",\")",
    "crumbs": [
      "2023",
      "Day 15"
    ]
  },
  {
    "objectID": "2023/R/day15.html#setup",
    "href": "2023/R/day15.html#setup",
    "title": "Day 15",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day15.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split_1(\",\")",
    "crumbs": [
      "2023",
      "Day 15"
    ]
  },
  {
    "objectID": "2023/R/day15.html#part-1",
    "href": "2023/R/day15.html#part-1",
    "title": "Day 15",
    "section": "Part 1",
    "text": "Part 1\nDefine a function that converts a character string into a hash value as defined by the specs:\n\nascii_hash &lt;- function(str) {\n  reduce(\n    .x = utf8ToInt(str),\n    .f = ~ ((.x + .y) * 17) %% 256, \n    .init = 0\n  )\n}\n\nSeparate the input at the commas, run the ASCII hash on each item, and sum the result:\n\ninput |&gt; \n  map_int(ascii_hash) |&gt; \n  sum()\n\n[1] 511215",
    "crumbs": [
      "2023",
      "Day 15"
    ]
  },
  {
    "objectID": "2023/R/day15.html#part-2",
    "href": "2023/R/day15.html#part-2",
    "title": "Day 15",
    "section": "Part 2",
    "text": "Part 2\nDefine a function to place lenses in the appropriate boxes as defined by the input sequence:\n\nhashmap &lt;- function(boxes, str) {\n  label     &lt;- str_extract(str, \"[a-z]+\")\n  box_num   &lt;- ascii_hash(label) + 1\n  operation &lt;- str_extract(str, \"-|=\")\n\n  if (operation == \"=\") \n    boxes[[box_num]][[label]] &lt;- parse_number(str)\n  if (operation == \"-\")\n    boxes[[box_num]] &lt;- discard_at(boxes[[box_num]], label)\n\n  boxes\n}\n\nDefine a function to compute the focusing power of the lenses in the final box arrangement:\n\nfocusing_power &lt;- function(boxes) {\n  boxes |&gt; \n    imap(\\(box, box_num) {\n      imap(unname(box), \\(lens, lens_num) {\n        (as.integer(box_num) + 1) * lens_num * lens\n      })\n    }) |&gt; \n    unlist() |&gt; \n    sum()\n}\n\nRun on puzzle input:\n\ninit_boxes &lt;- map(set_names(0:255), ~ list())\n\ninput |&gt; \n  reduce(hashmap, .init = init_boxes) |&gt; \n  focusing_power()\n\n[1] 236057",
    "crumbs": [
      "2023",
      "Day 15"
    ]
  },
  {
    "objectID": "2023/R/day17.html",
    "href": "2023/R/day17.html",
    "title": "Day 17",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day17.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 17"
    ]
  },
  {
    "objectID": "2023/R/day17.html#setup",
    "href": "2023/R/day17.html#setup",
    "title": "Day 17",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day17.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 17"
    ]
  },
  {
    "objectID": "2023/R/day17.html#part-1",
    "href": "2023/R/day17.html#part-1",
    "title": "Day 17",
    "section": "Part 1",
    "text": "Part 1\nConvert text input to a set of 2D coordinates (stored as complex numbers) and their costs:\n\nvtx &lt;- input |&gt; \n  enframe(name = \"row\") |&gt; \n  mutate(value = str_split(value, \"\")) |&gt; \n  unnest_longer(value, indices_to = \"col\") |&gt; \n  transmute(\n    id = row_number(),\n    z = complex(real = col, imaginary = row),\n    cost = as.integer(value)\n  )\n\nz    &lt;- pull(vtx, z)\ncost &lt;- pull(vtx, cost)\n\nnmax &lt;- length(z)\n\nDefine a set of helper functions needed for the pathfinding algorithm:\n\n# Sort a list of lists by the value at the given/named index of the inner lists\nnested_sort &lt;- \\(x, idx) x[order(sapply(x, '[[', idx))]\npsort &lt;- partial(nested_sort, idx = \"priority\")\n\n# Compute the manhattan distance between any two vertices\nmanhattan_dist &lt;- \\(a, b) abs(Re(a - b)) + abs(Im(a - b))\n\n# Pull a vertex's neighbors along the given axis (Re/Im) within a set dist range\nneighbors &lt;- function(vtx, axis = c(\"Re\", \"Im\"), dmin, dmax) {\n  rng &lt;- c(-dmax:-dmin, dmin:dmax) \n  nbr &lt;- vtx + (rng * complex(real = axis == \"Re\", imaginary = axis == \"Im\"))\n  keep(nbr, ~ .x %in% z)\n}\n\n# Compute the cost of moving in a straight line between two vertices\nmove_cost &lt;- function(source, target) {\n  path_indices &lt;- complex(\n    real      = seq(Re(source), Re(target)),\n    imaginary = seq(Im(source), Im(target))\n  ) |&gt; \n    discard(~ .x == source) |&gt; \n    match(z)\n  \n  sum(cost[path_indices])\n}\n\nA* pathfinding implementation (with much help from Reddit on use of complex numbers and storing the turns as part of the state):\n\nhttps://en.wikipedia.org/wiki/A*_search_algorithm\nhttps://www.redblobgames.com/pathfinding/a-star/introduction.html\nhttps://www.reddit.com/r/adventofcode/comments/18khohi/comment/kdrkivy/\n\n\na_star &lt;- function(start, goal, h, dmin, dmax) {\n  \n  # Current set of discovered nodes awaitng further investigation\n  frontier &lt;- list(\n    list(id = start, axis = 'Re', priority = 0),\n    list(id = start, axis = 'Im', priority = 0)\n  )\n  \n  # For each vertex, the immediately preceeding vertex on its cheapest path\n  came_from &lt;- rep(list(lst(Re = NA, Im = NA)), nmax)\n  \n  # Tracks the current min cost to get from 'start' node to node n\n  cost_so_far &lt;- rep(list(lst(Re = Inf, Im = Inf)), nmax)\n  cost_so_far[[start]]$Re &lt;- 0\n  cost_so_far[[start]]$Im &lt;- 0\n  \n  while (length(frontier) &gt; 0) {\n    cur_id   &lt;- frontier[[1]]$id\n    cur_z    &lt;- z[[cur_id]]\n    cur_axis &lt;- frontier[[1]]$axis\n    nxt_axis &lt;- case_match(cur_axis, 'Re' ~ 'Im', 'Im' ~ 'Re')\n    frontier &lt;- tail(frontier, -1)\n    \n    # Return info about best path to goal\n    if (cur_id == goal) return(cost_so_far[[cur_id]][[cur_axis]])\n    \n    # If this path is better than the current record, then replace it\n    for (nxt_z in neighbors(cur_z, cur_axis, dmin, dmax)) {\n      nxt_id &lt;- match(nxt_z, z)\n      tentative_cost &lt;- cost_so_far[[cur_id]][[cur_axis]] + move_cost(cur_z, nxt_z)\n      \n      if (tentative_cost &lt; cost_so_far[[nxt_id]][[nxt_axis]]) {\n        came_from[[nxt_id]][[nxt_axis]] &lt;- cur_id\n        cost_so_far[[nxt_id]][[nxt_axis]] &lt;- tentative_cost\n        \n        frontier &lt;- psort(c(frontier, list(list(\n          id = nxt_id, \n          axis = nxt_axis, \n          priority = tentative_cost + h(nxt_z, z[[goal]])\n        ))))\n      }\n    }\n  }\n}\n\nRun on puzzle input:\n\na_star(1, nmax, h = manhattan_dist, dmin = 1, dmax = 3)\n\n[1] 847",
    "crumbs": [
      "2023",
      "Day 17"
    ]
  },
  {
    "objectID": "2023/R/day17.html#part-2",
    "href": "2023/R/day17.html#part-2",
    "title": "Day 17",
    "section": "Part 2",
    "text": "Part 2\nRe-run on puzzle input with modified min/max distance values passed to the neighbors function:\n\na_star(1, nmax, h = manhattan_dist, dmin = 4, dmax = 10)\n\n[1] 997",
    "crumbs": [
      "2023",
      "Day 17"
    ]
  },
  {
    "objectID": "2023/R/day02.html",
    "href": "2023/R/day02.html",
    "title": "Day 2",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day02.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 2"
    ]
  },
  {
    "objectID": "2023/R/day02.html#setup",
    "href": "2023/R/day02.html#setup",
    "title": "Day 2",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day02.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 2"
    ]
  },
  {
    "objectID": "2023/R/day02.html#part-1",
    "href": "2023/R/day02.html#part-1",
    "title": "Day 2",
    "section": "Part 1",
    "text": "Part 1\nExtract game IDs and red/green/blue counts from each line in the input:\n\ncubes &lt;- input |&gt; \n  \n  # Extract cube colors, numbers, rounds, and games\n  unglue_data(\"Game {game}: {txt=.*}\", convert = TRUE) |&gt; \n  mutate(txt = str_split(txt, \"; \")) |&gt; \n  unnest_longer(txt, indices_to = \"round\", values_to = \"txt\") |&gt; \n  mutate(txt = str_split(txt, \", \")) |&gt; \n  unnest_longer(txt) |&gt; \n  separate(txt, into = c(\"num_cubes\", \"color\"), convert = TRUE) |&gt; \n  \n  # Add implicit zero counts for each color of cube not listed in each round\n  complete(\n    color = c(\"red\", \"blue\", \"green\"), \n    nesting(game, round),\n    fill = list(num_cubes = 0)\n  )\n\nCheck which games are possible if the bag contains only 12 red cubes, 13 green cubes, and 14 blue cubes by flagging any games with any color count over the limit:\n\nlimits &lt;- c(\"red\" = 12, \"green\" = 13, \"blue\" = 14)\n\ncubes |&gt; \n  \n  # Categorize each game as possible vs impossible\n  mutate(num_over_lim = num_cubes &gt; limits[color]) |&gt; \n  summarize(impossible = any(num_over_lim), .by = game) |&gt; \n  \n  # Pull and sum the indices of the possible games\n  filter(!impossible) |&gt; \n  pull(game) |&gt; \n  sum()\n\n[1] 2369",
    "crumbs": [
      "2023",
      "Day 2"
    ]
  },
  {
    "objectID": "2023/R/day02.html#part-2",
    "href": "2023/R/day02.html#part-2",
    "title": "Day 2",
    "section": "Part 2",
    "text": "Part 2\nWithin each game, compute the minimum number of cubes of each color by taking the maximum count of each color over all rounds in each game:\n\ncubes |&gt; \n  summarize(min_cubes = max(num_cubes), .by = c(game, color)) |&gt; \n  pivot_wider(names_from = color, values_from = min_cubes) |&gt; \n  mutate(power = blue * green * red) |&gt; \n  pull(power) |&gt; \n  sum()\n\n[1] 66363",
    "crumbs": [
      "2023",
      "Day 2"
    ]
  },
  {
    "objectID": "2023/R/day12.html",
    "href": "2023/R/day12.html",
    "title": "Day 12",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day12.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 12"
    ]
  },
  {
    "objectID": "2023/R/day12.html#setup",
    "href": "2023/R/day12.html#setup",
    "title": "Day 12",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day12.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 12"
    ]
  },
  {
    "objectID": "2023/R/day12.html#part-1",
    "href": "2023/R/day12.html#part-1",
    "title": "Day 12",
    "section": "Part 1",
    "text": "Part 1\nConvert text input to a dataframe. Identifiy the indices of each unknown value per row, and convert the numeric input into a regex pattern to test if a given spring arrangement is possible:\n\ndf &lt;- input |&gt; \n  unglue_data(\"{chr} {num}\") |&gt; \n  mutate(\n    regex_pattern = str_c(\n      \"^\\\\.*#{\", \n      str_replace_all(num, \",\", \"}\\\\.+#{\"),\n      \"}\\\\.*$\"\n    ),\n    u_idx = map(chr, ~ which(str_split_1(.x, \"\") == \"?\")),\n    num = map(num, ~ as.integer(str_split_1(.x, \",\"))),\n    total_broken = map_int(num, sum),\n    cur_broken = str_count(chr, \"#\"),\n    num_b = total_broken - cur_broken\n  )\n\nDefine a function to compute the total number of possible arrangements of broken springs for a given row using regex:\n\nidx_permutations &lt;- function(u_idx, num_b) {\n  \n  if (num_b == 0) {\n    list(list(B = numeric(0), O = u_idx))\n  } else {\n    permutations &lt;- combn(length(u_idx), num_b)\n    map(\n      1:ncol(permutations),\n      ~ list(\n        B = u_idx[permutations[,.x]],\n        O = u_idx[-permutations[,.x]]\n      )\n    )\n  }\n  \n}\n\nnum_arragements &lt;- function(input, regex_pattern, u_idx, num_b) {\n  perms &lt;- idx_permutations(u_idx, num_b)\n  vec   &lt;- str_split_1(input, \"\")\n  \n  perms |&gt; \n    map_chr(\\(perm) {\n      vec |&gt; \n        replace(perm$O, \".\") |&gt; \n        replace(perm$B, \"#\") |&gt; \n        str_c(collapse = \"\")\n    }) |&gt; \n    str_detect(regex_pattern) |&gt; \n    sum()\n}\n\nRun on puzzle input:\n\ndf |&gt; \n  pmap_int(\\(chr, regex_pattern, u_idx, num_b, ...) {\n    num_arragements(chr, regex_pattern, u_idx, num_b)\n  }) |&gt; \n  sum()\n\n[1] 7674",
    "crumbs": [
      "2023",
      "Day 12"
    ]
  },
  {
    "objectID": "2023/R/day12.html#part-2",
    "href": "2023/R/day12.html#part-2",
    "title": "Day 12",
    "section": "Part 2",
    "text": "Part 2\nWith hints from Reddit, re-define the arrangement-counting function using memoization and recursion to examine at each character:\n\ncount_arr &lt;- memoise::memoise(function(str, grps, grp_count) {\n\n  # Check for contradictions and/or the end of the input\n  if (length(grps) == 0)\n    return(if_else(grp_count == 0 & str_detect(str, \"^(\\\\.|\\\\?)*$\"), 1, 0))\n  else if (str == \"\")\n    return(0)\n  else if (grp_count &gt; grps[1]) \n    return(0)\n\n  # Initialize the total number of arrangements to 0 and get the current char\n  total_arr &lt;- 0\n  cur_chr   &lt;- str_sub(str, 1, 1)\n  \n  # If the char is unknown, examine both of the two possible states\n  if (cur_chr == \"?\")\n    cur_chr &lt;- c(\".\", \"#\")\n  \n  for (chr in cur_chr) {\n    \n    # If '#', recurse within the current group\n    if (chr == \"#\")\n      total_arr &lt;- total_arr + count_arr(str_sub(str, 2), grps, grp_count + 1)\n    \n    # If '.', close the current group (if one is active) & recurse\n    else if (chr == \".\") {\n      if (grp_count == 0)\n        total_arr &lt;- total_arr + count_arr(str_sub(str, 2), grps, grp_count)\n      else if (grp_count == grps[1])\n        total_arr &lt;- total_arr + count_arr(str_sub(str, 2), tail(grps, -1), 0)\n    }\n    \n  }\n  \n  total_arr\n})\n\nRun on puzzle input:\n\ndf |&gt; \n  pmap_dbl(\\(chr, num, ...) {\n    count_arr(str_c(str_c(rep(chr, 5), collapse = \"?\"), \".\"), rep(num, 5), 0)\n  }) |&gt; \n  sum() |&gt; \n  format(scientific = FALSE)\n\n[1] \"4443895258186\"",
    "crumbs": [
      "2023",
      "Day 12"
    ]
  },
  {
    "objectID": "2023/R/day07.html",
    "href": "2023/R/day07.html",
    "title": "Day 7",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day07.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 7"
    ]
  },
  {
    "objectID": "2023/R/day07.html#setup",
    "href": "2023/R/day07.html#setup",
    "title": "Day 7",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day07.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 7"
    ]
  },
  {
    "objectID": "2023/R/day07.html#part-1",
    "href": "2023/R/day07.html#part-1",
    "title": "Day 7",
    "section": "Part 1",
    "text": "Part 1\nParse text input as a bid and set of cards for each hand:\n\ncard_types &lt;- c(2:9, 'T', 'J', 'Q', 'K', 'A')\n\nhands &lt;- input |&gt; \n  unglue_data(\"{card1=.}{card2=.}{card3=.}{card4=.}{card5=.} {bid}\") |&gt; \n  transmute(\n    hand_id = row_number(),\n    bid = as.numeric(bid),\n    across(starts_with(\"card\"), partial(factor, levels = card_types)),\n    cards = pmap(list(card1, card2, card3, card4, card5), c)\n  )\n\nDefine a function to compute the type of each hand:\n\nhand_types &lt;- c(\"HIGH\", \"PAIR\", \"2PAIR\", \"3KIND\", \"FULL\", \"4KIND\", \"5KIND\")\n\nhand_type &lt;- function(cards) {\n  card_counts &lt;- sort(summary(cards), decreasing = TRUE)\n  case_when(\n    card_counts[1] == 3 & card_counts[2] == 2 ~ \"FULL\",\n    card_counts[1] == 2 & card_counts[2] == 2 ~ \"2PAIR\",\n    card_counts[1] == 5 ~ \"5KIND\",\n    card_counts[1] == 4 ~ \"4KIND\",\n    card_counts[1] == 3 ~ \"3KIND\",\n    card_counts[1] == 2 ~ \"PAIR\",\n    card_counts[1] == 1 ~ \"HIGH\"\n  )\n}\n\nDefine a function to determine the type of each hand, rank the results, and sum the total winnings:\n\nscore &lt;- function(df) {\n  df |&gt; \n    mutate(hand_type = factor(map_chr(cards, hand_type), levels = hand_types)) |&gt; \n    arrange(hand_type, card1, card2, card3, card4, card5) |&gt; \n    mutate(\n      rank = row_number(),\n      winnings = rank * bid\n    ) |&gt; \n    pull(winnings) |&gt; \n    sum()\n}\n\nRun on puzzle input:\n\nscore(hands)\n\n[1] 252295678",
    "crumbs": [
      "2023",
      "Day 7"
    ]
  },
  {
    "objectID": "2023/R/day07.html#part-2",
    "href": "2023/R/day07.html#part-2",
    "title": "Day 7",
    "section": "Part 2",
    "text": "Part 2\nRedefine the hand-scoring function to allow jokers to act as any card:\n\nhand_type &lt;- function(cards) {\n  \n  counts_joker &lt;- sum(cards == \"J\")\n  counts_other &lt;- cards |&gt; \n    discard(~ .x == \"J\") |&gt; \n    summary() |&gt; \n    sort(decreasing = TRUE)\n  \n  top_1 &lt;- counts_other[1] + counts_joker\n  top_2 &lt;- counts_other[2]\n  \n  case_when(\n    top_1 == 3 & top_2 == 2 ~ \"FULL\",\n    top_1 == 2 & top_2 == 2 ~ \"2PAIR\",\n    top_1 == 5 ~ \"5KIND\",\n    top_1 == 4 ~ \"4KIND\",\n    top_1 == 3 ~ \"3KIND\",\n    top_1 == 2 ~ \"PAIR\",\n    top_1 == 1 ~ \"HIGH\"\n  )\n}\n\nRe-rank the jokers to the bottom of the card heirarcy and re-score:\n\ncard_types &lt;- c(\"J\", discard(card_types, ~ .x == \"J\"))\n\nhands |&gt; \n  mutate(across(num_range(\"card\", 1:5), partial(factor, levels = card_types))) |&gt; \n  score()\n\n[1] 250577259",
    "crumbs": [
      "2023",
      "Day 7"
    ]
  },
  {
    "objectID": "2023/R/day05.html",
    "href": "2023/R/day05.html",
    "title": "Day 5",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sets)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day05.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 5"
    ]
  },
  {
    "objectID": "2023/R/day05.html#setup",
    "href": "2023/R/day05.html#setup",
    "title": "Day 5",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sets)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day05.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 5"
    ]
  },
  {
    "objectID": "2023/R/day05.html#part-1",
    "href": "2023/R/day05.html#part-1",
    "title": "Day 5",
    "section": "Part 1",
    "text": "Part 1\nParse input into sets of separate vector inputs and maps:\n\nseeds &lt;- head(input, 1) |&gt; \n  str_remove(\"seeds: \") |&gt; \n  str_split_1(\" \") |&gt; \n  as.numeric()\n\nmaps &lt;- tail(input, -2) |&gt; \n  enframe(name = NULL, value = \"txt\") |&gt; \n  mutate(\n    map_id = cumsum(txt == \"\"),\n    map_name = case_when(str_detect(txt, \":\") ~ txt)\n  ) |&gt; \n  fill(map_name, .direction = \"down\") |&gt; \n  unglue_unnest(map_name, \"{src_cat}-to-{dst_cat} map:\") |&gt; \n  filter(txt != \"\" & !str_detect(txt, \":\")) |&gt; \n  unglue_unnest(txt, \"{dst_start} {src_start} {range_len}\", convert = TRUE) |&gt; \n  mutate(\n    src_end = src_start + range_len - 1,\n    dst_end = dst_start + range_len - 1,\n    diff = dst_start - src_start\n  ) |&gt; \n  select(map_id, src_cat, dst_cat, src_start, src_end, dst_start, dst_end, diff) |&gt; \n  group_split(map_id, .keep = FALSE)\n\nConvert seed maps to interval notation:\n\n# Add rows for the interval complement (neg infinity to infinity) to each map\nmaps_interval &lt;- maps |&gt; \n  map(\\(df) {\n    complement &lt;- df |&gt; \n      pmap(\\(src_start, src_end, ...) {\n        interval(src_start, src_end, domain = 'Z')\n      }) |&gt; \n      interval_union() |&gt; \n      interval_complement() |&gt; \n      as.list() |&gt; \n      map_dfr(~ tibble(src_start = min(.x), src_end = max(.x))) |&gt; \n      mutate(\n        dst_start = src_start,\n        dst_end = src_end,\n        diff = 0\n      )\n    \n    df |&gt; \n      select(-ends_with(\"_cat\")) |&gt; \n      bind_rows(complement)\n  }) \n\n\n# Join each map to one another in sequence to create one overall src/dest map\nmain_map &lt;- maps_interval |&gt; \n  reduce(\n    ~ cross_join(.x, .y) |&gt; \n      mutate(\n        overlap_start = pmax(dst_start.x, src_start.y),\n        overlap_end   = pmin(dst_end.x,   src_end.y),\n        is_overlap    = overlap_start &lt;= overlap_end\n      ) |&gt; \n      filter(is_overlap) |&gt; \n      transmute(\n        src_start = overlap_start - diff.x,\n        src_end   = overlap_end   - diff.x,\n        dst_start = overlap_start + diff.y,\n        dst_end   = overlap_end   + diff.y,\n        diff      = diff.x + diff.y\n      )\n  )\n\nFind final location of all seeds, then take the minimum:\n\nmain_map |&gt; \n  cross_join(tibble(seed = seeds)) |&gt; \n  filter(seed &gt;= src_start & seed &lt;= src_end) |&gt; \n  mutate(loc = seed + diff) |&gt; \n  pull(loc) |&gt; \n  min()\n\n[1] 289863851",
    "crumbs": [
      "2023",
      "Day 5"
    ]
  },
  {
    "objectID": "2023/R/day05.html#part-2",
    "href": "2023/R/day05.html#part-2",
    "title": "Day 5",
    "section": "Part 2",
    "text": "Part 2\nConvert seed inputs to intervals:\n\nseeds_interval &lt;- tibble(seed = seeds) |&gt; \n  mutate(\n    type = case_match(\n      row_number() %% 2, \n      1 ~ \"seed_start\", \n      0 ~ \"range_len\"\n    ),\n    pair_id = ceiling(row_number() / 2)\n  ) |&gt; \n  pivot_wider(names_from = type, values_from = seed) |&gt; \n  transmute(seed_start, seed_end = seed_start + range_len - 1)\n\nJoin the seed intervals onto the mapper, filter to the overlap, and take the min result:\n\nmain_map |&gt; \n  cross_join(seeds_interval) |&gt; \n  mutate(\n    overlap_start = pmax(seed_start, src_start),\n    overlap_end   = pmin(seed_end,   src_end),\n    is_overlap    = overlap_start &lt;= overlap_end\n  ) |&gt; \n  filter(is_overlap) |&gt; \n  mutate(loc_start = overlap_start + diff) |&gt; \n  pull(loc_start) |&gt; \n  min()\n\n[1] 60568880",
    "crumbs": [
      "2023",
      "Day 5"
    ]
  },
  {
    "objectID": "2023/R/day10.html",
    "href": "2023/R/day10.html",
    "title": "Day 10",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day10.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 10"
    ]
  },
  {
    "objectID": "2023/R/day10.html#setup",
    "href": "2023/R/day10.html#setup",
    "title": "Day 10",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day10.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 10"
    ]
  },
  {
    "objectID": "2023/R/day10.html#part-1",
    "href": "2023/R/day10.html#part-1",
    "title": "Day 10",
    "section": "Part 1",
    "text": "Part 1\n\ndirs &lt;- list(\n  n = c(row = -1, col =  0),\n  s = c(row =  1, col =  0),\n  w = c(row =  0, col = -1),\n  e = c(row =  0, col =  1)\n)\n\npipes &lt;- list(\n  '|' = list(dirs$n, dirs$s),\n  '-' = list(dirs$w, dirs$e),\n  'L' = list(dirs$n, dirs$e),\n  'J' = list(dirs$n, dirs$w),\n  '7' = list(dirs$s, dirs$w),\n  'F' = list(dirs$s, dirs$e)\n)\n\nConvert text input into a graph:\n\n# Compute row and column of every tile in the input text\nmaze_src &lt;- input |&gt; \n  enframe(name = \"row\") |&gt; \n  mutate(value = str_split(value, \"\")) |&gt; \n  unnest_longer(value, indices_to = \"col\") |&gt; \n  transmute(\n    id = row_number(),\n    chr = value, \n    coords = map2(row, col, ~ c(row = .x, col = .y))\n  )\n\n# Save the index of the starting tile\nid_s &lt;- maze_src |&gt; \n  filter(chr == 'S') |&gt; \n  pull(id)\n\n# Create a copy of the maze for each possible 'S' pipe and compute their conns\nmazes &lt;- map(names(pipes), \\(pipe) {\n  maze_src |&gt; \n    mutate(\n      chr = replace(chr, id_s, pipe),\n      conn = map(chr, ~ pipes[[.x]])\n    ) |&gt; \n    unnest_longer(conn, indices_to = \"conn_num\") |&gt; \n    mutate(conn = map2(coords, conn, ~ .x + .y)) |&gt; \n    unnest_wider(coords) |&gt; \n    unnest_wider(conn, names_sep = \"_\")\n})\n\n# Turn each maze into an undirected graph\ng &lt;- mazes |&gt; \n  map(\\(maze) {\n    edge_list &lt;- maze |&gt; \n      left_join(\n        distinct(maze, conn_id = id, row, col), \n        join_by(x$conn_row == y$row, x$conn_col == y$col)\n      ) |&gt; \n      distinct(id, conn = conn_id) |&gt; \n      drop_na(conn) |&gt; \n      pmap(~ c(..1, ..2))\n    \n    intersect(edge_list, map(edge_list, rev)) |&gt; \n      keep(~ .x[[1]] &lt; .x[[2]]) |&gt; \n      unlist()\n  }) |&gt; \n  map(~ make_graph(as.integer(.x), directed = FALSE))\n\n\n# For each graph, check if there's a cycle containing the starting index\nhas_cycle_s &lt;- map_lgl(g, \\(graph) {\n  subgraphs &lt;- components(graph)$membership\n  sub_vtx &lt;- which(subgraphs == subgraphs[[id_s]])\n  \n  if (length(sub_vtx) &lt;= 2) \n    FALSE\n  else\n    graph |&gt; \n      subgraph(sub_vtx) |&gt; \n      has_eulerian_cycle()\n})\n\n# Keep only the graph that contain a cycle from the starting index\npipe_id_s &lt;- which(has_cycle_s)\nmaze_g &lt;- g[[pipe_id_s]]\n\nCompute the furthest distance on the loop from the starting point:\n\nmembership   &lt;- components(maze_g)$membership\nloop_members &lt;- which(membership == membership[[id_s]])\nloop_g       &lt;- subgraph(maze_g, loop_members)\n\nceiling(girth(loop_g)$girth / 2)\n\n[1] 6828",
    "crumbs": [
      "2023",
      "Day 10"
    ]
  },
  {
    "objectID": "2023/R/day10.html#part-2",
    "href": "2023/R/day10.html#part-2",
    "title": "Day 10",
    "section": "Part 2",
    "text": "Part 2\nHint from Reddit (link): To determine if a point is enclosed within a loop, check if a ray in any direction intersects the loop an even or odd number of times.\nFlag the tiles in the maze that make up the loop:\n\nmaze &lt;- maze_src |&gt; \n  mutate(chr = str_replace(chr, \"S\", names(pipes)[[pipe_id_s]])) |&gt; \n  unnest_wider(coords) |&gt; \n  mutate(in_loop = id %in% loop_members)\n\nSeparate the loop by rows and count the number of orthogonal loop tiles for each:\n\nmaze_loop &lt;- filter(maze, in_loop)\n\nloop_rows &lt;- maze_loop |&gt; \n  select(row, col, chr) |&gt; \n  arrange(row, col) |&gt; \n  mutate(\n    segment_num = cumsum(replace_na(col - lag(col), 1) &gt; 1) + 1,\n    .by = row\n  ) |&gt; \n  summarize(\n    col_min = min(col),\n    col_max = max(col),\n    chr = str_c(chr, collapse = \"\"),\n    .by = c(row, segment_num)\n  ) |&gt; \n  mutate(\n    num_crossings = chr |&gt; \n      str_replace_all(\"-\", \"\") |&gt; \n      str_replace_all(\"F7|LJ\", \"\") |&gt; \n      str_replace_all(\"FJ|L7\", \"|\") |&gt; \n      str_count(\"\\\\|\")\n  ) |&gt; \n  select(row, col_min, col_max, num_crossings)\n\nFor each non-loop member of the maze, count the number of times it intersects the loop.\n\n# Count all loop crossings to the left of each non-loop tile\nmaze |&gt; \n  filter(!in_loop) |&gt; \n  left_join(loop_rows, join_by(row, col &lt; col_min)) |&gt; \n  summarize(\n    num_crossings = sum(replace_na(num_crossings, 0)),\n    .by = c(id, row, col)\n  ) |&gt; \n  mutate(num_crossings = num_crossings %% 2) |&gt; \n  pull(num_crossings) |&gt; \n  sum()\n\n[1] 459",
    "crumbs": [
      "2023",
      "Day 10"
    ]
  },
  {
    "objectID": "2024/R/day21.html",
    "href": "2024/R/day21.html",
    "title": "Day 21",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day21.txt\")",
    "crumbs": [
      "2024",
      "Day 21"
    ]
  },
  {
    "objectID": "2024/R/day21.html#setup",
    "href": "2024/R/day21.html#setup",
    "title": "Day 21",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day21.txt\")",
    "crumbs": [
      "2024",
      "Day 21"
    ]
  },
  {
    "objectID": "2024/R/day21.html#part-1",
    "href": "2024/R/day21.html#part-1",
    "title": "Day 21",
    "section": "Part 1",
    "text": "Part 1\nDefine functions calculate minimum distances between keys on a keypad:\n\n# Helper function to convert pairs of adjacent keys to their directions\nkeypad_to_df &lt;- function(keys, rows, cols) {\n  df &lt;- tibble(key = keys, row = rows, col = cols)\n  \n  cross_join(df, df, suffix = c(\"_from\", \"_to\")) |&gt; \n    filter(abs(row_to - row_from) + abs(col_to - col_from) == 1) |&gt; \n    mutate(dir = case_when(\n      col_from &lt; col_to ~ \"&gt;\",\n      col_from &gt; col_to ~ \"&lt;\",\n      row_from &lt; row_to ~ \"^\",\n      row_from &gt; row_to ~ \"v\"\n    ))\n}\n\n# Convert a keypad (set of keys and their coordinates) to a graph\nkeypad_to_graph &lt;- function(keys, rows, cols) {\n  df &lt;- keypad_to_df(keys, rows, cols)\n  g &lt;- df |&gt; \n    transmute(from = key_from, to = key_to) |&gt; \n    graph_from_data_frame(vertices = keys)\n  f &lt;- function(from, to) {\n    df |&gt; \n    filter(key_from == from & key_to == to) |&gt; \n    pull(dir)\n  }\n  list(\"df\" = df, \"g\" = g, \"f\" = f)\n}\n\n# Return all shortests paths between two keys on a keypad\nkeypad_paths &lt;- function(keypad, key_from, key_to) {\n  all_shortest_paths(keypad$g, from = key_from, to = key_to)$vpaths |&gt; \n    map_chr(\\(x) {\n      dirs &lt;- map2_chr(\n        head(names(x), -1), \n        head(lead(names(x)), -1), \n        \\(dir_from, dir_to) keypad$f(dir_from, dir_to)\n      )\n      str_c(c(dirs, \"A\"), collapse = \"\")\n    })\n}\n\n# Define the numeric keypad\nkeys_num &lt;- c(\"A\", 0:9)\nrows_num &lt;- case_match(keys_num,\n  c(\"A\", \"0\")      ~ 1,\n  c(\"1\", \"2\", \"3\") ~ 2,\n  c(\"4\", \"5\", \"6\") ~ 3,\n  c(\"7\", \"8\", \"9\") ~ 4\n)\ncols_num &lt;- case_match(keys_num,\n  c(\"1\", \"4\", \"7\")      ~ 1,\n  c(\"0\", \"2\", \"5\", \"8\") ~ 2,\n  c(\"A\", \"3\", \"6\", \"9\") ~ 3\n)\nkeypad_num &lt;- keypad_to_graph(keys = keys_num, row = rows_num, col = cols_num)\n\n# Define the directional keypad\nkeys_dir &lt;- c(\"&lt;\", \"v\", \"&gt;\", \"^\", \"A\")\nrows_dir &lt;- case_match(keys_dir,\n  c(\"&lt;\", \"v\", \"&gt;\") ~ 1,\n  c(\"^\", \"A\")      ~ 2\n)\ncols_dir &lt;- case_match(keys_dir,\n  c(\"&lt;\")      ~ 1,\n  c(\"v\", \"^\") ~ 2,\n  c(\"&gt;\", \"A\") ~ 3\n)\nkeypad_dir &lt;- keypad_to_graph(keys = keys_dir, row = rows_dir, col = cols_dir)\n\n# Recursively compute the minimum user input for a given input string\nmin_path &lt;- function(input_str, level = 0, max_level = 3) {\n  if (level == max_level)\n    return(str_length(input_str))\n  \n  keypad &lt;- if (level == 0) keypad_num else keypad_dir\n  \n  input_to &lt;- str_split_1(input_str, \"\")\n  input_from &lt;- lag(input_to, default = \"A\")\n  steps &lt;- map2_int(\n    input_from, \n    input_to, \n    \\(from, to) keypad_paths(keypad, from, to) |&gt; \n      map_int(min_path, level = level + 1, max_level = max_level) |&gt; \n      min()\n  )\n  sum(steps)\n}\n\nRun on puzzle input:\n\ntibble(input) |&gt; \n  mutate(\n    numeric_code = parse_number(input),\n    shortest_seq = map_int(input, min_path),\n    complexity = numeric_code * shortest_seq\n  ) |&gt; \n  pull(complexity) |&gt; \n  sum()\n\n[1] 157908",
    "crumbs": [
      "2024",
      "Day 21"
    ]
  },
  {
    "objectID": "2024/R/day21.html#part-2",
    "href": "2024/R/day21.html#part-2",
    "title": "Day 21",
    "section": "Part 2",
    "text": "Part 2\nModify the min_path function to condense all inputs wherever possible so needless computation isn’t repeated:\n\nmin_path &lt;- function(input_str, level = 0, max_level = 3) {\n  if (level == max_level)\n    return(str_length(input_str))\n  \n  keypad &lt;- if (level == 0) keypad_num else keypad_dir\n  \n  df &lt;- tibble(str = input_str) |&gt; \n    mutate(\n      id = row_number(),\n      key = map(str, ~ tibble(\n        input_to = str_split_1(.x, \"\"),\n        input_from = lag(input_to, default = \"A\")\n      ))\n    ) |&gt; \n      unnest(key)\n\n  steps &lt;- df |&gt; \n    distinct(input_from, input_to) |&gt; \n    mutate(paths = map2(input_from, input_to, ~ keypad_paths(keypad, .x, .y))) |&gt; \n    unnest(paths) |&gt; \n    mutate(len = min_path(paths, level = level + 1, max_level = max_level)) |&gt; \n    slice_min(len, by = c(input_from, input_to), with_ties = FALSE)\n  \n  df |&gt; \n    left_join(steps, join_by(input_from, input_to)) |&gt; \n    summarize(steps = sum(len), .by = c(id, str)) |&gt; \n    pull(steps)\n}\n\nRe-run puzzle input with a max level of 26:\n\ntibble(input) |&gt; \n  mutate(\n    numeric_code = parse_number(input),\n    shortest_seq = map_dbl(input, min_path, max_level = 26),\n    complexity = numeric_code * shortest_seq\n  ) |&gt; \n  pull(complexity) |&gt; \n  sum() |&gt; \n  format(scientific = FALSE)\n\n[1] \"196910339808654\"",
    "crumbs": [
      "2024",
      "Day 21"
    ]
  },
  {
    "objectID": "2024/R/day08.html",
    "href": "2024/R/day08.html",
    "title": "Day 8",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day08.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2024",
      "Day 8"
    ]
  },
  {
    "objectID": "2024/R/day08.html#setup",
    "href": "2024/R/day08.html#setup",
    "title": "Day 8",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day08.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2024",
      "Day 8"
    ]
  },
  {
    "objectID": "2024/R/day08.html#part-1",
    "href": "2024/R/day08.html#part-1",
    "title": "Day 8",
    "section": "Part 1",
    "text": "Part 1\nDefine antinode functions:\n\n# Check if a coordinate is in the bounds of the map\nin_bounds &lt;- function(x, map) {\n  between(x[1], 1, nrow(map)) & between(x[2], 1, ncol(map))\n}\n\n# Compute the antinodes of a given pair of antennas\nantinode_pair &lt;- function(x1, x2, map) {\n  diff &lt;- x2 - x1\n  list(x1 - diff, x2 + diff) |&gt; \n    keep(~in_bounds(.x, map))\n}\n\n# Get coordinates of every antenna of the given frequency\nget_freq_antennas &lt;- function(freq, map) {\n  antennas &lt;- which(map == freq, arr.ind = TRUE)\n  split(antennas, row(antennas))\n}\n\n# Compute all antinodes of a given frequency in a given map\nget_all_antinodes &lt;- function(freq, map, f) {\n  antennas &lt;- get_freq_antennas(freq, map)\n  \n  pairs &lt;- combn(antennas, 2)\n  pairs &lt;- split(pairs, col(pairs))\n  \n  pairs |&gt; \n    map(~f(.x[[1]], .x[[2]], map)) |&gt; \n    list_flatten() |&gt; \n    unique()\n}\n\nRun antinode functions on puzzle input:\n\n# Convert input to matrix format\nmtx &lt;- input |&gt;\n  str_split(\"\") |&gt; \n  unlist() |&gt; \n  matrix(nrow = length(input), byrow = TRUE)\n\n# Find the distinct set of frequencies in the map\nfreqs &lt;- keep(\n  unique(as.vector(mtx)), \n  ~.x %in% c(letters, LETTERS, as.character(0:9))\n)\n\n# Count all distinct antinode locations across all frequencies in the map\nfreqs |&gt; \n  map(~get_all_antinodes(.x, mtx, antinode_pair)) |&gt; \n  list_flatten() |&gt; \n  unique() |&gt; \n  length()\n\n[1] 369",
    "crumbs": [
      "2024",
      "Day 8"
    ]
  },
  {
    "objectID": "2024/R/day08.html#part-2",
    "href": "2024/R/day08.html#part-2",
    "title": "Day 8",
    "section": "Part 2",
    "text": "Part 2\nUpdate the antinode function:\n\n# Compute the updated antinodes of a given pair of antennas\nantinode_set &lt;- function(x1, x2, map) {\n  diff &lt;- x2 - x1\n  antinodes &lt;- list(x1, x2)\n  \n  i &lt;- 1\n  while(in_bounds(x2 + i * diff, map)) {\n    antinodes &lt;- c(antinodes, list(as.integer(x2 + i * diff)))\n    i &lt;- i + 1\n  }\n\n  i &lt;- 1\n  while(in_bounds(x1 - i * diff, map)) {\n    antinodes &lt;- c(antinodes, list(as.integer(x1 - i * diff)))\n    i &lt;- i + 1\n  }\n  \n  antinodes\n}\n\nRe-run puzzle input:\n\nfreqs |&gt; \n  map(~get_all_antinodes(.x, mtx, antinode_set)) |&gt; \n  list_flatten() |&gt; \n  unique() |&gt; \n  length()\n\n[1] 1169",
    "crumbs": [
      "2024",
      "Day 8"
    ]
  },
  {
    "objectID": "2024/R/day23.html",
    "href": "2024/R/day23.html",
    "title": "Day 23",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day23.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\"{v1}-{v2}\")",
    "crumbs": [
      "2024",
      "Day 23"
    ]
  },
  {
    "objectID": "2024/R/day23.html#setup",
    "href": "2024/R/day23.html#setup",
    "title": "Day 23",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day23.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\"{v1}-{v2}\")",
    "crumbs": [
      "2024",
      "Day 23"
    ]
  },
  {
    "objectID": "2024/R/day23.html#part-1",
    "href": "2024/R/day23.html#part-1",
    "title": "Day 23",
    "section": "Part 1",
    "text": "Part 1\n\n# Convert list of connections to an undirected graph\ng &lt;- input |&gt; \n  pmap(function(v1, v2) c(v1, v2)) |&gt; \n  unlist() |&gt; \n  make_graph(directed = FALSE)\n\n# Find all sets of 3 connected vertices\ncliques(g, min = 3, max = 3) |&gt; \n  \n  # Keep only the sets having some vertex starting with 't'\n  keep(\n    ~ names(.x) |&gt; \n      str_starts(\"t\") |&gt; \n      any()\n  ) |&gt; \n  \n  # Count the number of resulting sets\n  length()\n\n[1] 1423",
    "crumbs": [
      "2024",
      "Day 23"
    ]
  },
  {
    "objectID": "2024/R/day23.html#part-2",
    "href": "2024/R/day23.html#part-2",
    "title": "Day 23",
    "section": "Part 2",
    "text": "Part 2\n\ng |&gt; \n  \n  # Find the largest interconnected set of vertices\n  largest_cliques() |&gt; \n  unlist() |&gt; \n\n  # Convert the list of vertices into the \"password\" by sorting alphabetically\n  names() |&gt; \n  sort() |&gt; \n  str_c(collapse = \",\")\n\n[1] \"gt,ha,ir,jn,jq,kb,lr,lt,nl,oj,pp,qh,vy\"",
    "crumbs": [
      "2024",
      "Day 23"
    ]
  },
  {
    "objectID": "2024/R/day18.html",
    "href": "2024/R/day18.html",
    "title": "Day 18",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day18.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(patterns = \"{col},{row}\", convert = TRUE) |&gt; \n  mutate(byte_num = row_number())\n\nmaxdim &lt;- 70",
    "crumbs": [
      "2024",
      "Day 18"
    ]
  },
  {
    "objectID": "2024/R/day18.html#setup",
    "href": "2024/R/day18.html#setup",
    "title": "Day 18",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day18.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(patterns = \"{col},{row}\", convert = TRUE) |&gt; \n  mutate(byte_num = row_number())\n\nmaxdim &lt;- 70",
    "crumbs": [
      "2024",
      "Day 18"
    ]
  },
  {
    "objectID": "2024/R/day18.html#part-1",
    "href": "2024/R/day18.html#part-1",
    "title": "Day 18",
    "section": "Part 1",
    "text": "Part 1\n\n# Fill out the full grid with the provided dimensions\ngrid &lt;- input |&gt; \n  complete(col = 0:maxdim, row = 0:maxdim) |&gt; \n  mutate(id = row_number(), .before = everything()) |&gt; \n  \n  # Define the graph edges (cell borders) between vertices (cells)\n  mutate(edge_w = map2(id, lag(id), ~ c(.x, .y)), .by = row) |&gt; \n  mutate(edge_n = map2(id, lag(id), ~ c(.x, .y)), .by = col)\n\n# Define the IDs of the start and end vertices\nstart &lt;- grid |&gt; filter(row == 0 & col == 0) |&gt; pull(id)\nexit  &lt;- grid |&gt; filter(row == maxdim & col == maxdim) |&gt; pull(id)\n\nConvert the grid to a graph and count the steps from the start to the exit:\n\ncompute_num_steps &lt;- function(grid, start, exit, num_bytes) {\n\n  grid |&gt; \n    \n    # Flag and remove any graph edges between corrupted cells\n    mutate(corrupted = replace_na(byte_num &lt;= num_bytes, FALSE)) |&gt; \n    mutate(edge_w = case_when(!corrupted & !lag(corrupted) ~ edge_w), .by = row) |&gt; \n    mutate(edge_n = case_when(!corrupted & !lag(corrupted) ~ edge_n), .by = col) |&gt; \n    \n    # Pull graph edges\n    select(edge_w, edge_n) |&gt; \n    pivot_longer(everything()) |&gt; \n    pull(value) |&gt; \n    discard(is.null) |&gt; \n    unlist() |&gt; \n    \n    # Convert to a graph\n    make_graph(n = max(grid$id), directed = FALSE) |&gt; \n    \n    # Count the steps from the start to the exit\n    distances(start, exit) |&gt; \n    as.list() |&gt; \n    unlist()\n  \n}\n\nRun puzzle input:\n\ncompute_num_steps(grid, start, exit, 1024)\n\n[1] 340",
    "crumbs": [
      "2024",
      "Day 18"
    ]
  },
  {
    "objectID": "2024/R/day18.html#part-2",
    "href": "2024/R/day18.html#part-2",
    "title": "Day 18",
    "section": "Part 2",
    "text": "Part 2\nLoop through different byte values to find the first byte that blocks the path:\n\n# Initialize byte counts\nmax_bytes &lt;- max(grid$byte_num, na.rm = TRUE)\nmax_walkable &lt;- 1024\nmin_unwalkable &lt;- max_bytes\nnum_bytes &lt;- round(mean(c(max_walkable, min_unwalkable)))\n\n# Loop through bytes, a half at a time\nwhile (min_unwalkable - max_walkable &gt; 1) {\n  \n  num_steps &lt;- compute_num_steps(grid, start, exit, num_bytes)\n  \n  if (is.infinite(num_steps))\n    min_unwalkable &lt;- num_bytes\n  else \n    max_walkable &lt;- num_bytes\n    \n  num_bytes &lt;- round(mean(c(max_walkable, min_unwalkable)))\n}\n\nGet the coordinates of the first byte that blocks the path:\n\ngrid |&gt; \n  filter(byte_num == min_unwalkable) |&gt; \n  mutate(coord = str_c(col, row, sep = \",\")) |&gt; \n  pull(coord)\n\n[1] \"34,32\"",
    "crumbs": [
      "2024",
      "Day 18"
    ]
  },
  {
    "objectID": "2024/R/day25.html",
    "href": "2024/R/day25.html",
    "title": "Day 25",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day25.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2024",
      "Day 25"
    ]
  },
  {
    "objectID": "2024/R/day25.html#setup",
    "href": "2024/R/day25.html#setup",
    "title": "Day 25",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day25.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2024",
      "Day 25"
    ]
  },
  {
    "objectID": "2024/R/day25.html#part-1",
    "href": "2024/R/day25.html#part-1",
    "title": "Day 25",
    "section": "Part 1",
    "text": "Part 1\nConvert input to lists of keys and locks by height:\n\ngroups &lt;- input |&gt; \n  enframe(name = NULL) |&gt; \n  mutate(group_id = cumsum(value == \"\"), .before = everything()) |&gt; \n  filter(value != \"\") |&gt; \n  mutate(\n    col = str_split(value, \"\"),\n    row = row_number(),\n    .by = group_id\n  ) |&gt; \n  mutate(\n    type = case_when(row == 1 ~ if_else(str_detect(value, \"#\"), \"lock\", \"key\"))\n  ) |&gt; \n  fill(type, .direction = \"down\") |&gt; \n  unnest_wider(col, names_sep = \"\") |&gt; \n  mutate(group_id = str_c(type, \"_\", group_id)) |&gt; \n  select(-c(value, row, type, row)) |&gt; \n  group_split(group_id)\n\ngroups &lt;- set_names(\n  groups,\n  map_chr(groups, ~ unique(pull(.x, group_id)))\n)\n\nTranspose data frames and count pin heights of each column:\n\npins &lt;- groups |&gt; \n  map(\n    ~ .x |&gt; \n      select(-group_id) |&gt; \n      as.matrix() |&gt; \n      t() |&gt; \n      as_tibble() |&gt; \n      transmute(height = rowSums(across(everything(), ~ .x == \"#\")) - 1) |&gt; \n      pull(height)\n  )\n\nlocks &lt;- keep_at(pins, ~ str_starts(.x, \"lock\"))\nkeys  &lt;- keep_at(pins, ~ str_starts(.x, \"key\"))\n\nCompute maximum height for any given lock/key combo:\n\nmax_height &lt;- nrow(groups[[1]]) - 2\n\nCross all locks with all keys and check for overlapping pins:\n\nexpand_grid(lock = locks, key = keys) |&gt; \n  mutate(fits = map2_lgl(lock, key, ~ max(.x + .y) &lt;= max_height)) |&gt; \n  pull(fits) |&gt; \n  sum()\n\n[1] 3495",
    "crumbs": [
      "2024",
      "Day 25"
    ]
  },
  {
    "objectID": "2024/R/day01.html",
    "href": "2024/R/day01.html",
    "title": "Day 1",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_table(\n  \"../input/day01.txt\", \n  col_names = c(\"x\", \"y\"), \n  show_col_types = FALSE\n)",
    "crumbs": [
      "2024",
      "Day 1"
    ]
  },
  {
    "objectID": "2024/R/day01.html#setup",
    "href": "2024/R/day01.html#setup",
    "title": "Day 1",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_table(\n  \"../input/day01.txt\", \n  col_names = c(\"x\", \"y\"), \n  show_col_types = FALSE\n)",
    "crumbs": [
      "2024",
      "Day 1"
    ]
  },
  {
    "objectID": "2024/R/day01.html#part-1",
    "href": "2024/R/day01.html#part-1",
    "title": "Day 1",
    "section": "Part 1",
    "text": "Part 1\nSort each list independently, then sum the distances between each pair of ordered items.\n\ntibble(\n  x = sort(input$x), \n  y = sort(input$y),\n  dist = abs(y - x)\n) |&gt; \n  summarize(total = sum(dist)) |&gt; \n  pull()\n\n[1] 2285373",
    "crumbs": [
      "2024",
      "Day 1"
    ]
  },
  {
    "objectID": "2024/R/day01.html#part-2",
    "href": "2024/R/day01.html#part-2",
    "title": "Day 1",
    "section": "Part 2",
    "text": "Part 2\nFor each item in list x, multiply its value by its number of occurrences in list y, then sum the total.\n\ninput |&gt; \n  mutate(\n    x_match_count = map_int(x, ~ sum(.x == y)),\n    similarity_score = x * x_match_count\n  ) |&gt; \n  summarize(total = sum(similarity_score)) |&gt; \n  pull()\n\n[1] 21142653",
    "crumbs": [
      "2024",
      "Day 1"
    ]
  },
  {
    "objectID": "2024/R/day03.html",
    "href": "2024/R/day03.html",
    "title": "Day 3",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day03.txt\") |&gt; \n  str_c(collapse = \"\")",
    "crumbs": [
      "2024",
      "Day 3"
    ]
  },
  {
    "objectID": "2024/R/day03.html#setup",
    "href": "2024/R/day03.html#setup",
    "title": "Day 3",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day03.txt\") |&gt; \n  str_c(collapse = \"\")",
    "crumbs": [
      "2024",
      "Day 3"
    ]
  },
  {
    "objectID": "2024/R/day03.html#part-1",
    "href": "2024/R/day03.html#part-1",
    "title": "Day 3",
    "section": "Part 1",
    "text": "Part 1\n\nuncorrupt &lt;- function(str) {\n  \n  str |&gt; \n    \n    # Extract all text of the format `mul(a,b)` where a, b are valid integers\n    str_extract_all(\"mul\\\\(\\\\d+,\\\\d+\\\\)\") |&gt; \n    unlist() |&gt; \n    \n    # Extract both integers from the mul sequences and multiply them together\n    str_extract_all(\"\\\\d+\") |&gt; \n    map(parse_number) |&gt; \n    map(reduce, prod) |&gt; \n    \n    # Sum up the total of all results\n    reduce(sum)\n  \n}\n\nuncorrupt(input)\n\n[1] 178538786",
    "crumbs": [
      "2024",
      "Day 3"
    ]
  },
  {
    "objectID": "2024/R/day03.html#part-2",
    "href": "2024/R/day03.html#part-2",
    "title": "Day 3",
    "section": "Part 2",
    "text": "Part 2\n\n# Remove all text between `don't()` and `do()`, then uncorrupt the result\ninput |&gt; \n  str_remove_all(\"don't\\\\(\\\\).*?do\\\\(\\\\)\") |&gt;   \n  uncorrupt()\n\n[1] 102467299",
    "crumbs": [
      "2024",
      "Day 3"
    ]
  },
  {
    "objectID": "2024/R/day16.html",
    "href": "2024/R/day16.html",
    "title": "Day 16",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2024",
      "Day 16"
    ]
  },
  {
    "objectID": "2024/R/day16.html#setup",
    "href": "2024/R/day16.html#setup",
    "title": "Day 16",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2024",
      "Day 16"
    ]
  },
  {
    "objectID": "2024/R/day16.html#part-1",
    "href": "2024/R/day16.html#part-1",
    "title": "Day 16",
    "section": "Part 1",
    "text": "Part 1\nConvert text input into a weighted, undirected graph\n\n# Convert input to a data frame\ndf &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  unlist() |&gt; \n  as_tibble_col(column_name = \"cell\") |&gt; \n  mutate(\n    input_id  = row_number() - 1,\n    row = floor(input_id / length(input)),\n    col = floor(input_id %% length(input))\n  )\n\n# Convert borders between grid cells to graph vertices and map edges by cell\nborders &lt;- df |&gt; \n  mutate(border_e = (cell != \"#\" & lead(cell) != \"#\"), .by = row) |&gt; \n  mutate(border_s = (cell != \"#\" & lead(cell) != \"#\"), .by = col) |&gt; \n  mutate(\n    vtx_id_e = case_when(border_e ~ cumsum(border_e)),\n    vtx_id_s = case_when(border_s ~ cumsum(border_s) + max(vtx_id_e, na.rm = T))\n  ) |&gt; \n  mutate(vtx_id_n = lag(vtx_id_s), .by = col) |&gt; \n  mutate(vtx_id_w = lag(vtx_id_e), .by = row) |&gt; \n  mutate(\n    conn_ns = map2(vtx_id_n, vtx_id_s, ~ na.omit(c(.x, .y))),\n    conn_ew = map2(vtx_id_e, vtx_id_w, ~ na.omit(c(.x, .y))),\n    conn_ne = map2(vtx_id_n, vtx_id_e, ~ na.omit(c(.x, .y))),\n    conn_nw = map2(vtx_id_n, vtx_id_w, ~ na.omit(c(.x, .y))),\n    conn_se = map2(vtx_id_s, vtx_id_e, ~ na.omit(c(.x, .y))),\n    conn_sw = map2(vtx_id_s, vtx_id_w, ~ na.omit(c(.x, .y))),\n  )\n\n# Extract the list of all vertices\nvertices &lt;- c(borders$vtx_id_e, borders$vtx_id_s) |&gt; \n  na.omit() |&gt; \n  sort()\n\n# Convert vertices and edges to an adjacency matrix\nmtx &lt;- borders |&gt; \n  # Unnest lists of edge connections between vertices\n  select(starts_with(\"conn\")) |&gt; \n  pivot_longer(everything(), names_to = \"conn\", names_prefix = \"conn_\") |&gt; \n  unnest_wider(value, names_sep = \"_\") |&gt; \n  drop_na(value_1, value_2) |&gt; \n  # Rotations get an extra 1k added to the weight\n  mutate(weight = case_match(conn, c(\"ns\", \"ew\") ~ 1, .default = 1001)) |&gt; \n  select(-conn) |&gt; \n  # Convert to matrix format, where unconnected vertices have weight 0\n  complete(value_1 = vertices, value_2 = vertices, fill = list(weight = 0)) |&gt; \n  arrange(value_1, value_2) |&gt; \n  pivot_wider(names_from = value_2, values_from = weight) |&gt; \n  column_to_rownames(var = \"value_1\") |&gt; \n  as.matrix()\n\n# Make matrix symmetric (for an undirected graph)\nsym_mtx &lt;- pmax(mtx, t(mtx))\n\n# Convert adjacency matrix to a graph\ng &lt;- graph_from_adjacency_matrix(sym_mtx, mode = \"undirected\", weighted = TRUE)\n\nDetermine possible starting and ending locations from the input\n\nspecial_cells &lt;- borders |&gt; \n  filter(cell %in% c(\"S\", \"E\")) |&gt; \n  select(cell, starts_with(\"vtx_id\")) |&gt; \n  pivot_longer(\n    starts_with(\"vtx_id\"), \n    names_prefix = \"vtx_id_\",\n    names_to = \"dir\",\n    values_to = \"vertex\"\n  ) |&gt; \n  drop_na(vertex)\n\n# Create all combinations of start & end cell borders\ncombos &lt;- special_cells |&gt; \n  filter(cell == \"S\") |&gt; \n  mutate(\n    init_rotation = case_match(dir, \"e\" ~ 0, c(\"n\", \"s\") ~ 1, \"w\" ~ 2) * 1000\n  ) |&gt;\n  select(start_vertex = vertex, init_rotation) |&gt; \n  cross_join(\n    special_cells |&gt; \n      filter(cell == \"E\") |&gt; \n      select(end_vertex = vertex)\n  )\n\nFind the minimum path distance for each start/end vertex combo:\n\nmin_dist &lt;- combos |&gt; \n  mutate(\n    dist = map2_int(\n      start_vertex, \n      end_vertex, \n      ~ distances(g, .x, .y)) + init_rotation + 1\n  ) |&gt; \n  slice_min(dist)\n\nmin_dist |&gt; \n  pull(dist)\n\n[1] 102504",
    "crumbs": [
      "2024",
      "Day 16"
    ]
  },
  {
    "objectID": "2024/R/day16.html#part-2",
    "href": "2024/R/day16.html#part-2",
    "title": "Day 16",
    "section": "Part 2",
    "text": "Part 2\nPull all paths that have the minimum distance from start to end:\n\nshortest_paths &lt;- min_dist |&gt; \n  pmap(function(start_vertex, init_rotation, end_vertex, ...) {\n    all_shortest_paths(g, start_vertex, end_vertex)$vpaths\n  }) |&gt; \n  flatten() |&gt; \n  map(as.integer)\n\n\npath_vertices &lt;- shortest_paths |&gt; \n  unlist() |&gt; \n  unique() |&gt; \n  sort()\n\nCount all non-wall cells with a border in the shortest path vertex list:\n\nborders |&gt; \n  select(cell, input_id, starts_with(\"vtx_id\")) |&gt; \n  pivot_longer(starts_with(\"vtx_id\")) |&gt; \n  drop_na(value) |&gt; \n  filter(map_lgl(value, ~ .x %in% path_vertices)) |&gt; \n  filter(cell != \"#\") |&gt; \n  distinct(input_id) |&gt; \n  nrow()\n\n[1] 535",
    "crumbs": [
      "2024",
      "Day 16"
    ]
  },
  {
    "objectID": "2024/R/day06.html",
    "href": "2024/R/day06.html",
    "title": "Day 6",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day06.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2024",
      "Day 6"
    ]
  },
  {
    "objectID": "2024/R/day06.html#setup",
    "href": "2024/R/day06.html#setup",
    "title": "Day 6",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day06.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2024",
      "Day 6"
    ]
  },
  {
    "objectID": "2024/R/day06.html#part-1",
    "href": "2024/R/day06.html#part-1",
    "title": "Day 6",
    "section": "Part 1",
    "text": "Part 1\n\n# Guard functions --------------------------------------------------------------\nguards &lt;- c(\"^\", \"&gt;\", \"v\", \"&lt;\")\nguard_shift &lt;- c(tail(guards, -1), head(guards, 1))\n\nrotate_guard &lt;- function(cur) guard_shift[guards == cur]\n\nguard_dir &lt;- function(char) {\n  case_match(char,\n    \"^\" ~ matrix(c(-1,  0), nrow = 1),\n    \"&gt;\" ~ matrix(c( 0,  1), nrow = 1),\n    \"v\" ~ matrix(c( 1,  0), nrow = 1),\n    \"&lt;\" ~ matrix(c( 0, -1), nrow = 1)\n  )\n}\n\nin_bounds &lt;- function(coord, mtx) {\n  between(coord[1], 1, nrow(mtx)) & between(coord[2], 1, ncol(mtx))\n}\n\nmap_path &lt;- function(mtx) {\n\n  # Initiate guard's starting position and direction\n  cur_char  &lt;- keep(mtx, ~ .x %in% guards)\n  cur_coord &lt;- which(mtx == cur_char, arr.ind = TRUE)\n  cur_dir   &lt;- guard_dir(cur_char)\n  \n  # As long as the guard is in bounds, iteratively update its coords and direction\n  repeat {\n    next_coord &lt;- cur_coord + cur_dir\n    \n    # If next step is out-of-bounds, update matrix and exit\n    if (!in_bounds(next_coord, mtx)) {\n      mtx[cur_coord] &lt;- \"X\"\n      break\n    }\n    # If next step is an obstacle, rotate the guard\n    else if (mtx[next_coord] == '#') {\n      cur_char &lt;- rotate_guard(cur_char)\n      cur_dir  &lt;- guard_dir(cur_char)\n    }\n    # Otherwise advance the guard forward\n    else {\n      mtx[cur_coord] &lt;- \"X\"\n      cur_coord &lt;- next_coord\n    }\n  }\n  \n  mtx\n}\n\n\n# Convert input into a matrix\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  unlist() |&gt; \n  matrix(nrow = length(input), byrow = TRUE)\n\n# Map the guard's path\nguard_path &lt;- map_path(mtx)\n\n# Count distinct positions visited\nsum(guard_path == \"X\")",
    "crumbs": [
      "2024",
      "Day 6"
    ]
  },
  {
    "objectID": "2024/R/day06.html#part-2",
    "href": "2024/R/day06.html#part-2",
    "title": "Day 6",
    "section": "Part 2",
    "text": "Part 2\nChange the path mapping function to test for loops\n\npath_loops &lt;- function(mtx) {\n\n  # Initiate guard's starting position and direction\n  cur_char  &lt;- keep(mtx, ~ .x %in% guards)\n  cur_coord &lt;- which(mtx == cur_char, arr.ind = TRUE)\n  cur_dir   &lt;- guard_dir(cur_char)\n  path_hist &lt;- matrix(\"\", nrow(mtx), ncol(mtx))\n\n  # As long as the guard is in bounds, iteratively update its coords and direction\n  repeat {\n    next_coord &lt;- cur_coord + cur_dir\n    \n    # Check if the guard is looping or if they have left the area\n    if (str_detect(path_hist[cur_coord], fixed(cur_char))) \n      return(TRUE)\n    else if (!in_bounds(next_coord, mtx)) \n      return(FALSE)\n    \n    # If next step is an obstacle, rotate the guard\n    else if (mtx[next_coord] == '#') {\n      # Update path history\n      path_hist[cur_coord] &lt;- str_c(path_hist[cur_coord], cur_char)\n      # Update guard\n      cur_char &lt;- rotate_guard(cur_char)\n      cur_dir  &lt;- guard_dir(cur_char)\n    }\n    # Otherwise advance the guard forward\n    else {\n      # Update path history\n      path_hist[cur_coord] &lt;- str_c(path_hist[cur_coord], cur_char)\n      # Update guard\n      cur_coord &lt;- next_coord\n    }\n  }\n}\n\n\n# Create a variation of the map for each possible obstacle location\nobstacles &lt;- which(guard_path == \"X\" & !(mtx %in% guards))\n\n# Test each obstacle location for loops and sum result\nobstacles |&gt; \n  map(~ replace(mtx, .x, \"#\")) |&gt; \n  map_lgl(path_loops) |&gt; \n  sum()",
    "crumbs": [
      "2024",
      "Day 6"
    ]
  },
  {
    "objectID": "2024/R/day13.html",
    "href": "2024/R/day13.html",
    "title": "Day 13",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day13.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2024",
      "Day 13"
    ]
  },
  {
    "objectID": "2024/R/day13.html#setup",
    "href": "2024/R/day13.html#setup",
    "title": "Day 13",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day13.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2024",
      "Day 13"
    ]
  },
  {
    "objectID": "2024/R/day13.html#part-1",
    "href": "2024/R/day13.html#part-1",
    "title": "Day 13",
    "section": "Part 1",
    "text": "Part 1\nExtract numerical values from input text:\n\ndf &lt;- input |&gt; \n  unglue_data(c(\n    \"Button {button}: X+{x=\\\\d+}, Y+{y=\\\\d+}\",\n    \"{button}: X={x=\\\\d+}, Y={y=\\\\d+}\"\n  )) |&gt; \n  mutate(\n    machine_id = floor((row_number() - 1) / 3),\n    across(c(x, y), parse_number),\n    .before = everything()\n  ) |&gt; \n  pivot_wider(names_from = button, values_from = c(x, y))\n\nDefine a function to convert numeric equation input and output token counts:\n\ncompute_tokens &lt;- function(df) {\n  \n  # Convert each machine's properties into a system of equations and solve.\n  soln &lt;- df |&gt; \n    nest(coeff = c(x_A, x_B, y_A, y_B)) |&gt; \n    nest(intercept = c(x_Prize, y_Prize)) |&gt; \n    mutate(\n      coeff = map(coeff, ~ matrix(as.numeric(.x), nrow = 2, byrow = TRUE)),\n      intercept = map(intercept, as.numeric),\n      soln = map2(\n        coeff, \n        intercept, \n        ~ solve(.x, .y) |&gt; \n          set_names(\"A\", \"B\") |&gt; \n          as_tibble_row()\n      )\n    ) |&gt; \n    unnest(soln) |&gt; \n    select(machine_id, A, B)\n  \n  \n  # Check that the solution is two whole numbers, then sum the token cost\n  soln |&gt; \n    mutate(\n      across(\n        c(A, B), \n        ~ near(.x, abs(round(.x)), tol = 0.001), \n        .names = \"{.col}_valid\"\n      ),\n      win = A_valid & B_valid,\n      tokens = if_else(win, 3 * A + B, 0)\n    ) |&gt; \n    pull(tokens) |&gt; \n    sum()\n}\n\nRun function on puzzle input:\n\ncompute_tokens(df)\n\n[1] 31623",
    "crumbs": [
      "2024",
      "Day 13"
    ]
  },
  {
    "objectID": "2024/R/day13.html#part-2",
    "href": "2024/R/day13.html#part-2",
    "title": "Day 13",
    "section": "Part 2",
    "text": "Part 2\nAdd 10000000000000 to each prize intercept and re-compute:\n\ndf |&gt; \n  mutate(across(c(x_Prize, y_Prize), ~ .x + 10000000000000)) |&gt; \n  compute_tokens() |&gt; \n  format(scientific = FALSE)\n\n[1] \"93209116744825\"",
    "crumbs": [
      "2024",
      "Day 13"
    ]
  },
  {
    "objectID": "2024/R/day11.html",
    "href": "2024/R/day11.html",
    "title": "Day 11",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day11.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split_1(\" \") |&gt; \n  as.integer()",
    "crumbs": [
      "2024",
      "Day 11"
    ]
  },
  {
    "objectID": "2024/R/day11.html#setup",
    "href": "2024/R/day11.html#setup",
    "title": "Day 11",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day11.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split_1(\" \") |&gt; \n  as.integer()",
    "crumbs": [
      "2024",
      "Day 11"
    ]
  },
  {
    "objectID": "2024/R/day11.html#part-1",
    "href": "2024/R/day11.html#part-1",
    "title": "Day 11",
    "section": "Part 1",
    "text": "Part 1\nCreate blink functions:\n\nblink &lt;- function(x) {\n  char &lt;- format(x, scientific = FALSE)\n  n &lt;- str_length(char)\n  \n  if (x == 0) \n    1\n  else if (n %% 2 == 0)\n    parse_number(c(\n      str_sub(char, 1, n / 2),\n      str_sub(char, n / 2 + 1, n)\n    ))\n  else \n    x * 2024\n}\n\nblink_n &lt;- function(df, n) {\n  if (n == 0)\n    return(sum(df$n))\n  \n  df |&gt; \n    mutate(stones = map(stones, blink)) |&gt; \n    unnest(stones) |&gt; \n    summarize(n = sum(n), .by = stones) |&gt; \n    blink_n(n - 1)\n}\n\nRun blink function 25 times on puzzle input:\n\ndf &lt;- tibble(stones = input, n = 1)\n\nblink_n(df, 25)\n\n[1] 193899",
    "crumbs": [
      "2024",
      "Day 11"
    ]
  },
  {
    "objectID": "2024/R/day11.html#part-2",
    "href": "2024/R/day11.html#part-2",
    "title": "Day 11",
    "section": "Part 2",
    "text": "Part 2\nRun blink function 75 times on puzzle input:\n\nblink_n(df, 75) |&gt; \n  format(scientific = FALSE)\n\n[1] \"229682160383225\"",
    "crumbs": [
      "2024",
      "Day 11"
    ]
  },
  {
    "objectID": "2024/R/day04.html",
    "href": "2024/R/day04.html",
    "title": "Day 4",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day04.txt\")",
    "crumbs": [
      "2024",
      "Day 4"
    ]
  },
  {
    "objectID": "2024/R/day04.html#setup",
    "href": "2024/R/day04.html#setup",
    "title": "Day 4",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day04.txt\")",
    "crumbs": [
      "2024",
      "Day 4"
    ]
  },
  {
    "objectID": "2024/R/day04.html#part-1",
    "href": "2024/R/day04.html#part-1",
    "title": "Day 4",
    "section": "Part 1",
    "text": "Part 1\n\n# Convert vector of text to matrix\ntxt_to_mtx &lt;- function(txt) {\n  txt |&gt; \n    str_split(\"\") |&gt; \n    unlist() |&gt; \n    matrix(nrow = length(txt), byrow = TRUE)\n}\n\n# Convert matrix to vector of text\nmtx_to_txt &lt;- function(mtx) {\n  mtx |&gt; \n    t() |&gt; \n    as_tibble() |&gt; \n    as.list() |&gt; \n    map(str_flatten) |&gt; \n    unlist() |&gt; \n    unname()\n}\n\n# Transpose a vector of text\ntranspose_txt &lt;- function(txt) {\n  txt |&gt; \n    txt_to_mtx() |&gt; \n    t() |&gt; \n    mtx_to_txt()\n}\n\n# Get rows and columns of input as individual text vectors\nrows &lt;- input\ncols &lt;- transpose_txt(rows)\n\n# Convert diagonals of input as individual text vectors\npad &lt;- map_chr(\n  1:length(rows), \n  ~ str_c(rep_len(\" \", .x - 1), collapse = \"\")\n)\n\ndiag1 &lt;- str_c(pad, rows, rev(pad)) |&gt; \n  transpose_txt()\ndiag2 &lt;- str_c(rev(pad), rows, pad) |&gt; \n  transpose_txt()\n\n# Loop over rows, columns, and diagnoals and count occurrences of \"XMAS\"\nmap_int(\n  list(rows, cols, diag1, diag2),\n  ~ sum(str_count(.x, \"XMAS\") + str_count(.x, \"SAMX\"))\n) |&gt; \n  sum()\n\n[1] 2599",
    "crumbs": [
      "2024",
      "Day 4"
    ]
  },
  {
    "objectID": "2024/R/day04.html#part-2",
    "href": "2024/R/day04.html#part-2",
    "title": "Day 4",
    "section": "Part 2",
    "text": "Part 2\n\n# Define the four possible XMAS patterns in a 3x3 grid as a regex string\nxmas1 &lt;- \"M.S.A.M.S\"\nxmas4 &lt;- \"S.M.A.S.M\"\nxmas2 &lt;- \"S.S.A.M.M\"\nxmas3 &lt;- \"M.M.A.S.S\"\nxmas_regex &lt;- glue::glue(\"{xmas1}|{xmas2}|{xmas3}|{xmas4}\")\n\n# Convert input into a matrix\nmtx &lt;- txt_to_mtx(input)\n\n# Extract every 3x3 submatrix in the input text block as a text string\nmap(\n  1:(nrow(mtx) - 2),\n  function(row_start) {\n    map_chr(\n      1:(ncol(mtx) - 2),\n      function(col_start) {\n        mtx[row_start:(row_start + 2), col_start:(col_start + 2)] |&gt; \n          mtx_to_txt() |&gt; \n          str_flatten()\n      }\n    )\n  }\n) |&gt; \n  unlist() |&gt; \n  \n  # Count the text strings with a valid XMAS pattern\n  str_detect(xmas_regex) |&gt; \n  sum()\n\n[1] 1948",
    "crumbs": [
      "2024",
      "Day 4"
    ]
  },
  {
    "objectID": "2022/R/day09.html",
    "href": "2022/R/day09.html",
    "title": "Day 9",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(ctmle, include.only = \"bound\")\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day09.txt\") |&gt;\n  str_split(\" \")",
    "crumbs": [
      "2022",
      "Day 9"
    ]
  },
  {
    "objectID": "2022/R/day09.html#setup",
    "href": "2022/R/day09.html#setup",
    "title": "Day 9",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(ctmle, include.only = \"bound\")\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day09.txt\") |&gt;\n  str_split(\" \")",
    "crumbs": [
      "2022",
      "Day 9"
    ]
  },
  {
    "objectID": "2022/R/day09.html#part-1",
    "href": "2022/R/day09.html#part-1",
    "title": "Day 9",
    "section": "Part 1",
    "text": "Part 1\n\n# Convert head movements to sequence of locations on complex plane\nhead_path &lt;- input |&gt;\n  map(~ rep(.x[[1]], .x[[2]])) |&gt;\n  reduce(c) |&gt;\n  recode(\"R\" = 1 + 0i, \"L\" = -1 + 0i, \"U\" = 0 + 1i, \"D\" = 0 - 1i) |&gt;\n  accumulate(.init = 0 + 0i, .f = sum)\n\n# Find path of next knot given path of previous knot.\nmove_next_knot &lt;- function(prev_knot_path) {\n  accumulate(\n    .x = prev_knot_path,\n    .f = function(tail = .x, head = .y) {\n      diff &lt;- head - tail\n      if_else(\n        max(abs(Re(diff)), abs(Im(diff))) &lt;= 1,\n        tail,\n        tail + bound(Re(diff), c(-1, 1)) + bound(Im(diff), c(-1, 1)) * 1i\n      )\n    }\n  )\n}\n\n\nunique_tail_spots &lt;- function(path, num_knots) {\n  # Iteratively compute path of each knot from head & to tail\n  move_tail &lt;- reduce(map(1:(num_knots - 1), ~ move_next_knot), compose)\n\n  # Find number of unique locations in the tail's path\n  length(unique(move_tail(path)))\n}\n\n\nunique_tail_spots(head_path, num_knots = 2)\n\n[1] 6197",
    "crumbs": [
      "2022",
      "Day 9"
    ]
  },
  {
    "objectID": "2022/R/day09.html#part-2",
    "href": "2022/R/day09.html#part-2",
    "title": "Day 9",
    "section": "Part 2",
    "text": "Part 2\n\nunique_tail_spots(head_path, num_knots = 10)\n\n[1] 2562",
    "crumbs": [
      "2022",
      "Day 9"
    ]
  },
  {
    "objectID": "2022/R/day20.html",
    "href": "2022/R/day20.html",
    "title": "Day 20",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day20.txt\", skip_empty_rows = TRUE) |&gt; \n  as.numeric()",
    "crumbs": [
      "2022",
      "Day 20"
    ]
  },
  {
    "objectID": "2022/R/day20.html#setup",
    "href": "2022/R/day20.html#setup",
    "title": "Day 20",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day20.txt\", skip_empty_rows = TRUE) |&gt; \n  as.numeric()",
    "crumbs": [
      "2022",
      "Day 20"
    ]
  },
  {
    "objectID": "2022/R/day20.html#part-1",
    "href": "2022/R/day20.html#part-1",
    "title": "Day 20",
    "section": "Part 1",
    "text": "Part 1\n\n# Shift the value at the given index by n steps\nshift_value &lt;- function(vec, idx_old, n) {\n  idx_new &lt;- (idx_old + n - 2) %% (length(vec) - 1) + 1\n  value &lt;- vec[idx_old]\n  \n  vec |&gt; \n    discard_at(idx_old) |&gt; \n    append(value, after = idx_new)\n}\n\n# Mix the given list of integers in order by shifting values one-by-one \nmix &lt;- function(file, n = 1) {\n  ids &lt;- 1:length(file)\n  \n  for (rep in 1:n) {\n    for (i in 1:length(file)) {\n      ids &lt;- shift_value(ids, which(ids == i), file[i])\n    }\n  }\n  \n  file[ids]\n}\n\n# Sum the grove coordinates in a given vector\ngrove_coords &lt;- function(vec) {\n  c(1000, 2000, 3000) |&gt; \n    map_dbl(~ vec[(which(vec == 0) + .x) %% length(vec)]) |&gt; \n    sum()\n}\n\nRun on puzzle input:\n\ninput |&gt; \n  mix() |&gt; \n  grove_coords()\n\n[1] 2215",
    "crumbs": [
      "2022",
      "Day 20"
    ]
  },
  {
    "objectID": "2022/R/day20.html#part-2",
    "href": "2022/R/day20.html#part-2",
    "title": "Day 20",
    "section": "Part 2",
    "text": "Part 2\nApply decryption key and mix 10 times:\n\n(input * 811589153) |&gt; \n  mix(n = 10) |&gt; \n  grove_coords()\n\n[1] 8927480683",
    "crumbs": [
      "2022",
      "Day 20"
    ]
  },
  {
    "objectID": "2022/R/day22.html",
    "href": "2022/R/day22.html",
    "title": "Day 22",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day22.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 22"
    ]
  },
  {
    "objectID": "2022/R/day22.html#setup",
    "href": "2022/R/day22.html#setup",
    "title": "Day 22",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day22.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 22"
    ]
  },
  {
    "objectID": "2022/R/day22.html#part-1",
    "href": "2022/R/day22.html#part-1",
    "title": "Day 22",
    "section": "Part 1",
    "text": "Part 1\nConvert input to a grid board and a series of steps in the path:\n\nboard &lt;- input |&gt; \n  head(-1) |&gt; \n  enframe(name = \"row\") |&gt; \n  mutate(value = str_split(value, \"\")) |&gt; \n  unnest(value) |&gt; \n  mutate(col = row_number(), .by = row, .after = row) |&gt; \n  filter(value %in% c(\".\", \"#\")) |&gt; \n  mutate(id = row_number(), .before = everything())\n\npath &lt;- input |&gt;\n  tail(1) |&gt; \n  str_split_1(\"(?&lt;=.)(?=[LR])\") |&gt; \n  as_tibble_col(column_name = \"input\") |&gt; \n  mutate(\n    turn = case_match(str_extract(input, \"L|R\"), \n      \"R\" ~ 1, \n      \"L\" ~ -1, \n      .default = 0\n    ),\n    walk = parse_number(input),\n  )\n\nCreate a set of 2D lists by direction:\n\nvecs &lt;- map(\n  c(row = \"row\", col = \"col\"),\n  ~ board |&gt; \n    select({{ .x }}, id, value) |&gt; \n    arrange(.data[[.x]]) |&gt; \n    nest(vec = c(id, value)) |&gt; \n    mutate(vec = map(vec, deframe)) |&gt; \n    select(vec) |&gt; \n    deframe()\n)\n\n\nwrap_head &lt;- \\(x, n) c(tail(x,  n), head(x, -n))\nwrap_tail &lt;- \\(x, n) c(tail(x, -n), head(x,  n))\n\ndirs_2d &lt;- c(\"row_pos\", \"col_pos\", \"row_neg\", \"col_neg\")\n\nnext_dir &lt;- function(dir_vec, prv_dir, turn) {\n  dir_vec[((which(dir_vec == prv_dir) + turn - 1) %% length(dir_vec)) + 1]\n}\n\nwalk_n &lt;- function(id_start, dir_start, n) {\n  dir_vec  &lt;- str_extract(dir_start, \"row|col\")\n  dir_sign &lt;- case_match(str_extract(dir_start, \"pos|neg\"), \n    \"pos\" ~ 1, \n    \"neg\" ~ -1\n  )\n  \n  vec_idx &lt;- board |&gt; \n    filter(id == id_start) |&gt; \n    pull({{ dir_vec }})\n  \n  x   &lt;- vecs[[dir_vec]][[vec_idx]]\n  idx &lt;- which(names(x) == id_start)\n  \n  for (i in 1:n) {\n    idx_next &lt;- (idx + dir_sign - 1) %% length(x) + 1\n    \n    if (x[idx_next] == \"#\")\n      break\n    else\n      idx &lt;- idx_next\n  }\n  \n  as.numeric(names(x)[idx])\n}\n\ncompute_pwd &lt;- function(cell_id, dir_num) {\n  final &lt;- filter(board, id == cell_id)\n  1000 * final$row + 4 * final$col + unname(dir_num)\n}\n\ninit_cell &lt;- board |&gt; \n  filter(value == \".\") |&gt; \n  pull(id) |&gt; \n  min()\n\nRun on puzzle input:\n\ncell &lt;- init_cell\ndir  &lt;- \"row_pos\"\n  \nfor (i in 1:nrow(path)) {\n  prv_dir  &lt;- dir\n  prv_cell &lt;- cell\n  \n  dir  &lt;- next_dir(dirs_2d, prv_dir, path$turn[i])\n  cell &lt;- walk_n(cell, dir, path$walk[i])\n}\n\ncompute_pwd(cell, which(dirs_2d == dir) - 1)\n\n[1] 164014",
    "crumbs": [
      "2022",
      "Day 22"
    ]
  },
  {
    "objectID": "2022/R/day22.html#part-2",
    "href": "2022/R/day22.html#part-2",
    "title": "Day 22",
    "section": "Part 2",
    "text": "Part 2\nConvert from row/col vectors to roll/pitch/yaw vectors:\n\nbox_dim &lt;- 50\n\nvecs[[\"roll\"]] &lt;- pmap(\n  list(\n    vecs$row[1:box_dim],\n    vecs$row[1:box_dim + box_dim * 2] |&gt; \n      rev() |&gt; \n      map(rev)\n  ),\n  ~ c(..1, ..2)\n)\n\nvecs[[\"pitch\"]] &lt;- pmap(\n  list(\n    vecs$col[1:box_dim + box_dim],\n    vecs$row[1:box_dim + box_dim * 3] |&gt; \n      map(rev)\n  ),\n  ~ c(..1, ..2)\n)\n\nvecs[[\"yaw\"]] &lt;- pmap(\n  list(\n    vecs$row[1:box_dim + box_dim],\n    vecs$col[1:box_dim + box_dim * 2] |&gt; \n      map(rev),\n    vecs$col[1:box_dim] |&gt; \n      map(rev)\n  ),\n  ~ c(..1, ..2, ..3)\n)\n\ncoords_3d &lt;- map(\n  c(roll = \"roll\", pitch = \"pitch\", yaw = \"yaw\"),\n  ~ vecs[[.x]] |&gt; \n    map(~ as.numeric(names(.x))) |&gt; \n    enframe(name = .x, value = \"id\") |&gt; \n    unnest(id) |&gt; \n    relocate(id)\n) |&gt; \n  reduce(partial(full_join, by = join_by(id)))\n\nCreate a new set of instructions for making left/right turns that depend on which box face is currently occupied:\n\ndirs_3d &lt;- list(\n  f1 = c(\"roll_pos\",  \"pitch_pos\", \"roll_neg\",  \"pitch_neg\"),\n  f2 = c(\"roll_pos\",  \"yaw_neg\",   \"roll_neg\",  \"yaw_pos\"),\n  f3 = c(\"yaw_pos\",   \"pitch_pos\", \"yaw_neg\",   \"pitch_neg\"),\n  f4 = c(\"roll_neg\",  \"yaw_neg\",   \"roll_pos\",  \"yaw_pos\"),\n  f5 = c(\"roll_neg\",  \"pitch_pos\", \"roll_pos\",  \"pitch_neg\"),\n  f6 = c(\"pitch_neg\", \"yaw_neg\",   \"pitch_pos\", \"yaw_pos\")\n) |&gt; \n  map(partial(set_names, nm = c(\"row_pos\", \"col_pos\", \"row_neg\", \"col_neg\")))\n\nfaces &lt;- board |&gt; \n  mutate(\n    face_row = ceiling(row / box_dim), \n    face_col = ceiling(col / box_dim)\n  ) |&gt;\n  arrange(id) |&gt; \n  mutate(\n    box_face = cur_group_id(),\n    .by = c(face_row, face_col)\n  ) |&gt; \n  select(id, box_face)\n\nboard_3d &lt;- board |&gt; \n  left_join(coords_3d, join_by(id)) |&gt; \n  left_join(faces, join_by(id))\n\nRedefine the walk function to take roll/pitch/yaw directions:\n\nwalk_n &lt;- function(id_start, dir_start, n) {\n  dir_vec  &lt;- str_extract(dir_start, \"roll|pitch|yaw\")\n  dir_sign &lt;- case_match(str_extract(dir_start, \"pos|neg\"), \n    \"pos\" ~ 1, \n    \"neg\" ~ -1\n  )\n  \n  vec_idx &lt;- board_3d |&gt; \n    filter(id == id_start) |&gt; \n    pull({{ dir_vec }})\n  \n  x   &lt;- vecs[[dir_vec]][[vec_idx]]\n  idx &lt;- which(names(x) == id_start)\n  \n  for (i in 1:n) {\n    idx_next &lt;- (idx + dir_sign - 1) %% length(x) + 1\n    \n    if (x[idx_next] == \"#\")\n      break\n    else\n      idx &lt;- idx_next\n  }\n  \n  as.numeric(names(x)[idx])\n}\n\nRe-run the puzzle input:\n\ncell &lt;- init_cell\ndir  &lt;- \"roll_pos\"\ndir_vec &lt;- dirs_3d$f1\n  \nfor (i in 1:nrow(path)) {\n  prv_dir  &lt;- dir\n  prv_cell &lt;- cell\n  \n  dir_vec &lt;- dirs_3d[[board_3d$box_face[[prv_cell]]]]\n  \n  dir  &lt;- next_dir(dir_vec, prv_dir, path$turn[i])\n  cell &lt;- walk_n(cell, dir, path$walk[i])\n}\n\ncompute_pwd(cell, which(dir_vec == dir) - 1)\n\n[1] 47525",
    "crumbs": [
      "2022",
      "Day 22"
    ]
  },
  {
    "objectID": "2022/R/day24.html",
    "href": "2022/R/day24.html",
    "title": "Day 24",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day24.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 24"
    ]
  },
  {
    "objectID": "2022/R/day24.html#setup",
    "href": "2022/R/day24.html#setup",
    "title": "Day 24",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day24.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 24"
    ]
  },
  {
    "objectID": "2022/R/day24.html#part-1",
    "href": "2022/R/day24.html#part-1",
    "title": "Day 24",
    "section": "Part 1",
    "text": "Part 1\nConvert input string to a matrix of characters:\n\nw &lt;- str_length(input[[1]])\nh &lt;- length(input)\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  unlist() |&gt; \n  matrix(nrow = h, byrow = TRUE)\n\nDefine helper functions to determine whether a map space is occupied at a given time. Hint from reddit user u/jaccomoc to scan rows/columns for blizzards at a certain time, rather than simulating the entire map at every time point:\n\n# Define the constant start/end locations\ninit   &lt;- c(row = 1, col = 2)\ntarget &lt;- c(row = h, col = w - 1)\n\n# Wrap blizzards aroound the map edges\nwrap_w &lt;- function(idx) (idx - 2) %% (w - 2) + 2\nwrap_h &lt;- function(idx) (idx - 2) %% (h - 2) + 2\n\n# Check whether a given cell is open at a given time\nis_open &lt;- function(idx, time) {\n  row &lt;- idx[[1]]\n  col &lt;- idx[[2]]\n  mtx[row, wrap_w(col - time)] != '&gt;' & mtx[wrap_h(row - time), col] != 'v' &\n  mtx[row, wrap_w(col + time)] != '&lt;' & mtx[wrap_h(row + time), col] != '^'\n}\n\n# Check whether a given cell is in the bounds of the map\nin_bounds &lt;- function(idx) {\n  row &lt;- idx[[1]]\n  col &lt;- idx[[2]]\n  \n  (between(row, 2, h - 1) & between(col, 2, w - 1)) | \n  all(idx == init) | all(idx == target)\n}\n\nDefine a function that loops through time points and stops when the first elf reaches the target. Hint on use of “quantum elves” that die if standing on a blizzard spot from Reddit user u/SLiV9.\n\nmoves &lt;- list(\n  c(row =  1, col =  0),  # down\n  c(row =  0, col =  1),  # right\n  c(row = -1, col =  0),  # up\n  c(row =  0, col = -1),  # left\n  c(row =  0, col =  0)   # still\n)\n\ntime_cross &lt;- function(time_start, init, target) {\n  \n  cur_locations &lt;- list(init)\n  t &lt;- time_start\n  \n  repeat {\n    t &lt;- t + 1\n\n    cur_locations &lt;- cur_locations |&gt; \n      map(\\(start) map(moves, \\(move) start + move)) |&gt; \n      flatten() |&gt; \n      keep(in_bounds) |&gt; \n      keep(partial(is_open, time = t)) |&gt; \n      unique()\n    \n    if (list(target) %in% cur_locations) break\n  }\n  \n  t\n}\n\nRun on puzzle input:\n\nt1 &lt;- time_cross(0, init, target)\n\nt1\n\n[1] 299",
    "crumbs": [
      "2022",
      "Day 24"
    ]
  },
  {
    "objectID": "2022/R/day24.html#part-2",
    "href": "2022/R/day24.html#part-2",
    "title": "Day 24",
    "section": "Part 2",
    "text": "Part 2\nRun the simulation again two more times, swapping the target and source locations, and starting where the last left off.\n\nt2 &lt;- time_cross(t1, target, init)\nt3 &lt;- time_cross(t2, init, target)\n\nt3\n\n[1] 899",
    "crumbs": [
      "2022",
      "Day 24"
    ]
  },
  {
    "objectID": "2022/R/day19.html",
    "href": "2022/R/day19.html",
    "title": "Day 19",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day19.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 19"
    ]
  },
  {
    "objectID": "2022/R/day19.html#setup",
    "href": "2022/R/day19.html#setup",
    "title": "Day 19",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day19.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 19"
    ]
  },
  {
    "objectID": "2022/R/day19.html#part-1",
    "href": "2022/R/day19.html#part-1",
    "title": "Day 19",
    "section": "Part 1",
    "text": "Part 1\nReformat the input as lists of robots with inputs and outputs for each blueprint:\n\nore      &lt;- c(\"ore\" = 1, \"clay\" = 0, \"obsidian\" = 0, \"geode\" = 0)\nclay     &lt;- c(\"ore\" = 0, \"clay\" = 1, \"obsidian\" = 0, \"geode\" = 0)\nobsidian &lt;- c(\"ore\" = 0, \"clay\" = 0, \"obsidian\" = 1, \"geode\" = 0)\ngeode    &lt;- c(\"ore\" = 0, \"clay\" = 0, \"obsidian\" = 0, \"geode\" = 1)\nempty    &lt;- c(\"ore\" = 0, \"clay\" = 0, \"obsidian\" = 0, \"geode\" = 0)\n\nunglue_pattern &lt;- str_c(\n  \"Blueprint {blueprint}:\",\n  \"Each ore robot costs {ore_ore} ore.\",\n  \"Each clay robot costs {clay_ore} ore.\",\n  \"Each obsidian robot costs {obsidian_ore} ore and {obsidian_clay} clay.\",\n  \"Each geode robot costs {geode_ore} ore and {geode_obsidian} obsidian.\",\n  sep = \" \"\n)\n\nblueprints &lt;- input |&gt; \n  unglue::unglue_data(unglue_pattern, convert = TRUE) |&gt; \n  pivot_longer(\n    -blueprint, \n    names_to = c(\"robot\", \"cost_type\"), \n    values_to = \"cost_value\",\n    names_sep = \"_\"\n  ) |&gt; \n  pivot_wider(names_from = cost_type, values_from = cost_value, values_fill = 0) |&gt; \n  mutate(geode = 0) |&gt; \n  nest(cost = c(ore, clay, obsidian, geode)) |&gt; \n  mutate(\n    cost = map(cost, unlist),\n    output = map(robot, get)\n  ) |&gt; \n  group_split(blueprint)\n\nDefine a set of functions to find the maximum number of geodes for each blueprint.\nOptimizations to improve runtime were sourced from Reddit (1, 2).\n\nmax_geodes &lt;- function(blueprint, inventory, production, time_left, max_cost, cur_best = 0) {\n  \n  # If the best possible set of geode robots in this branch can't outdo the current\n  # best, then don't traverse this branch.\n  theoretical_best &lt;- inventory[\"geode\"] + \n    production[\"geode\"] * time_left +\n    sum(1:time_left - 1)\n  \n  if (time_left == 0 | theoretical_best &lt;= cur_best)\n    return(inventory[\"geode\"])\n    \n  # Determine the amount of time required to build each robot next\n  time_to_build &lt;- map_dbl(blueprint$cost, \n    ~ ceiling((.x - inventory) / production) |&gt; \n      keep(.x &gt; 0) |&gt; \n      map_dbl(~ max(.x, 0) + 1) |&gt; \n      max()\n  )\n  \n  # Determine which robots are buildable within the remaining time\n  idx &lt;- which(\n    is.finite(time_to_build) & \n      time_to_build &lt; time_left & \n      production &lt; max_cost\n  )\n  \n  # Quit if there are no remaining options\n  if (length(idx) == 0)\n    return((inventory + time_left * production)[\"geode\"])\n  \n  # Loop through each branch of options\n  for (i in rev(idx)) {\n    branch_best &lt;- max_geodes(\n        blueprint  = blueprint,\n        inventory  = inventory + \n          production * time_to_build[[i]] - \n          blueprint$cost[[i]],\n        production = production + blueprint$output[[i]],\n        time_left  = time_left - time_to_build[[i]],\n        max_cost   = max_cost,\n        cur_best   = cur_best\n      )\n    if (branch_best &gt; cur_best)\n      cur_best &lt;- branch_best\n  }\n  \n  return(cur_best)\n}\n\nblueprint_geodes &lt;- function(blueprints, total_time) {\n  \n  best &lt;- c()\n  \n  for (blueprint in blueprints) {\n    max_cost &lt;- blueprint |&gt; \n      pull(cost) |&gt; \n      do.call(what = pmax) |&gt; \n      modify_at(.at = \"geode\", ~ Inf)\n    best &lt;- c(\n      best,\n      max_geodes(\n        blueprint  = blueprint,\n        inventory  = empty,\n        production = ore,\n        time_left  = total_time, \n        max_cost   = max_cost,\n        cur_best   = 0\n      )\n    )\n  }\n  \n  unname(best)\n}\n\nCompute total quality score by multiplying the max geodes for each blueprint by its index:\n\nblueprint_geodes(blueprints, total_time = 24) |&gt; \n  imap_dbl(\\(geodes, i) i * geodes) |&gt; \n  sum()\n\n[1] 2160",
    "crumbs": [
      "2022",
      "Day 19"
    ]
  },
  {
    "objectID": "2022/R/day19.html#part-2",
    "href": "2022/R/day19.html#part-2",
    "title": "Day 19",
    "section": "Part 2",
    "text": "Part 2\nFilter to the first 3 blueprints, increase the total time to 32 seconds, and take the product of the max geodes:\n\nblueprints |&gt; \n  keep_at(1:3) |&gt; \n  blueprint_geodes(total_time = 32) |&gt; \n  prod()\n\n[1] 13340",
    "crumbs": [
      "2022",
      "Day 19"
    ]
  },
  {
    "objectID": "2022/R/day14.html",
    "href": "2022/R/day14.html",
    "title": "Day 14",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from text\ninput &lt;- read_lines(\"../input/day14.txt\")",
    "crumbs": [
      "2022",
      "Day 14"
    ]
  },
  {
    "objectID": "2022/R/day14.html#setup",
    "href": "2022/R/day14.html#setup",
    "title": "Day 14",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from text\ninput &lt;- read_lines(\"../input/day14.txt\")",
    "crumbs": [
      "2022",
      "Day 14"
    ]
  },
  {
    "objectID": "2022/R/day14.html#part-1",
    "href": "2022/R/day14.html#part-1",
    "title": "Day 14",
    "section": "Part 1",
    "text": "Part 1\nConvert input from rows of text lines to a list of obstacle coordinates:\n\n# Extract numeric values from the input text\ndf &lt;- input |&gt; \n  str_split(\" -&gt; \") |&gt; \n  imap_dfr(\\(input, idx) tibble(idx, input)) |&gt; \n  unglue_unnest(input, \"{x},{y}\", convert = TRUE)\n\n\n# Expand the endpoints into a list of coordinates of every obstacle\nobstacles &lt;- df |&gt; \n  mutate(\n    seq_x = map2(x, lead(x), ~ if (!is.na(.x) & !is.na(.y)) .x:.y),\n    seq_y = map2(y, lead(y), ~ if (!is.na(.x) & !is.na(.y)) .x:.y),\n    .by = idx\n  ) |&gt; \n  unnest(c(seq_x, seq_y)) |&gt; \n  distinct(x = seq_x, y = seq_y) |&gt; \n  mutate(chr = '#')\n\nDefine a function to recursively drop a grain of sand until it comes to rest:\n\ndrop_grain &lt;- function(scan, x_cur, y_cur) {\n  y_new &lt;- y_cur + 1\n  \n  # Check if new y-coordinate is out of bounds\n  if (y_new &gt; max(scan$y))\n    return(scan)\n  \n  for (x_new in c(x_cur, x_cur - 1, x_cur + 1)) {\n    # Check if next x-coordinate is out of bounds\n    if (!between(x_new, min(scan$x), max(scan$x)))\n      return(scan)\n    # If grain can flow into the next spot, recurse into next spot\n    else if (nrow(filter(scan, x == x_new, y == y_new)) == 0)\n      return(drop_grain(scan, x_new, y_new))\n  }\n\n  # If grain has nowhere to go, drop the grain in its current place and exit\n  return(add_row(scan, x = x_cur, y = y_cur, chr = \"o\"))\n}\n\nDefine a function that fills the map with sand one grain at a time, starting from the designated point, until all sand comes to rest:\n\nfill_sand &lt;- function(scan, grain_func) {\n  repeat {\n    scan_new &lt;- grain_func(scan)\n    \n    # If the scan is unchanged after dropping the grain, the sand is at rest. \n    if (nrow(scan_new) == nrow(scan)) break\n    \n    scan &lt;- scan_new\n  }\n  scan\n}\n\ncount_grains &lt;- function(scan) {\n  scan |&gt; \n    filter(chr == \"o\") |&gt; \n    nrow()\n}\n\nCount the grains using the puzzle input:\n\nobstacles |&gt; \n  fill_sand(grain_func = partial(drop_grain, x_cur = 500, y_cur = 0)) |&gt; \n  count_grains()\n\n[1] 862",
    "crumbs": [
      "2022",
      "Day 14"
    ]
  },
  {
    "objectID": "2022/R/day14.html#part-2",
    "href": "2022/R/day14.html#part-2",
    "title": "Day 14",
    "section": "Part 2",
    "text": "Part 2\nRe-define the drop_grain function to allow for the boundless floor:\n\ndrop_grain &lt;- function(scan, x_cur, y_cur, floor) {\n  y_new &lt;- y_cur + 1\n  \n  # Check if current location already has a grain of sand (entry blocked)\n  if (nrow(filter(scan, x == x_cur, y == y_cur)) &gt; 0)\n    return(scan)\n  \n  # Check if the current sand grain is sitting on top of the floor\n  if (y_new == floor)\n    return(add_row(scan, x = x_cur, y = y_cur, chr = \"o\"))\n  \n  # If grain can flow into the next spot, recurse into next spot\n  for (x_new in c(x_cur, x_cur - 1, x_cur + 1)) {\n    if (nrow(filter(scan, x == x_new, y == y_new)) == 0)\n      return(drop_grain(scan, x_new, y_new, floor))\n  }\n\n  # If grain has nowhere to go, drop the grain in its current place and exit\n  return(add_row(scan, x = x_cur, y = y_cur, chr = \"o\"))\n}\n\nCount the grains using the puzzle input:\n\nobstacles |&gt; \n  fill_sand(\n    grain_func = partial(\n      drop_grain, \n      x_cur = 500, \n      y_cur = 0, \n      floor = max(obstacles$y) + 2\n    )\n  ) |&gt; \n  count_grains()\n\n[1] 28744",
    "crumbs": [
      "2022",
      "Day 14"
    ]
  },
  {
    "objectID": "2022/R/day15.html",
    "href": "2022/R/day15.html",
    "title": "Day 15",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sf)\n\ntheme_set(theme_bw())\n\n# Read input from text and extract numeric values into a data frame\ninput &lt;- read_lines(\"../input/day15.txt\") |&gt; \n  unglue_data(\n    \"Sensor at x={s_x}, y={s_y}: closest beacon is at x={b_x}, y={b_y}\",\n    convert = TRUE\n  )",
    "crumbs": [
      "2022",
      "Day 15"
    ]
  },
  {
    "objectID": "2022/R/day15.html#setup",
    "href": "2022/R/day15.html#setup",
    "title": "Day 15",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sf)\n\ntheme_set(theme_bw())\n\n# Read input from text and extract numeric values into a data frame\ninput &lt;- read_lines(\"../input/day15.txt\") |&gt; \n  unglue_data(\n    \"Sensor at x={s_x}, y={s_y}: closest beacon is at x={b_x}, y={b_y}\",\n    convert = TRUE\n  )",
    "crumbs": [
      "2022",
      "Day 15"
    ]
  },
  {
    "objectID": "2022/R/day15.html#part-1",
    "href": "2022/R/day15.html#part-1",
    "title": "Day 15",
    "section": "Part 1",
    "text": "Part 1\nConvert input into a list of beacons, sensors, and total detection distances:\n\nsensors &lt;- input |&gt; \n  distinct(\n    s_x, \n    s_y, \n    max_dist = abs(b_x - s_x) + abs(b_y - s_y)\n  )\n\nbeacons &lt;- input |&gt; \n  distinct(x = b_x, y = b_y)\n\nGenerate a set of polygons that defines the regions detectible by each sensor:\n\n# Convert each sensor's detection distance into a region defined by a polygon\npoly &lt;- sensors |&gt; \n  mutate(\n    polygon = pmap(list(s_x, s_y, max_dist), function(x, y, dist) {\n      rbind(\n        c(x - dist, y),\n        c(x, y - dist),\n        c(x + dist, y),\n        c(x, y + dist),\n        c(x - dist, y)\n      ) |&gt; \n        list() |&gt; \n        st_polygon()\n    }),\n    geometry = st_sfc(polygon)\n  ) |&gt; \n  transmute(idx = row_number(), geometry) |&gt; \n  st_as_sf()\n\n# Merge all polygons into a single geometric shape\npoly_union &lt;- st_union(poly)\n\nVisualize:\n\n# Overlapping regions\nggplot() + \n  geom_sf(data = poly, aes(fill = factor(idx))) + \n  scale_fill_viridis_d(guide = \"none\")\n\n\n\n\n\n\n\n# Merged region\nggplot() + \n  geom_sf(data = poly_union)\n\n\n\n\n\n\n\n\nDefine a set of functions to count the number of integer points that cannot have a beacon within the detection region\n\n# Convert a set of x/y boundaries to a spatial rectangle object\npoly_rect &lt;- function(xmin, xmax, ymin, ymax) {\n  rbind(\n    c(xmin, ymax), \n    c(xmin, ymin), \n    c(xmax, ymin), \n    c(xmax, ymax), \n    c(xmin, ymax)\n  ) |&gt; \n    list() |&gt; \n    st_polygon() |&gt; \n    st_sfc()\n}\n\n# Get the coordinates within a poly, optionally limited within x/y bounds\nsf_points_in_poly &lt;- function(poly, xlim = NULL, ylim = NULL) {\n  \n  # Define a rectangular region within which to generate grid points\n  points_region &lt;- poly_rect(\n    xmin = (if (is_null(xlim)) st_bbox(poly)$xmin else head(xlim, 1)) - 0.5, \n    xmax = (if (is_null(xlim)) st_bbox(poly)$xmax else tail(xlim, 1)) + 0.5, \n    ymin = (if (is_null(ylim)) st_bbox(poly)$ymin else head(ylim, 1)) - 0.5,\n    ymax = (if (is_null(ylim)) st_bbox(poly)$ymax else tail(ylim, 1)) + 0.5\n  )\n  \n  # Generate the grid points that sit within the polygon\n  points_region |&gt; \n    st_make_grid(cellsize = 1, what = \"centers\") |&gt; \n    st_intersection(poly) |&gt; \n    \n    # Convert the set of points from spatial objects to x-y coordinates\n    st_coordinates() |&gt; \n    as_tibble() |&gt; \n    mutate(across(everything(), as.integer)) |&gt; \n    rename_with(tolower)\n}\n\n# Count the points in a sf region (with optional x/y lims) that can't be a beacon\ncount_nonbeacon &lt;- function(detection_region, known_beacons, x = NULL, y = NULL) {\n  \n  # Get the set of integer points within the polygon and x-y region specified\n  detection_region |&gt; \n    sf_points_in_poly(xlim = x, ylim = y) |&gt;\n  \n    # Remove known beacons from the list of points and count\n    anti_join(known_beacons, join_by(x, y)) |&gt;\n    nrow()\n}\n\nRun puzzle input:\n\ncount_nonbeacon(poly_union, beacons, y = 2000000)\n\n[1] 5367037",
    "crumbs": [
      "2022",
      "Day 15"
    ]
  },
  {
    "objectID": "2022/R/day15.html#part-2",
    "href": "2022/R/day15.html#part-2",
    "title": "Day 15",
    "section": "Part 2",
    "text": "Part 2\nDefine a function to get the location of an undetected beacon within a viewport:\n\nfind_undetected_beacon &lt;- function(detection_region, xlim, ylim) {\n  boundary &lt;- poly_rect(xlim[1], xlim[2], ylim[1], ylim[2])\n  \n  # Find the polygon region where an undetected beacon could occur\n  undetected_region &lt;- st_difference(boundary, detection_region)\n  \n  # Get all integer points in the region\n  points &lt;- sf_points_in_poly(undetected_region)\n  \n  # Compute the region's boundary points to exclude\n  undetected_region_boundary &lt;- undetected_region |&gt;\n    st_bbox() |&gt;\n    as.list() |&gt;\n    pmap(\\(xmin, xmax, ymin, ymax) poly_rect(xmin, xmax, ymin, ymax)) |&gt;\n    pluck(1) |&gt; \n    st_difference(undetected_region) |&gt; \n    sf_points_in_poly()\n  \n  # Exclude all boundary points from the region\n  anti_join(points, undetected_region_boundary, join_by(x, y))\n  \n}\n\ntuning_freq &lt;- function(x, y) format(4000000 * x + y, scientific = FALSE)\n\nRun on puzzle input:\n\npoint &lt;- find_undetected_beacon(poly_union, c(0, 4000000), c(0, 4000000))\n\ntuning_freq(point$x, point$y)\n\n[1] \"11914583249288\"",
    "crumbs": [
      "2022",
      "Day 15"
    ]
  },
  {
    "objectID": "2022/R/day17.html",
    "href": "2022/R/day17.html",
    "title": "Day 17",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day17.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split_1(\"\")",
    "crumbs": [
      "2022",
      "Day 17"
    ]
  },
  {
    "objectID": "2022/R/day17.html#setup",
    "href": "2022/R/day17.html#setup",
    "title": "Day 17",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day17.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split_1(\"\")",
    "crumbs": [
      "2022",
      "Day 17"
    ]
  },
  {
    "objectID": "2022/R/day17.html#part-1",
    "href": "2022/R/day17.html#part-1",
    "title": "Day 17",
    "section": "Part 1",
    "text": "Part 1\nRepresenting obstacles as 1s and empty space as 0s, represent the shapes of the falling blocks, the floor, and the walls as bitwise integers:\n\nblock1 &lt;- strtoi(c(\"000111100\"                                    ), base = 2)\nblock2 &lt;- strtoi(c(\"000010000\",\"000111000\",\"000010000\"            ), base = 2)\nblock3 &lt;- strtoi(c(\"000111000\",\"000001000\",\"000001000\"            ), base = 2)\nblock4 &lt;- strtoi(c(\"000100000\",\"000100000\",\"000100000\",\"000100000\"), base = 2)\nblock5 &lt;- strtoi(c(\"000110000\",\"000110000\"                        ), base = 2)\n\nwalls  &lt;- strtoi(\"100000001\", base = 2)\nfloor  &lt;- strtoi(\"111111111\", base = 2)\n\nblocks &lt;- list(block1, block2, block3, block4, block5)\n\nDefine functions that give properties of the tower:\n\n# Print tower to terminal (for debugging)\nprint_tower &lt;- function(tower) {\n  tower |&gt;\n  imap_chr(\\(row, name) {\n    row |&gt; \n      intToBits() |&gt; \n      rev() |&gt; \n      tail(9) |&gt; \n      as.integer() |&gt; \n      case_match(0 ~ \"·\", 1 ~ \"#\") |&gt; \n      modify_at(.at = c(1L, 9L), .f = ~ \"|\") |&gt; \n      str_c(collapse = \"\") |&gt; \n      str_c(name, sep = \" \")\n  }) |&gt; \n  modify_at(.at = 1L, .f = ~ if_else(.x == \"|#######| 0\", \"+-------+ 0\", .x)) |&gt; \n  rev() |&gt; \n  cat(sep = \"\\n\")\n}\n\ntower_height &lt;- function(tower) {\n  idx &lt;- max(which(tower != walls))\n  tower[idx] |&gt;\n    names() |&gt; \n    as.double()\n}\n\ntower_base &lt;- function(tower) {\n  idx &lt;- max(which(accumulate(tower, bitwOr, .dir = \"backward\") == floor))\n  tower[idx] |&gt;\n    names() |&gt; \n    as.double()\n}\n\ntrim_tower &lt;- function(tower) {\n  base &lt;- tower_base(tower)\n  top  &lt;- tower_height(tower)\n  tower[as.character(base:top)]\n}\n\nDefine functions that move blocks and check if the move is valid:\n\nshift_block &lt;- function(block, dir) {\n  f &lt;- switch(dir, \n    \"&lt;\" = bitwShiftL, \n    \"&gt;\" = bitwShiftR\n  )\n  f(block, 1)\n}\n\nis_collision &lt;- function(block, tower_slice) {\n  any(bitwAnd(block, tower_slice) &gt; 0)\n}\n\n# Try to move the block L/R if the move is valid, or return the old one if not\ntry_shift_block &lt;- function(block, dir, tower_slice) {\n  new &lt;- shift_block(block, dir)\n  if (is_collision(new, tower_slice))\n    block\n  else\n    new\n}\n\nDefine a function to drop blocks onto a tower:\n\ndrop_blocks &lt;- function(jets, n_blocks) {\n  \n  tower        &lt;- floor\n  names(tower) &lt;- 1:length(tower) - 1\n  \n  n_jets &lt;- length(jets)\n  time   &lt;- 0\n  \n  # Cycle through the list of blocks and drop them in order\n  for (i in 1:n_blocks) {\n    \n    block_idx &lt;- (i - 1) %% length(blocks) + 1\n    block     &lt;- blocks[[block_idx]]\n    \n    # Initialize the vertical location of the block\n    block_loc &lt;- 1:length(block) + 3 + tower_height(tower)\n    \n    # Add empty wall space to the top of the tower\n    add_walls &lt;- rep(walls, length(block) + 3) |&gt; \n      set_names(c(min(block_loc) - 3:1, block_loc))\n    tower &lt;- c(tower, add_walls)\n    \n    # Drop block until it comes to rest\n    repeat {\n      jet_idx &lt;- time %% n_jets + 1\n      \n      # Apply jet blast & increment time\n      block &lt;- try_shift_block(block, jets[jet_idx], tower[as.character(block_loc)])\n      time &lt;- time + 1\n      \n      # Check if block has come to rest; if so, add block to tower\n      if (is_collision(block, tower[as.character(block_loc - 1)])) {\n        tower[as.character(block_loc)] &lt;- bitwOr(tower[as.character(block_loc)], block)\n        tower &lt;- trim_tower(tower)\n        break\n        \n      } \n      # Otherwise drop block one unit and repeat the block jet seq\n      else {\n        block_loc &lt;- block_loc - 1\n      }\n    }\n  }\n  \n  tower\n}\n\nRun on puzzle input:\n\ninput |&gt; \n  drop_blocks(2022) |&gt; \n  tower_height()\n\n[1] 3133",
    "crumbs": [
      "2022",
      "Day 17"
    ]
  },
  {
    "objectID": "2022/R/day17.html#part-2",
    "href": "2022/R/day17.html#part-2",
    "title": "Day 17",
    "section": "Part 2",
    "text": "Part 2\nModify the drop_blocks function to loop until a cycle is found and return cycle info:\n\nfind_cycle &lt;- function(jets) {\n  \n  tower        &lt;- floor\n  names(tower) &lt;- 1:length(tower) - 1\n  \n  n_jets &lt;- length(jets)\n  time   &lt;- 0\n  states &lt;- tibble(\n    n_blocks  = numeric(0),\n    tower_idx = list(),\n    tower_val = list(), \n    block_idx = numeric(0), \n    jet_idx   = numeric(0)\n  )\n  \n  i &lt;- 1\n  # Cycle through the list of blocks and drop them in order\n  repeat {\n    \n    block_idx &lt;- (i - 1) %% length(blocks) + 1\n    block     &lt;- blocks[[block_idx]]\n    \n    # Initialize the vertical location of the block\n    block_loc &lt;- 1:length(block) + 3 + tower_height(tower)\n    \n    # Add empty wall space to the top of the tower\n    add_walls &lt;- rep(walls, length(block) + 3) |&gt; \n      set_names(c(min(block_loc) - 3:1, block_loc))\n    tower &lt;- c(tower, add_walls)\n    \n    # Drop block until it comes to rest\n    repeat {\n      jet_idx &lt;- time %% n_jets + 1\n      \n      # Apply jet blast & increment time\n      block &lt;- try_shift_block(block, jets[jet_idx], tower[as.character(block_loc)])\n      time &lt;- time + 1\n      \n      # Check if block has come to rest; if so, add block to tower\n      if (is_collision(block, tower[as.character(block_loc - 1)])) {\n        tower[as.character(block_loc)] &lt;- bitwOr(tower[as.character(block_loc)], block)\n        tower &lt;- trim_tower(tower)\n        \n        # Add block and jet index to the states list\n        states &lt;- states |&gt; \n          add_row(\n            n_blocks  = i,\n            tower_idx = list(names(tower)),\n            tower_val = list(unname(tower)),\n            block_idx = block_idx,\n            jet_idx   = jet_idx\n          )\n        # print(tower)\n        break\n        \n      } \n      # Otherwise drop block one unit and repeat the block jet seq\n      else {\n        block_loc &lt;- block_loc - 1\n      }\n    }\n    \n    i &lt;- i + 1\n    \n    # After each block is dropped, check if a cycle has been found and return it\n    dupes &lt;- states |&gt; \n      filter(n_distinct(tower_val) != n(), .by = c(block_idx, jet_idx))\n    \n    if (nrow(dupes) &gt; 0) {\n      \n      cycle_length &lt;- dupes |&gt;\n        pull(n_blocks) |&gt;\n        reduce(`-`) |&gt;\n        abs()\n\n      cycle_start &lt;- dupes |&gt;\n        pull(n_blocks) |&gt;\n        min()\n      \n      cycle_height &lt;- dupes |&gt;\n        pull(tower_idx) |&gt; \n        map(as.numeric) |&gt; \n        reduce(`-`) |&gt; \n        unique() |&gt; \n        abs()\n\n      return(list(length = cycle_length, start = cycle_start, height = cycle_height))\n      return(dupes)\n    }\n  }\n}\n\nGet the cycle of the puzzle input:\n\ncycle &lt;- find_cycle(input)\n\nUsing the cycle info from the output, compute the majority of the height using the cycle, then and add the height of the remaineder:\n\nn_cycles &lt;- floor((1000000000000 - cycle$start) / cycle$length)\nn_blocks &lt;- (1000000000000 - cycle$start) %% cycle$length + cycle$start\n\n((n_cycles * cycle$height) + tower_height(drop_blocks(input, n_blocks))) |&gt; \n  format(scientific = FALSE)\n\n[1] \"1547953216393\"",
    "crumbs": [
      "2022",
      "Day 17"
    ]
  },
  {
    "objectID": "2022/R/day02.html",
    "href": "2022/R/day02.html",
    "title": "Day 2",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_fwf(\"../input/day02.txt\", col_types = \"c\")",
    "crumbs": [
      "2022",
      "Day 2"
    ]
  },
  {
    "objectID": "2022/R/day02.html#setup",
    "href": "2022/R/day02.html#setup",
    "title": "Day 2",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_fwf(\"../input/day02.txt\", col_types = \"c\")",
    "crumbs": [
      "2022",
      "Day 2"
    ]
  },
  {
    "objectID": "2022/R/day02.html#part-1",
    "href": "2022/R/day02.html#part-1",
    "title": "Day 2",
    "section": "Part 1",
    "text": "Part 1\n\n# Format shapes/strategies as numbers 1-3 for modular arithmetic\ndf &lt;- tibble(\n  opponent = as.numeric(factor(input$X1, levels = c(\"A\", \"B\", \"C\"))),\n  strategy = as.numeric(factor(input$X2, levels = c(\"X\", \"Y\", \"Z\")))\n)\n\nscore_shape &lt;- function(df) {\n  df |&gt; \n    mutate(\n      self = strategy,\n      outcome = (self - opponent + 1) %% 3 * 3,\n      score = self + outcome\n    ) |&gt;\n    pull(score) |&gt;\n    sum()\n}\n\nRun puzzle input:\n\nscore_shape(df)\n\n[1] 15422",
    "crumbs": [
      "2022",
      "Day 2"
    ]
  },
  {
    "objectID": "2022/R/day02.html#part-2",
    "href": "2022/R/day02.html#part-2",
    "title": "Day 2",
    "section": "Part 2",
    "text": "Part 2\n\nscore_outcome &lt;- function(df) {\n  df |&gt; \n    mutate(\n      self = (opponent + strategy) %% 3 + 1,\n      outcome = (strategy - 1) * 3,\n      score = self + outcome\n    ) |&gt;\n    pull(score) |&gt;\n    sum()\n}\n\n\nscore_outcome(df)\n\n[1] 15442",
    "crumbs": [
      "2022",
      "Day 2"
    ]
  },
  {
    "objectID": "2022/R/day12.html",
    "href": "2022/R/day12.html",
    "title": "Day 12",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day12.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 12"
    ]
  },
  {
    "objectID": "2022/R/day12.html#setup",
    "href": "2022/R/day12.html#setup",
    "title": "Day 12",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day12.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 12"
    ]
  },
  {
    "objectID": "2022/R/day12.html#part-1",
    "href": "2022/R/day12.html#part-1",
    "title": "Day 12",
    "section": "Part 1",
    "text": "Part 1\nReformat input as a data frame of coordinates and elevations:\n\ndf &lt;- input |&gt;\n  str_split(\"\") |&gt;\n  unlist() |&gt;\n  as_tibble() |&gt;\n  transmute(\n    id = row_number(),\n    letter = value,\n    elevation = case_when(\n      letter == \"S\" ~  Inf,\n      letter == \"E\" ~ -Inf,\n      .default = match(letter, letters)\n    ),\n    row = floor((id - 1) / str_length(input[1]) + 1),\n    col = (id - 1) %% str_length(input[1]) + 1\n  )\n\n\ndf_to_graph &lt;- function(df) {\n\n  # Flag whether each neighbor of each vertex is walkable\n  neighbors &lt;- df |&gt;\n    mutate(up   = lag(id), down  = lead(id), .by = col) |&gt;\n    mutate(left = lag(id), right = lead(id), .by = row) |&gt;\n    mutate(\n      across(\n        c(up, down, left, right),\n        ~ elevation[.x],\n        .names = \"{.col}_elev\"\n      ),\n      across(\n        ends_with(\"_elev\"),\n        ~ (.x - elevation) &lt;= 1,\n        .names = \"{str_remove(.col, '_elev')}_walkable\"\n      )\n    ) |&gt;\n    rename_with(.cols = c(up, down, left, right), ~ str_c(.x, \"_idx\")) |&gt;\n    select(source_idx = id, ends_with(c(\"idx\", \"walkable\")))\n\n  # Construct a list of edges\n  edge_list &lt;- neighbors |&gt;\n    pivot_longer(\n      !source_idx,\n      names_to = c(\"target_dir\", \".value\"),\n      names_sep = \"_\"\n    ) |&gt;\n    rename(\n      target_idx = idx,\n      target_walkable = walkable\n    ) |&gt;\n    filter(target_walkable == TRUE) |&gt;\n    pmap(function(source_idx, target_idx, ...) { c(source_idx, target_idx) }) |&gt;\n    unlist()\n\n  # Convert to a directed graph\n  g &lt;- make_empty_graph() |&gt;\n    add_vertices(length(df$id)) |&gt;\n    add_edges(edge_list)\n\n}\n\nshortest_path_length &lt;- function(g, source_idx, target_idx) {\n  shortest_paths(g, from = source_idx, to = target_idx)$vpath[[1]] |&gt;\n    length() - 1\n}\n\n\ng &lt;- df_to_graph(df)\n\n\n# Get the indices of the start and end vertices\nidx_start &lt;- match(\"S\", df$letter)\nidx_end   &lt;- match(\"E\", df$letter)\n\n# Compute shortest path from start to end\nshortest_path_length(g, idx_start, idx_end)\n\n[1] 462",
    "crumbs": [
      "2022",
      "Day 12"
    ]
  },
  {
    "objectID": "2022/R/day12.html#part-2",
    "href": "2022/R/day12.html#part-2",
    "title": "Day 12",
    "section": "Part 2",
    "text": "Part 2\n\n# Loop over all starting locations and find the shortest path to the end\nmin_dist &lt;- Inf\nfor (i in c(idx_start, which(df$letter == \"a\"))) {\n  cur &lt;- shortest_path_length(g, i, idx_end)\n  if (cur &gt;= 0 & cur &lt; min_dist) {\n    min_dist &lt;- cur\n  }\n}\nmin_dist\n\n[1] 451",
    "crumbs": [
      "2022",
      "Day 12"
    ]
  },
  {
    "objectID": "2022/R/day07.html",
    "href": "2022/R/day07.html",
    "title": "Day 7",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day07.txt\") |&gt; \n  enframe(name = NULL)",
    "crumbs": [
      "2022",
      "Day 7"
    ]
  },
  {
    "objectID": "2022/R/day07.html#setup",
    "href": "2022/R/day07.html#setup",
    "title": "Day 7",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day07.txt\") |&gt; \n  enframe(name = NULL)",
    "crumbs": [
      "2022",
      "Day 7"
    ]
  },
  {
    "objectID": "2022/R/day07.html#part-1",
    "href": "2022/R/day07.html#part-1",
    "title": "Day 7",
    "section": "Part 1",
    "text": "Part 1\n\ndir_sizes &lt;- input |&gt; \n  mutate(\n\n    # Determine path of each file by accumulating preceding cd terms\n    path = value |&gt;\n      str_extract(\"(?&lt;=^\\\\$ cd ).*\") |&gt;\n      str_c(\"/\") |&gt;\n      replace_na(\"\") |&gt;\n      accumulate(\n        ~ if (.y == \"../\") {\n          str_remove(.x, \"(?&lt;=/)[a-z]+/$\")\n        } else {\n          str_c(.x, .y)\n        }\n      ) |&gt;\n      str_remove_all(\"^/|/$\"),\n\n    # Convert paths to lists of all containing directories\n    dirs = path |&gt;\n      str_split(\"/\") |&gt;\n      map(~accumulate(.x, str_c, sep = \"/\"))\n  ) |&gt;\n\n  # Remove commands & directories from output and format file info as cols\n  filter(!str_detect(value, \"^\\\\$|dir \")) |&gt;\n  separate(value, into = c(\"size\", \"file\"), sep = \" \") |&gt;\n  mutate(size = as.integer(size)) |&gt;\n\n  # Convert nested lists of directories to long-format\n  unnest_wider(dirs, names_sep = \"_\") |&gt;\n  mutate(dirs_1 = \"/\") |&gt;\n  pivot_longer(\n    cols = matches(\"dirs_\\\\d+\"),\n    names_to = NULL,\n    values_to = \"dir\",\n    values_drop_na = TRUE\n  ) |&gt;\n\n  # Compute size of each directory\n  group_by(dir) |&gt;\n  summarize(size = sum(size)) |&gt;\n  ungroup()\n\nSum sizes of all directories with maximum size 100000:\n\ndir_sizes |&gt;\n  filter(size &lt;= 100000) |&gt;\n  pull(size) |&gt;\n  sum()\n\n[1] 1243729",
    "crumbs": [
      "2022",
      "Day 7"
    ]
  },
  {
    "objectID": "2022/R/day07.html#part-2",
    "href": "2022/R/day07.html#part-2",
    "title": "Day 7",
    "section": "Part 2",
    "text": "Part 2\nFind size of the smallest necessary directory to delete:\n\ncurr_system_size &lt;- dir_sizes |&gt;\n  filter(dir == \"/\") |&gt;\n  pull(size)\n\ndir_sizes |&gt;\n  filter(size &gt;= (30000000 - (70000000 - curr_system_size))) |&gt;\n  slice_min(size) |&gt;\n  pull(size)\n\n[1] 4443914",
    "crumbs": [
      "2022",
      "Day 7"
    ]
  },
  {
    "objectID": "2022/R/day05.html",
    "href": "2022/R/day05.html",
    "title": "Day 5",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\npath &lt;- \"../input/day05.txt\"\ninput &lt;- read_lines(path)",
    "crumbs": [
      "2022",
      "Day 5"
    ]
  },
  {
    "objectID": "2022/R/day05.html#setup",
    "href": "2022/R/day05.html#setup",
    "title": "Day 5",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\npath &lt;- \"../input/day05.txt\"\ninput &lt;- read_lines(path)",
    "crumbs": [
      "2022",
      "Day 5"
    ]
  },
  {
    "objectID": "2022/R/day05.html#part-1",
    "href": "2022/R/day05.html#part-1",
    "title": "Day 5",
    "section": "Part 1",
    "text": "Part 1\n\n# Format raw input\nmoves &lt;- input |&gt;\n  tail_while(~ .x != \"\") |&gt;\n  str_extract_all(\"\\\\d+\") |&gt;\n  map(as.integer)\n\nstacks &lt;- read_fwf(\n  path,\n  n_max = length(input) - length(moves) - 2,\n  col_types = \"c\"\n) |&gt;\n  mutate(across(everything(), ~ str_extract(.x, \"[A-Z]\"))) |&gt;\n  as.list() |&gt;\n  map(discard, is.na) |&gt;\n  map(rev)\n\nmove_crates &lt;- function(moves, stacks, func) {\n  \n  # Execute moves\n  for (curr_move in moves) {\n    count &lt;- curr_move[1]\n    from  &lt;- curr_move[2]\n    to    &lt;- curr_move[3]\n    \n    crates &lt;- func(tail(stacks[[from]], count))\n\n    stacks[[to]]   &lt;- append(stacks[[to]], crates)\n    stacks[[from]] &lt;- head(stacks[[from]], -1 * count)\n  }\n\n  # Examine final top row of crates\n  stacks |&gt;\n    map(~ tail(.x, 1)) |&gt;\n    str_c(collapse = \"\")\n}\n\n\nmove_crates(moves, stacks, rev)\n\n[1] \"RLFNRTNFB\"",
    "crumbs": [
      "2022",
      "Day 5"
    ]
  },
  {
    "objectID": "2022/R/day05.html#part-2",
    "href": "2022/R/day05.html#part-2",
    "title": "Day 5",
    "section": "Part 2",
    "text": "Part 2\n\nmove_crates(moves, stacks, identity)\n\n[1] \"MHQTLJRLB\"",
    "crumbs": [
      "2022",
      "Day 5"
    ]
  },
  {
    "objectID": "2022/R/day10.html",
    "href": "2022/R/day10.html",
    "title": "Day 10",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day10.txt\") |&gt;\n  enframe(name = \"cmd_num\")",
    "crumbs": [
      "2022",
      "Day 10"
    ]
  },
  {
    "objectID": "2022/R/day10.html#setup",
    "href": "2022/R/day10.html#setup",
    "title": "Day 10",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day10.txt\") |&gt;\n  enframe(name = \"cmd_num\")",
    "crumbs": [
      "2022",
      "Day 10"
    ]
  },
  {
    "objectID": "2022/R/day10.html#part-1",
    "href": "2022/R/day10.html#part-1",
    "title": "Day 10",
    "section": "Part 1",
    "text": "Part 1\n\nsignal &lt;- input |&gt;\n\n  # Convert multi-cycle commands into list of changes to X at each cycle\n  separate(value, into = c(\"cmd\", \"V\"), sep = \" \", convert = TRUE) |&gt;\n  transmute(cmd_num, v1 = 0, v2 = V) |&gt;\n  pivot_longer(\n    c(v1, v2),\n    names_to = \"cycle_count\",\n    values_to = \"x_change\",\n    values_drop_na = TRUE\n  ) |&gt;\n  pull(x_change) |&gt;\n\n  # Iterate through changes to X to get value of X during each cycle\n  accumulate(`+`, .init = 1) |&gt;\n  enframe(name = \"cycle\", value = \"X\") |&gt;\n  slice_head(n = -1)\n\n\n# Sum the signal strength at 20th cycle & every 40 cycles after that\nsignal |&gt;\n  filter(cycle %% 40 == 20) |&gt;\n  mutate(signal_strength = cycle * X) |&gt;\n  pull(signal_strength) |&gt;\n  sum()\n\n[1] 16020",
    "crumbs": [
      "2022",
      "Day 10"
    ]
  },
  {
    "objectID": "2022/R/day10.html#part-2",
    "href": "2022/R/day10.html#part-2",
    "title": "Day 10",
    "section": "Part 2",
    "text": "Part 2\n\n# Draw pixel when position of 3px-wide sprite overlaps w/ CRT position\nsignal |&gt;\n  mutate(\n    row = floor((cycle - 1) / 40),\n    col = (cycle - 1) %% 40\n  ) |&gt;\n  mutate(pixel = if_else(X &lt;= col + 1 & X &gt;= col - 1, \"#\", \".\")) |&gt;\n  group_by(row) |&gt;\n  summarize(val = str_c(pixel, collapse = \"\")) |&gt;\n  pull(val) |&gt;\n  cat(sep = \"\\n\")\n\n####..##..####.#..#.####..##..#....###..\n#....#..#....#.#..#....#.#..#.#....#..#.\n###..#......#..#..#...#..#..#.#....#..#.\n#....#.....#...#..#..#...####.#....###..\n#....#..#.#....#..#.#....#..#.#....#.#..\n####..##..####..##..####.#..#.####.#..#.",
    "crumbs": [
      "2022",
      "Day 10"
    ]
  },
  {
    "objectID": "2022/R/day04.html",
    "href": "2022/R/day04.html",
    "title": "Day 4",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_csv(\"../input/day04.txt\", col_names = FALSE)",
    "crumbs": [
      "2022",
      "Day 4"
    ]
  },
  {
    "objectID": "2022/R/day04.html#setup",
    "href": "2022/R/day04.html#setup",
    "title": "Day 4",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_csv(\"../input/day04.txt\", col_names = FALSE)",
    "crumbs": [
      "2022",
      "Day 4"
    ]
  },
  {
    "objectID": "2022/R/day04.html#parts-1-2",
    "href": "2022/R/day04.html#parts-1-2",
    "title": "Day 4",
    "section": "Parts 1 & 2",
    "text": "Parts 1 & 2\n\ninput |&gt;  \n  separate(X1, into = c(\"start1\", \"end1\"), sep = \"-\", convert = TRUE) |&gt;\n  separate(X2, into = c(\"start2\", \"end2\"), sep = \"-\", convert = TRUE) |&gt;\n  mutate(\n    range1 = map2(start1, end1, ~ .x:.y),\n    range2 = map2(start2, end2, ~ .x:.y),\n    contained = map2_lgl(range1, range2, ~ all(.x %in% .y) | all(.y %in% .x)),\n    overlap   = map2_lgl(range1, range2, ~ length(intersect(.x, .y)) &gt; 0)\n  ) |&gt;\n  summarize(num_contained = sum(contained), num_overlap = sum(overlap))\n\n# A tibble: 1 × 2\n  num_contained num_overlap\n          &lt;int&gt;       &lt;int&gt;\n1           550         931",
    "crumbs": [
      "2022",
      "Day 4"
    ]
  },
  {
    "objectID": "2022/R/day11.html",
    "href": "2022/R/day11.html",
    "title": "Day 11",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day11.txt\") |&gt;\n  trimws() |&gt;\n  discard(~ .x == \"\")",
    "crumbs": [
      "2022",
      "Day 11"
    ]
  },
  {
    "objectID": "2022/R/day11.html#setup",
    "href": "2022/R/day11.html#setup",
    "title": "Day 11",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day11.txt\") |&gt;\n  trimws() |&gt;\n  discard(~ .x == \"\")",
    "crumbs": [
      "2022",
      "Day 11"
    ]
  },
  {
    "objectID": "2022/R/day11.html#part-1",
    "href": "2022/R/day11.html#part-1",
    "title": "Day 11",
    "section": "Part 1",
    "text": "Part 1\n\n# Reformat input\nitems &lt;- str_match(input, \"Starting items:(.*)\")[,2] |&gt;\n  discard(is.na) |&gt;\n  str_split(\",\") |&gt;\n  map(parse_number)\n\noperations &lt;- input |&gt;\n  keep(~ str_detect(.x, \"Operation:\")) |&gt;\n  str_replace(\"Operation: new = \", \"~ \") |&gt;\n  str_replace_all(\"old\", \".x\") |&gt;\n  map(~ rlang::as_function(as.formula(.x)))\n\ndiv  &lt;- parse_number(keep(input, ~ str_detect(.x, \"Test:\")))\ndivt &lt;- parse_number(keep(input, ~ str_detect(.x, \"If true:\")))\ndivf &lt;- parse_number(keep(input, ~ str_detect(.x, \"If false:\")))\n\ntest &lt;- pmap(\n  list(div, divt, divf),\n  ~ function(x) if_else(x %% ..1 == 0, ..2 + 1, ..3 + 1)\n)\n\nnum_monkeys &lt;- length(input) / 6\n\n\ncompute_monkey_business &lt;- function(num_rounds, worry_func) {\n  # Initialize\n  activity &lt;- rep(0, num_monkeys)\n\n  # Perform the tosses\n  for (round in 1:num_rounds) {\n    for (monkey in 1:num_monkeys) {\n      for (item in items[[monkey]]) {\n        worry &lt;- worry_func(operations[[monkey]](item))\n        toss  &lt;- test[[monkey]](worry)\n        items[[toss]] &lt;- c(items[[toss]], worry)\n      }\n      activity[[monkey]] &lt;- activity[[monkey]] + length(items[[monkey]])\n      items[[monkey]] &lt;- numeric(0)\n    }\n  }\n\n  # Compute monkey business score\n  activity |&gt;\n    sort() |&gt;\n    tail(2) |&gt;\n    reduce(`*`)\n}\n\n\ncompute_monkey_business(num_rounds = 20, worry_func = \\(x) floor(x / 3))\n\n[1] 78678",
    "crumbs": [
      "2022",
      "Day 11"
    ]
  },
  {
    "objectID": "2022/R/day11.html#part-2",
    "href": "2022/R/day11.html#part-2",
    "title": "Day 11",
    "section": "Part 2",
    "text": "Part 2\n\nlcm &lt;- DescTools::LCM(div)\ncompute_monkey_business(num_rounds = 10000, worry_func = \\(x) x %% lcm)\n\n[1] 15333249714",
    "crumbs": [
      "2022",
      "Day 11"
    ]
  },
  {
    "objectID": "2022/R/day13.html",
    "href": "2022/R/day13.html",
    "title": "Day 13",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input into a data frame and convert to indexed nested lists\ndf &lt;- read_table(\"../input/day13.txt\", col_names = \"txt\") |&gt; \n  mutate(\n    row_id   = row_number(),\n    group_id = floor((row_id - 1) / 2) + 1,\n    item_id  = (row_id - 1) %% 2 + 1,\n    lst      = map(txt, jsonlite::fromJSON, simplifyVector = FALSE)\n  )",
    "crumbs": [
      "2022",
      "Day 13"
    ]
  },
  {
    "objectID": "2022/R/day13.html#setup",
    "href": "2022/R/day13.html#setup",
    "title": "Day 13",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input into a data frame and convert to indexed nested lists\ndf &lt;- read_table(\"../input/day13.txt\", col_names = \"txt\") |&gt; \n  mutate(\n    row_id   = row_number(),\n    group_id = floor((row_id - 1) / 2) + 1,\n    item_id  = (row_id - 1) %% 2 + 1,\n    lst      = map(txt, jsonlite::fromJSON, simplifyVector = FALSE)\n  )",
    "crumbs": [
      "2022",
      "Day 13"
    ]
  },
  {
    "objectID": "2022/R/day13.html#part-1",
    "href": "2022/R/day13.html#part-1",
    "title": "Day 13",
    "section": "Part 1",
    "text": "Part 1\nDefine a function to compare nested lists:\n\ncompare_nested &lt;- function(a, b) {\n\n  # Compare if both inputs are numeric\n  if (is.numeric(a) & is.numeric(b)) {\n    if (a &lt; b)  return(-1)\n    if (a &gt; b)  return(1)\n    if (a == b) return(0)\n  }\n\n  # Compare if only one input is numeric\n  if (is.numeric(a) != is.numeric(b)) {\n    if (is.numeric(a))\n      return(compare_nested(list(a), b))\n    if (is.numeric(b))\n      return(compare_nested(a, list(b)))\n  }\n\n  # Compare if both inputs are lists\n  i &lt;- 1\n  while (i &lt;= min(length(a), length(b))) {\n    result &lt;- compare_nested(a[[i]], b[[i]])\n    if (result %in% c(1, -1))\n      return(result)\n    i &lt;- i + 1\n  }\n  # When all comparable values are equal, compare lengths\n  return(compare_nested(length(a), length(b)))\n}\n\nSum the indices of packet pairs that are in order:\n\ndf |&gt;\n  select(group_id, item_id, lst) |&gt;\n  pivot_wider(\n    names_from = item_id,\n    names_prefix = \"item_\",\n    values_from = lst\n  ) |&gt;\n  mutate(comparison = map2_int(item_1, item_2, compare_nested)) |&gt;\n  filter(comparison == -1) |&gt;\n  pull(group_id) |&gt; \n  sum()\n\n[1] 5684",
    "crumbs": [
      "2022",
      "Day 13"
    ]
  },
  {
    "objectID": "2022/R/day13.html#part-2",
    "href": "2022/R/day13.html#part-2",
    "title": "Day 13",
    "section": "Part 2",
    "text": "Part 2\nDefine a function to determine the pairwise order of nested lists:\n\nsort_nested &lt;- function(lst) {\n  n &lt;- length(lst)\n  indices &lt;- 1:n\n\n  if (n == 0) return()\n  if (n == 1) return(indices)\n\n  # Bubble sort: loop through list and swap elements until sorted\n  repeat {\n    swap_occurred &lt;- FALSE\n    for (i in 1:(n - 1)) {\n      j1 &lt;- which(indices == i)\n      j2 &lt;- which(indices == i + 1)\n      if (compare_nested(lst[[j1]], lst[[j2]]) == 1) {\n        indices[j1] &lt;- i + 1\n        indices[j2] &lt;- i\n        swap_occurred &lt;- TRUE\n      }\n    }\n    if (!swap_occurred) break\n  }\n  return(indices)\n}\n\nAdd new flagged packets, sort all, and multiply flagged indices:\n\nnew_packets &lt;- list(\"[[2]]\", \"[[6]]\") |&gt;\n  map(jsonlite::fromJSON, simplifyVector = FALSE) |&gt;\n  as_tibble_col(column_name = \"lst\")\n\ndf |&gt;\n  transmute(lst, flag = FALSE) |&gt;\n  add_row(new_packets, flag = TRUE) |&gt;\n  mutate(ord = sort_nested(lst)) |&gt;\n  filter(flag) |&gt;\n  pull(ord) |&gt; \n  prod()\n\n[1] 22932",
    "crumbs": [
      "2022",
      "Day 13"
    ]
  },
  {
    "objectID": "2022/R/day06.html",
    "href": "2022/R/day06.html",
    "title": "Day 6",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day06.txt\") |&gt;\n  str_split_1(\"\") |&gt;\n  enframe(name = \"idx\", value = \"char\")",
    "crumbs": [
      "2022",
      "Day 6"
    ]
  },
  {
    "objectID": "2022/R/day06.html#setup",
    "href": "2022/R/day06.html#setup",
    "title": "Day 6",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day06.txt\") |&gt;\n  str_split_1(\"\") |&gt;\n  enframe(name = \"idx\", value = \"char\")",
    "crumbs": [
      "2022",
      "Day 6"
    ]
  },
  {
    "objectID": "2022/R/day06.html#part-1",
    "href": "2022/R/day06.html#part-1",
    "title": "Day 6",
    "section": "Part 1",
    "text": "Part 1\n\nfind_marker &lt;- function(df, marker_length) {\n  df |&gt; \n    # Construct sequences of next n chars and count # of unique chars in each\n    transmute(\n      marker_idx = idx + marker_length - 1,\n      char_seq = reduce(\n        .x = map(0:(marker_length - 1), ~ lead(char, n = .x)),\n        .f = str_c\n      ),\n      n_unique = map_int(\n        char_seq,\n        ~ .x |&gt;\n          str_split(\"\") |&gt;\n          unlist() |&gt;\n          unique() |&gt;\n          length()\n      )\n    ) |&gt;\n\n    # Extract first instance where all n chars are unique\n    filter(n_unique == marker_length) |&gt;\n    pull(marker_idx) |&gt;\n    min()\n}\n\n\nfind_marker(input, marker_length = 4)\n\n[1] 1802",
    "crumbs": [
      "2022",
      "Day 6"
    ]
  },
  {
    "objectID": "2022/R/day06.html#part-2",
    "href": "2022/R/day06.html#part-2",
    "title": "Day 6",
    "section": "Part 2",
    "text": "Part 2\n\nfind_marker(input, marker_length = 14)\n\n[1] 3551",
    "crumbs": [
      "2022",
      "Day 6"
    ]
  },
  {
    "objectID": "2022/R/day16.html",
    "href": "2022/R/day16.html",
    "title": "Day 16",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\n    c(\n      \"Valve {source} has flow rate={rate}; tunnels lead to valves {target}\",\n      \"Valve {source} has flow rate={rate}; tunnel leads to valve {target}\"\n    ),\n    convert = TRUE\n  ) |&gt; \n  mutate(target = map(target, \\(x) str_split_1(x, \", \")))",
    "crumbs": [
      "2022",
      "Day 16"
    ]
  },
  {
    "objectID": "2022/R/day16.html#setup",
    "href": "2022/R/day16.html#setup",
    "title": "Day 16",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\n    c(\n      \"Valve {source} has flow rate={rate}; tunnels lead to valves {target}\",\n      \"Valve {source} has flow rate={rate}; tunnel leads to valve {target}\"\n    ),\n    convert = TRUE\n  ) |&gt; \n  mutate(target = map(target, \\(x) str_split_1(x, \", \")))",
    "crumbs": [
      "2022",
      "Day 16"
    ]
  },
  {
    "objectID": "2022/R/day16.html#part-1",
    "href": "2022/R/day16.html#part-1",
    "title": "Day 16",
    "section": "Part 1",
    "text": "Part 1\nRepresent tunnels and valves as a graph:\n\ng &lt;- input |&gt;\n  unnest(target) |&gt; \n  pmap(function(source, target, ...) c(source, target)) |&gt; \n  unique() |&gt; \n  unlist() |&gt; \n  make_graph(directed = TRUE) |&gt; \n  as_undirected()\n\nGet the list of valves with nonzero flow:\n\nflows &lt;- input |&gt; \n  filter(rate &gt; 0 | source == \"AA\") |&gt; \n  select(source, rate) |&gt; \n  deframe()\n\nnon_init_flows &lt;- flows |&gt; \n  discard_at(\"AA\")\n\nvalves &lt;- names(flows)\n\ndists &lt;- distances(g, valves, valves)\n\nList all permutations of possible valves to visit with a total distance less than 30:\n\nget_path &lt;- function(choices, last, cur_length, max_length) {\n  if (cur_length &gt;= max_length)\n    return(head(last, -1))\n  if (length(choices) == 0)\n    return(last)\n  \n  ls &lt;- list()\n  for (valve in choices) {\n    ls &lt;- append(\n      ls, \n      list(get_path(\n        choices[choices != valve], \n        c(last, valve), \n        cur_length + dists[tail(last, 1), valve] + 1,\n        max_length\n      ))\n    )\n  }\n  ls |&gt; \n    discard(is_null) |&gt; \n    list_flatten() |&gt; \n    unique()\n}\n\ncombos &lt;- get_path(names(non_init_flows), names(flows[\"AA\"]), 0, 30)\n\nCompute total pressure released for each permutation:\n\nget_pressures &lt;- function(paths, max_time) {\n  map_dbl(paths, \\(path) {\n    valve      &lt;- tail(path, -1)\n    valve_lag  &lt;- head(path, -1)\n    flow       &lt;- tail(flows[path], -1)\n    \n    dist       &lt;- map2_int(valve_lag, valve, \\(src, target) dists[src, target])\n    time_start &lt;- cumsum(dist) + 1:length(dist) + 1\n    pressure   &lt;- (max_time - time_start + 1) * flow\n    \n    sum(pressure[time_start &lt;= max_time])\n  })\n}\n\npressures &lt;- get_pressures(combos, 30)\n\nFind the permutation that gives the maximum pressure:\n\nmax_idx &lt;- which.max(pressures)\npressures[max_idx]\n\n[1] 1947",
    "crumbs": [
      "2022",
      "Day 16"
    ]
  },
  {
    "objectID": "2022/R/day16.html#part-2",
    "href": "2022/R/day16.html#part-2",
    "title": "Day 16",
    "section": "Part 2",
    "text": "Part 2\nList all permutations of possible valves to visit with a total distance less than 26:\n\nel_combos    &lt;- get_path(names(non_init_flows), names(flows[\"AA\"]), 0, 26)\nel_pressures &lt;- get_pressures(el_combos, 26)\n\nFor each set of permutations, get the best pressure.\n\nel_best &lt;- tibble(valves = map(el_combos, sort), pressure = el_pressures) |&gt; \n  slice_max(pressure, by = valves, with_ties = FALSE)\n\nGet best combinations of permutations between yourself and the elephant:\n\nel_best |&gt; \n  rename(el_valves = valves, el_pressure = pressure) |&gt; \n  pmap_dbl(\\(el_valves, el_pressure) {\n    el_valves &lt;- el_valves[el_valves != \"AA\"]\n    el_pressure + el_best |&gt;\n      filter(map_lgl(valves, ~ length(intersect(.x, el_valves)) == 0)) |&gt; \n      pull(pressure) |&gt; \n      max()\n  }) |&gt; \n  max()\n\n[1] 2556",
    "crumbs": [
      "2022",
      "Day 16"
    ]
  },
  {
    "objectID": "2022/R/day03.html",
    "href": "2022/R/day03.html",
    "title": "Day 3",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_table(\"../input/day03.txt\", col_names = \"str\")",
    "crumbs": [
      "2022",
      "Day 3"
    ]
  },
  {
    "objectID": "2022/R/day03.html#setup",
    "href": "2022/R/day03.html#setup",
    "title": "Day 3",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_table(\"../input/day03.txt\", col_names = \"str\")",
    "crumbs": [
      "2022",
      "Day 3"
    ]
  },
  {
    "objectID": "2022/R/day03.html#part-1",
    "href": "2022/R/day03.html#part-1",
    "title": "Day 3",
    "section": "Part 1",
    "text": "Part 1\n\ninput |&gt;\n  mutate(\n    # Separate each line into two compartments\n    str_length = str_length(str) / 2,\n    str_1 = str_sub(str, start = 1L, end = str_length),\n    str_2 = str_sub(str, start = str_length + 1, end = -1L),\n\n    # Find the letter in common between each pair of compartments\n    across(c(str_1, str_2), ~ str_split(.x, \"\")),\n    dup = map2_chr(str_1, str_2, ~ intersect(.x, .y)),\n\n    # Convert to priority value\n    priority = match(dup, c(letters, LETTERS))\n  ) |&gt;\n\n  # Compute total sum\n  pull(priority) |&gt;\n  sum()\n\n[1] 8252",
    "crumbs": [
      "2022",
      "Day 3"
    ]
  },
  {
    "objectID": "2022/R/day03.html#part-2",
    "href": "2022/R/day03.html#part-2",
    "title": "Day 3",
    "section": "Part 2",
    "text": "Part 2\n\ninput |&gt;\n\n  # Reshape to one row per group, one column per elf\n  mutate(\n    str = str_split(str, \"\"),\n    group_num = floor((row_number() - 1) / 3),\n    elf_num = as.character(row_number() %% 3)\n  ) |&gt;\n  pivot_wider(names_from = elf_num, values_from = str, names_prefix = \"elf_\") |&gt;\n\n  # Find the character in common between all 3 elves & convert to priority val\n  mutate(\n    dup = pmap_chr(\n      list(elf_0, elf_1, elf_2),\n      ~ reduce(list(..1, ..2, ..3), intersect)\n    ),\n    priority = match(dup, c(letters, LETTERS))\n  ) |&gt;\n\n  # Compute total sum\n  pull(priority) |&gt;\n  sum()\n\n[1] 2828",
    "crumbs": [
      "2022",
      "Day 3"
    ]
  },
  {
    "objectID": "2022/R/day01.html",
    "href": "2022/R/day01.html",
    "title": "Day 1",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day01.txt\") |&gt; \n  as.integer()",
    "crumbs": [
      "2022",
      "Day 1"
    ]
  },
  {
    "objectID": "2022/R/day01.html#setup",
    "href": "2022/R/day01.html#setup",
    "title": "Day 1",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day01.txt\") |&gt; \n  as.integer()",
    "crumbs": [
      "2022",
      "Day 1"
    ]
  },
  {
    "objectID": "2022/R/day01.html#part-1",
    "href": "2022/R/day01.html#part-1",
    "title": "Day 1",
    "section": "Part 1",
    "text": "Part 1\n\n# Format input as a data frame and number the elves\ndf &lt;- tibble(\n  cal = input,\n  elf_id = cumsum(is.na(cal)) + 1\n) |&gt;\n  filter(!is.na(cal))\n\n# Compute calorie sum for each elf, get the top n elves, and combine totals\ncount_max &lt;- function(df, num_top_elves) {\n  df |&gt; \n    group_by(elf_id) |&gt;\n    summarize(total_cal = sum(cal)) |&gt;\n    slice_max(total_cal, n = num_top_elves) |&gt;\n    pull(total_cal) |&gt;\n    sum()\n}\n\nRun puzzle input:\n\ncount_max(df, 1)\n\n[1] 68787",
    "crumbs": [
      "2022",
      "Day 1"
    ]
  },
  {
    "objectID": "2022/R/day01.html#part-2",
    "href": "2022/R/day01.html#part-2",
    "title": "Day 1",
    "section": "Part 2",
    "text": "Part 2\n\ncount_max(df, 3)\n\n[1] 198041",
    "crumbs": [
      "2022",
      "Day 1"
    ]
  },
  {
    "objectID": "2022/R/day25.html",
    "href": "2022/R/day25.html",
    "title": "Day 25",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day25.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 25"
    ]
  },
  {
    "objectID": "2022/R/day25.html#setup",
    "href": "2022/R/day25.html#setup",
    "title": "Day 25",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day25.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2022",
      "Day 25"
    ]
  },
  {
    "objectID": "2022/R/day25.html#part-1",
    "href": "2022/R/day25.html#part-1",
    "title": "Day 25",
    "section": "Part 1",
    "text": "Part 1\nConvert “snafu” strings to decimal numbers:\n\nsnafu_to_dbl &lt;- function(snafu) {\n  snafu |&gt; \n    str_split(\"\") |&gt; \n    map(~ case_match(rev(.x), \"2\" ~ 2, \"1\" ~ 1, \"0\" ~ 0, \"-\" ~ -1, \"=\" ~ -2)) |&gt; \n    map(~ .x * 5^(0:(length(.x) - 1))) |&gt; \n    map_dbl(sum)\n}\n\nConvert decimal numbers to “snafu” strings:\n\ndbl_to_snafu &lt;- function(x) {\n  output &lt;- c()\n\n  repeat {\n    output &lt;- c((x + 2) %% 5 - 2, output)\n    x &lt;- floor((x + 2) / 5)\n    \n    if (x == 0) break\n  }\n  \n  output |&gt; \n    case_match(2 ~ '2', 1 ~ '1', 0 ~ '0', -1 ~ '-', -2 ~ '=') |&gt; \n    str_c(collapse = \"\")\n}\n\nRun on puzzle input:\n\ninput |&gt; \n  snafu_to_dbl() |&gt; \n  sum() |&gt; \n  dbl_to_snafu()\n\n[1] \"122-12==0-01=00-0=02\"",
    "crumbs": [
      "2022",
      "Day 25"
    ]
  },
  {
    "objectID": "2022/R/day18.html",
    "href": "2022/R/day18.html",
    "title": "Day 18",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day18.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\"{x},{y},{z}\", convert = TRUE) |&gt; \n  mutate(id = row_number(), .before = everything())",
    "crumbs": [
      "2022",
      "Day 18"
    ]
  },
  {
    "objectID": "2022/R/day18.html#setup",
    "href": "2022/R/day18.html#setup",
    "title": "Day 18",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day18.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\"{x},{y},{z}\", convert = TRUE) |&gt; \n  mutate(id = row_number(), .before = everything())",
    "crumbs": [
      "2022",
      "Day 18"
    ]
  },
  {
    "objectID": "2022/R/day18.html#part-1",
    "href": "2022/R/day18.html#part-1",
    "title": "Day 18",
    "section": "Part 1",
    "text": "Part 1\nCreate a containing box for the set of cubes, padded by 1 voxel of air in each direction, and convert the full rectangular area into a graph:\n\nxrange &lt;- (min(input$x) - 1):(max(input$x) + 1)\nyrange &lt;- (min(input$y) - 1):(max(input$y) + 1)\nzrange &lt;- (min(input$z) - 1):(max(input$z) + 1)\n\n# Fill out each coordinate of the containing box with air\ncontainer &lt;- input |&gt; \n  mutate(type = \"cube\") |&gt; \n  complete(x = xrange, y = yrange, z = zrange, fill = list(type = \"air\")) |&gt; \n  mutate(id = row_number())\n\n# For each coordinate, create edges between adjacent coords of the same type\nedges &lt;- container |&gt;\n  arrange(x, y, z) |&gt; \n  mutate(\n    edge_x1 = case_when(type == lag(type)  ~ lag(id)),\n    edge_x2 = case_when(type == lead(type) ~ lead(id)),\n    .by = c(y, z)\n  ) |&gt; \n  mutate(\n    edge_y1 = case_when(type == lag(type)  ~ lag(id)),\n    edge_y2 = case_when(type == lead(type) ~ lead(id)),\n    .by = c(x, z)\n  ) |&gt; \n  mutate(\n    edge_z1 = case_when(type == lag(type)  ~ lag(id)),\n    edge_z2 = case_when(type == lead(type) ~ lead(id)),\n    .by = c(x, y)\n  ) |&gt; \n  mutate(across(starts_with(\"edge\"), \\(col) {\n    case_when(!is.na(col) ~ map2(id, col, ~ c(.x, .y)))\n  })) |&gt; \n  select(starts_with(\"edge\")) |&gt; \n  pivot_longer(everything()) |&gt; \n  pull(value) |&gt; \n  unlist()\n\n\n# Convert to a graph\ng &lt;- make_graph(edges = edges, n = max(container$id), directed = TRUE) |&gt; \n  as_undirected()\n\nCompute the surface area of the cubes. Start by giving every cube a surface area of 6, then subtract the cube’s vertex degree (which is the number of adjacent cubes):\n\n# Get the vertex IDs of all cubes\ncube_ids &lt;- container |&gt; \n  filter(type == \"cube\") |&gt; \n  pull(id)\n\n# Compute the surface area of all cubes\ng |&gt; \n  degree() |&gt; \n  keep_at(cube_ids) |&gt; \n  map_dbl(~ 6 - .x) |&gt; \n  sum()\n\n[1] 3470",
    "crumbs": [
      "2022",
      "Day 18"
    ]
  },
  {
    "objectID": "2022/R/day18.html#part-2",
    "href": "2022/R/day18.html#part-2",
    "title": "Day 18",
    "section": "Part 2",
    "text": "Part 2\nTo compute the external surface area, we compute the total surface area of the outermost containing box of air, then subtract away its known rectangular external surface area.\n\n# First vertex is external air padding, so we pull all vertices having its group\noutside_ids &lt;- which(components(g)$membership == components(g)$membership[1])\n\n# Compute the surface area of the external air voxels using their vertex degree\ntotal_sa &lt;- g |&gt; \n  degree() |&gt; \n  keep_at(outside_ids) |&gt; \n  map_dbl(~ 6 - .x) |&gt; \n  sum()\n\n# Compute the outer surface of the bounding box\nxlen &lt;- max(xrange) - min(xrange) + 1\nylen &lt;- max(yrange) - min(yrange) + 1\nzlen &lt;- max(zrange) - min(zrange) + 1\nbounding_sa &lt;- 2 * (xlen * ylen + xlen * zlen + ylen * zlen)\n\n# Subtract the outer surface area from the total surface area of the air padding\ntotal_sa - bounding_sa\n\n[1] 1986",
    "crumbs": [
      "2022",
      "Day 18"
    ]
  },
  {
    "objectID": "2022/R/day23.html",
    "href": "2022/R/day23.html",
    "title": "Day 23",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day23.txt\", skip_empty_rows = TRUE) |&gt; \n  enframe(name = \"row\") |&gt; \n  mutate(value = map(value, ~ enframe(str_split_1(.x, \"\"), name = \"col\"))) |&gt; \n  unnest(value)",
    "crumbs": [
      "2022",
      "Day 23"
    ]
  },
  {
    "objectID": "2022/R/day23.html#setup",
    "href": "2022/R/day23.html#setup",
    "title": "Day 23",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day23.txt\", skip_empty_rows = TRUE) |&gt; \n  enframe(name = \"row\") |&gt; \n  mutate(value = map(value, ~ enframe(str_split_1(.x, \"\"), name = \"col\"))) |&gt; \n  unnest(value)",
    "crumbs": [
      "2022",
      "Day 23"
    ]
  },
  {
    "objectID": "2022/R/day23.html#part-1",
    "href": "2022/R/day23.html#part-1",
    "title": "Day 23",
    "section": "Part 1",
    "text": "Part 1\nConvert map to a list of positions for each elf, using complex numbers to store 2D coords:\n\nelves &lt;- input |&gt; \n  filter(value == \"#\") |&gt; \n  mutate(z = complex(real = col, imaginary = row)) |&gt; \n  pull(z)\n\nDefine function to move elves in each round:\n\ncardinal_dirs &lt;- c(\n  n  =  0 - 1i,\n  s  =  0 + 1i,\n  w  = -1 + 0i,\n  e  =  1 + 0i,\n  nw = -1 - 1i,\n  ne =  1 - 1i,\n  sw = -1 + 1i,\n  se =  1 + 1i\n)\n\nadjacent_dirs &lt;- list(\n  n = c(\"n\", \"nw\", \"ne\"),\n  s = c(\"s\", \"sw\", \"se\"),\n  w = c(\"w\", \"nw\", \"sw\"),\n  e = c(\"e\", \"ne\", \"se\")\n)\n\nmove_elves &lt;- function(elves, round_num) {\n\n  # Determine which neighboring cells are occupied\n  neighbors &lt;- map(cardinal_dirs, \\(dir) elves + dir)\n  occupied  &lt;- map(neighbors, ~ .x %in% elves)\n  \n  # Determine which n/s/w/e moves are valid\n  valid &lt;- map(adjacent_dirs, \\(dir_set) {\n    dir_set |&gt; \n      map(~!occupied[[.x]]) |&gt; \n      reduce(`&`)\n  })\n  \n  # Re-order the n/s/w/e priority according to the current round number\n  valid &lt;- valid[(1:4 + round_num - 2) %% 4 + 1]\n  \n  # For all elves not surrounded by empty cells, determine their proposed move\n  all_borders_empty &lt;- reduce(valid, `&`)\n  proposals &lt;- valid |&gt; \n    imap(\\(vec, dir) case_when(vec ~ neighbors[[dir]])) |&gt;\n    pmap(\n      ~ c(discard(c(..1, ..2, ..3, ..4), is.na), NA) |&gt; \n        head(1)\n    ) |&gt; \n    unlist() |&gt; \n    modify_if(all_borders_empty, ~ NA)\n  \n  # Nullify any colliding proposed moves\n  collisions &lt;- na.omit(proposals)[duplicated(na.omit(proposals))]\n  movements &lt;- if_else(proposals %in% collisions, NA, proposals)\n  \n  # Return the new elf coordinates\n  coalesce(movements, elves)\n}\n\nDefine a function to compute the area of the bounding box then subtract away the number of elves:\n\nn_empty_tiles &lt;- function(elves) {\n  height &lt;- 1 + diff(range(Im(elves)))\n  width  &lt;- 1 + diff(range(Re(elves)))\n  \n  height * width - length(elves)\n}\n\nRun 10 rounds on puzzle input:\n\nreduce(1:10, move_elves, .init = elves) |&gt; \n  n_empty_tiles()\n\n[1] 3996",
    "crumbs": [
      "2022",
      "Day 23"
    ]
  },
  {
    "objectID": "2022/R/day23.html#part-2",
    "href": "2022/R/day23.html#part-2",
    "title": "Day 23",
    "section": "Part 2",
    "text": "Part 2\nRun until no further movements occur:\n\ni &lt;- 1\ncur_elves &lt;- elves\n\nrepeat {\n  new_elves &lt;- move_elves(cur_elves, i)\n  \n  if (all(new_elves == cur_elves)) break\n  \n  cur_elves &lt;- new_elves\n  i &lt;- i + 1\n}\n\ni\n\n[1] 908",
    "crumbs": [
      "2022",
      "Day 23"
    ]
  },
  {
    "objectID": "2022/R/day08.html",
    "href": "2022/R/day08.html",
    "title": "Day 8",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file and format as a matrix\ninput &lt;- read_fwf(\"../input/day08.txt\") |&gt; \n  transmute(x = str_split(X1, \"\")) |&gt;\n  unnest_wider(x, names_sep = \"\") |&gt;\n  mutate(across(everything(), as.integer)) |&gt;\n  as.matrix()",
    "crumbs": [
      "2022",
      "Day 8"
    ]
  },
  {
    "objectID": "2022/R/day08.html#setup",
    "href": "2022/R/day08.html#setup",
    "title": "Day 8",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file and format as a matrix\ninput &lt;- read_fwf(\"../input/day08.txt\") |&gt; \n  transmute(x = str_split(X1, \"\")) |&gt;\n  unnest_wider(x, names_sep = \"\") |&gt;\n  mutate(across(everything(), as.integer)) |&gt;\n  as.matrix()",
    "crumbs": [
      "2022",
      "Day 8"
    ]
  },
  {
    "objectID": "2022/R/day08.html#parts-1-2",
    "href": "2022/R/day08.html#parts-1-2",
    "title": "Day 8",
    "section": "Parts 1 & 2",
    "text": "Parts 1 & 2\n\n# Create df with one row per tree and variables for its containing row & col\nexpand_grid(\n  col_pos = 1:nrow(input),\n  row_pos = 1:ncol(input)\n) |&gt;\n  mutate(\n    tree_idx = row_number(),\n    row_list = map(col_pos, ~ unname(as.matrix(input)[.x, ])),\n    col_list = map(row_pos, ~ unname(as.matrix(input)[, .x])),\n  ) |&gt;\n\n  # For each tree, construct its treeline looking outward in each direction\n  pivot_longer(\n    c(col_pos, row_pos, col_list, row_list),\n    names_to = c(\"axis\", \".value\"),\n    names_sep = \"_\"\n  ) |&gt;\n  mutate(\n    split = map2(\n      list,\n      pos,\n      ~ split(.x, c(rep(\"bwd\", .y - 1), \"curr_tree\", rep(\"fwd\", length(.x) - .y)))\n    )\n  ) |&gt;\n  unnest_wider(split) |&gt;\n  mutate(bwd = map(bwd, rev)) |&gt;\n  pivot_longer(c(fwd, bwd), names_to = \"dir\", values_to = \"treeline\") |&gt;\n\n  # Check if each is the tallest tree in each direction & count visible trees\n  mutate(\n    is_tallest = map2_lgl(curr_tree, treeline, ~ all(.x &gt; .y)),\n    num_visible = map2_int(curr_tree, treeline, function(curr_tree, treeline) {\n      ifelse(\n        every(treeline, ~.x &lt; curr_tree),\n        length(treeline),\n        detect_index(treeline, ~ .x &gt;= curr_tree)\n      )\n    })\n  ) |&gt;\n\n  # Summarize visibility & scenic scores from all 4 directions for each tree\n  group_by(tree_idx) |&gt;\n  summarize(\n    is_visible = any(is_tallest),\n    scenic_score = prod(num_visible)\n  ) |&gt;\n  ungroup() |&gt;\n\n  # Compute total trees visible from forest edge & max scenic score in forest\n  summarize(\n    total_visible = sum(is_visible),\n    max_scenic_score = max(scenic_score)\n  )\n\n# A tibble: 1 × 2\n  total_visible max_scenic_score\n          &lt;int&gt;            &lt;dbl&gt;\n1          1690           535680",
    "crumbs": [
      "2022",
      "Day 8"
    ]
  },
  {
    "objectID": "2022/R/day21.html",
    "href": "2022/R/day21.html",
    "title": "Day 21",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day21.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\n    patterns = c(\n      \"{monkey}: {input_1} {operation} {input_2}\",\n      \"{monkey}: {number}\"\n    ),\n    convert = TRUE\n  )",
    "crumbs": [
      "2022",
      "Day 21"
    ]
  },
  {
    "objectID": "2022/R/day21.html#setup",
    "href": "2022/R/day21.html#setup",
    "title": "Day 21",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day21.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue::unglue_data(\n    patterns = c(\n      \"{monkey}: {input_1} {operation} {input_2}\",\n      \"{monkey}: {number}\"\n    ),\n    convert = TRUE\n  )",
    "crumbs": [
      "2022",
      "Day 21"
    ]
  },
  {
    "objectID": "2022/R/day21.html#part-1",
    "href": "2022/R/day21.html#part-1",
    "title": "Day 21",
    "section": "Part 1",
    "text": "Part 1\nIteratively apply each monkey-to-monnkey operation until complete:\n\nnumbers &lt;- input |&gt; \n  select(monkey, number) |&gt; \n  deframe()\n\neqns &lt;- input |&gt; \n  filter(!is.na(operation)) |&gt; \n  select(-number)\n\ncompute_monkeys &lt;- function(numbers, eqns) {\n  repeat {\n    new_values &lt;- eqns |&gt; \n      mutate(\n        value_1 = numbers[input_1],\n        value_2 = numbers[input_2]\n      ) |&gt; \n      drop_na(value_1, value_2) |&gt; \n      mutate(output = pmap_dbl(\n        list(operation, value_1, value_2), \n        ~ get(..1)(..2, ..3)\n      )) |&gt; \n      select(monkey, output) |&gt; \n      deframe()\n    \n    if (length(new_values) == 0) {\n      break\n    } else {\n      numbers[names(new_values)] &lt;- new_values\n      eqns &lt;- filter(eqns, !(monkey %in% names(new_values)))\n    }\n  }\n  \n  numbers\n}\n\nRun on puzzle input:\n\ncompute_monkeys(numbers, eqns) |&gt; \n  keep_at(\"root\") |&gt;  \n  format(scientific = FALSE)\n\n            root \n\"87457751482938\"",
    "crumbs": [
      "2022",
      "Day 21"
    ]
  },
  {
    "objectID": "2022/R/day21.html#part-2",
    "href": "2022/R/day21.html#part-2",
    "title": "Day 21",
    "section": "Part 2",
    "text": "Part 2\n\n# Replace 'humn' number with NA and re-compute known equation values\nmodified_numbers &lt;- compute_monkeys(\n  modify_at(numbers, \"humn\", ~ NA),\n  mutate(eqns, operation = if_else(monkey == \"root\", \"==\", operation))\n)\n\nmonkey_funcs &lt;- eqns |&gt; \n  \n  # Reformat equations\n  mutate(operation = if_else(monkey == \"root\", \"==\", operation)) |&gt; \n  mutate(\n    value_1 = modified_numbers[input_1], \n    value_2 = modified_numbers[input_2],\n    const = unname(coalesce(value_1, value_2)),\n    xposn = if_else(is.na(value_1), 1, 2),\n    input = if_else(is.na(value_1), input_1, input_2),\n  ) |&gt; \n  filter(is.na(value_1) | is.na(value_2)) |&gt; \n  \n  # Convert each operation into an inverse function\n  mutate(\n    f = pmap(list(operation, const, xposn), \\(op, const, xposn) {\n      if (op == \"+\")                   partial(`-`, ... = , const)\n      else if (op == \"*\")              partial(`/`, ... = , const)\n      else if (op == \"-\" & xposn == 1) partial(`+`, ... = , const)\n      else if (op == \"/\" & xposn == 1) partial(`*`, ... = , const)\n      else if (op == \"-\" & xposn == 2) partial(`-`, const, ... = )\n      else if (op == \"/\" & xposn == 2) partial(`/`, const, ... = )\n    }),\n  ) |&gt; \n  select(output = monkey, f, input, const)\n\n# Initiate starting monkey value at the root monkey\ncur_monkey  &lt;- filter(monkey_funcs, output == \"root\")\ncur_value   &lt;- cur_monkey$const\nnext_monkey &lt;- cur_monkey$input\n\n# Compute function inverse for each monkey until \"humn\" is reached\nwhile (next_monkey != \"humn\") {\n  cur_monkey  &lt;- filter(monkey_funcs, output == next_monkey)\n  cur_value   &lt;- cur_monkey$f[[1]](cur_value)\n  next_monkey &lt;- cur_monkey$input\n}\n\n# View final input needed to achieve equality\ncur_value |&gt; \n  format(scientific = FALSE)\n\n[1] \"3221245824363\"",
    "crumbs": [
      "2022",
      "Day 21"
    ]
  },
  {
    "objectID": "2024/R/day10.html",
    "href": "2024/R/day10.html",
    "title": "Day 10",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day10.txt\", skip_empty_rows = TRUE)\n\n# Convert input to matrix format\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt;\n  unlist() |&gt; \n  as.integer() |&gt; \n  matrix(nrow = length(input), byrow = TRUE)",
    "crumbs": [
      "2024",
      "Day 10"
    ]
  },
  {
    "objectID": "2024/R/day10.html#setup",
    "href": "2024/R/day10.html#setup",
    "title": "Day 10",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day10.txt\", skip_empty_rows = TRUE)\n\n# Convert input to matrix format\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt;\n  unlist() |&gt; \n  as.integer() |&gt; \n  matrix(nrow = length(input), byrow = TRUE)",
    "crumbs": [
      "2024",
      "Day 10"
    ]
  },
  {
    "objectID": "2024/R/day10.html#part-1",
    "href": "2024/R/day10.html#part-1",
    "title": "Day 10",
    "section": "Part 1",
    "text": "Part 1\nDefine custom functions:\n\n# North / South / East / West\ndirs &lt;- list(c(0,  1), c(0, -1), c(1,  0), c(-1,  0))\n\n# Check if a coordinate is in the bounds of the map\nin_bounds &lt;- function(x, map) {\n  between(x[1], 1, nrow(map)) & between(x[2], 1, ncol(map))\n}\n\nfind_trail_ends &lt;- function(cur_coord, map) {\n  \n  # If the trailhead has been reached, return its coordinate.\n  if (map[cur_coord] == 9)\n    return(list(cur_coord))\n  \n  # Define the possible next steps within the map bounds\n  next_steps &lt;- dirs |&gt; \n    map(~ cur_coord + .x) |&gt; \n    keep(~ in_bounds(.x, map))\n  \n  trail_ends &lt;- list()\n  \n  # If the next step leads to a valid path, add its terminal to the list\n  for (next_coord in next_steps) {\n    if (map[next_coord] == map[cur_coord] + 1) \n      trail_ends &lt;- c(trail_ends, find_trail_ends(next_coord, map))\n  }\n  \n  return(unique(trail_ends))\n}\n\nscore_trail &lt;- function(trailhead, map) length(find_trail_ends(trailhead, map))\n\n\n# Get a list of coordinates of all of the trailheads\ntrailheads &lt;- which(mtx == 0, arr.ind = TRUE)\ntrailheads_list &lt;- map(\n  1:nrow(trailheads), \n  ~ array(trailheads[.x,], dim = c(1, 2))\n)\n\n# Score each trailhead and sum the total\ntrailheads_list |&gt; \n  map_int(~ score_trail(.x, mtx)) |&gt; \n  sum()\n\n[1] 531",
    "crumbs": [
      "2024",
      "Day 10"
    ]
  },
  {
    "objectID": "2024/R/day10.html#part-2",
    "href": "2024/R/day10.html#part-2",
    "title": "Day 10",
    "section": "Part 2",
    "text": "Part 2\nModify the trail rating function:\n\nrate_trail &lt;- function(cur_coord, map) {\n  # If the trailhead has been reached, increment the score and exit.\n  if (map[cur_coord] == 9)\n    return(1)\n  \n  # Define the possible next steps within the map bounds\n  next_steps &lt;- dirs |&gt; \n    map(~ cur_coord + .x) |&gt; \n    keep(~ in_bounds(.x, map))\n  \n  # Sum the trail ratings of all valid next steps\n  map_int(\n    next_steps,\n    ~ if (map[.x] == map[cur_coord] + 1) rate_trail(.x, map) else 0\n  ) |&gt; \n    sum()\n}\n\nRe-run the puzzle input:\n\ntrailheads_list |&gt; \n  map_int(~ rate_trail(.x, mtx)) |&gt; \n  sum()\n\n[1] 1210",
    "crumbs": [
      "2024",
      "Day 10"
    ]
  },
  {
    "objectID": "2024/R/day05.html",
    "href": "2024/R/day05.html",
    "title": "Day 5",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day05.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2024",
      "Day 5"
    ]
  },
  {
    "objectID": "2024/R/day05.html#setup",
    "href": "2024/R/day05.html#setup",
    "title": "Day 5",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day05.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2024",
      "Day 5"
    ]
  },
  {
    "objectID": "2024/R/day05.html#part-1",
    "href": "2024/R/day05.html#part-1",
    "title": "Day 5",
    "section": "Part 1",
    "text": "Part 1\n\n# Extract page ordering rules from input\nrule_list &lt;- input |&gt; \n  keep(~ str_detect(.x, \"\\\\|\")) |&gt; \n  as_tibble_col(column_name = \"rule\") |&gt; \n  separate(rule, into = c(\"p1\", \"p2\")) |&gt; \n  mutate(rule_num = row_number(), .before = everything()) |&gt; \n  mutate(across(c(p1, p2), parse_number))\n\n# Extract page sequences from input\npages &lt;- input |&gt; \n  discard(~ str_detect(.x, \"\\\\|\")) |&gt; \n  str_split(\",\") |&gt; \n  map(parse_number) |&gt; \n  as_tibble_col(column_name = \"update\")\n\n# Sort a given vector by its applicable rules\nsort_by_rules &lt;- function(seq) {\n  active_rules &lt;- rule_list |&gt; \n    filter(p1 %in% seq & p2 %in% seq)\n  \n  repeat {\n    swap_occurred &lt;- FALSE\n    for (i in 1:nrow(active_rules)) {\n      rule &lt;- filter(active_rules, row_number() == i)\n      idx1 &lt;- which(seq == rule$p1)\n      idx2 &lt;- which(seq == rule$p2)\n      \n      if (idx1 &gt; idx2) {\n        seq[[idx1]] &lt;- rule$p2\n        seq[[idx2]] &lt;- rule$p1\n        swap_occurred &lt;- TRUE\n      }\n    }\n    if (!swap_occurred) return(seq)\n  }\n}\n\n# Sort all page sequences and extract the center page of each result\noutput &lt;- pages |&gt; \n  mutate(\n    resorted = map(update, sort_by_rules),\n    is_sorted = map2_lgl(update, resorted, identical),\n    center_page = map_int(resorted, ~ .x[(length(.x) + 1) / 2])\n  )\n\n\n# For the properly-ordered updates, sum the center page numbers\noutput |&gt;\n  filter(is_sorted) |&gt; \n  pull(center_page) |&gt; \n  sum()\n\n[1] 6505",
    "crumbs": [
      "2024",
      "Day 5"
    ]
  },
  {
    "objectID": "2024/R/day05.html#part-2",
    "href": "2024/R/day05.html#part-2",
    "title": "Day 5",
    "section": "Part 2",
    "text": "Part 2\n\n# For the improperly-ordered updates, sum their sorted center pages\noutput |&gt;\n  filter(!is_sorted) |&gt; \n  pull(center_page) |&gt; \n  sum()\n\n[1] 6897",
    "crumbs": [
      "2024",
      "Day 5"
    ]
  },
  {
    "objectID": "2024/R/day07.html",
    "href": "2024/R/day07.html",
    "title": "Day 7",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day07.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split(\" \") |&gt; \n  map(parse_number)",
    "crumbs": [
      "2024",
      "Day 7"
    ]
  },
  {
    "objectID": "2024/R/day07.html#setup",
    "href": "2024/R/day07.html#setup",
    "title": "Day 7",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day07.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split(\" \") |&gt; \n  map(parse_number)",
    "crumbs": [
      "2024",
      "Day 7"
    ]
  },
  {
    "objectID": "2024/R/day07.html#part-1",
    "href": "2024/R/day07.html#part-1",
    "title": "Day 7",
    "section": "Part 1",
    "text": "Part 1\nDefine calibration functions:\n\ncalibrate_operators &lt;- function(seq, target, operators) {\n  \n  # If the end of the list has been reached or the target is already overshot, exit\n  if (length(seq) == 1) \n    return(seq == target)\n  else if (seq[1] &gt; target)\n    return(FALSE)\n  \n  # Recursively compare the first two items of the seq using each operator\n  map_lgl(\n    operators,\n    \\(f) {\n      new_start &lt;- get(f)(seq[1], seq[2])\n      new_seq &lt;- c(new_start, tail(seq, -2))\n      calibrate_operators(new_seq, target, operators)\n    }\n  ) |&gt; \n    # If any output is true, the output has been calibrated.\n    any()\n}\n\ncalibration_value &lt;- function(input, output, operators) {\n  # Compute calibration for each input-output pair\n  is_calibrated &lt;- map2_lgl(\n    input, \n    output, \n    ~ calibrate_operators(.x, .y, operators = operators)\n  )\n  \n  # Sum the calibrated outputs\n  output |&gt; \n    keep(is_calibrated) |&gt; \n    sum() |&gt; \n    format(scientific = FALSE)\n}\n\nCompute calibration of the puzzle input:\n\ninput_values  &lt;- map(input, tail, -1)\noutput_values &lt;- map_dbl(input, head, 1)\n  \ncalibration_value(input_values, output_values, c(\"+\", \"*\"))\n\n[1] \"12940396350192\"",
    "crumbs": [
      "2024",
      "Day 7"
    ]
  },
  {
    "objectID": "2024/R/day07.html#part-2",
    "href": "2024/R/day07.html#part-2",
    "title": "Day 7",
    "section": "Part 2",
    "text": "Part 2\nAdd a new concatenation operator and re-run the calibration on the puzzle input\n\nconcat &lt;- function(x, y) as.numeric(str_c(x, y))\n\ncalibration_value(input_values, output_values, c(\"+\", \"*\", \"concat\"))\n\n[1] \"106016735664498\"",
    "crumbs": [
      "2024",
      "Day 7"
    ]
  },
  {
    "objectID": "2024/R/day12.html",
    "href": "2024/R/day12.html",
    "title": "Day 12",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file into a data frame\ninput &lt;- read_table(\"../input/day12.txt\", col_names = \"chr\") |&gt; \n  mutate(\n    row = row_number(),\n    chr = str_split(chr, \"\")\n  ) |&gt; \n  unnest(chr) |&gt; \n  mutate(col = row_number(), .by = row) |&gt; \n  mutate(idx = row_number(), .before = everything())",
    "crumbs": [
      "2024",
      "Day 12"
    ]
  },
  {
    "objectID": "2024/R/day12.html#setup",
    "href": "2024/R/day12.html#setup",
    "title": "Day 12",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(igraph)\n\n# Read input from file into a data frame\ninput &lt;- read_table(\"../input/day12.txt\", col_names = \"chr\") |&gt; \n  mutate(\n    row = row_number(),\n    chr = str_split(chr, \"\")\n  ) |&gt; \n  unnest(chr) |&gt; \n  mutate(col = row_number(), .by = row) |&gt; \n  mutate(idx = row_number(), .before = everything())",
    "crumbs": [
      "2024",
      "Day 12"
    ]
  },
  {
    "objectID": "2024/R/day12.html#part-1",
    "href": "2024/R/day12.html#part-1",
    "title": "Day 12",
    "section": "Part 1",
    "text": "Part 1\nFormat the input as a graph, with edges connecting neighbors of the same type:\n\n# Flag neighboring characters of the same value that border one other\nedges_wide &lt;- input |&gt; \n  mutate(v = case_when(row + 1 == lead(row) ~ lead(idx)), .by = c(chr, col)) |&gt; \n  mutate(h = case_when(col + 1 == lead(col) ~ lead(idx)), .by = c(chr, row))\n\nedges_long &lt;- edges_wide |&gt; \n  pivot_longer(\n    c(v, h), \n    names_to = NULL, \n    values_to = \"target\", \n    values_drop_na = TRUE\n  )\n\n# Format neighbors as a list of edges and add to add a graph\ng &lt;- edges_long |&gt; \n  transmute(\n    edge_id = row_number(),\n    src = idx, \n    target\n  ) |&gt; \n  pivot_longer(c(src, target)) |&gt; \n  arrange(edge_id, value) |&gt; \n  pull(value) |&gt; \n  make_graph(n = nrow(input), directed = FALSE)\n\nV(g)$name &lt;- 1:nrow(input)\n\n# Separate out the resulting graph into sub-graphs of innerconnected regions\ndg &lt;- decompose(g)\n\nCompute the perimeter, area, and cost of each subgraph then sum the total:\n\ndg |&gt; \n  map_int(\\(subgraph) {\n    perim &lt;- sum(4 - degree(subgraph))\n    area  &lt;- gorder(subgraph)\n    perim * area\n  }) |&gt; \n  sum()\n\n[1] 1433460",
    "crumbs": [
      "2024",
      "Day 12"
    ]
  },
  {
    "objectID": "2024/R/day12.html#part-2",
    "href": "2024/R/day12.html#part-2",
    "title": "Day 12",
    "section": "Part 2",
    "text": "Part 2\nUsed a hint from reddit: the number of corners is equal to the number of sides.\nA plot can have a convex corner or a concave corner.\n\nA cell has a convex corner for each pair of adjacent borders\nA cell has a concave corner if it has two adjacent cells of its same group, but its diagonal cell between the two has a different group.\n\n\n# Get original row/column input and join on the group output from the graph\ngroups &lt;- left_join(\n  input,\n  imap_dfr(dg, \\(g, grp_idx) tibble(grp = grp_idx, idx = V(g)$name)),\n  join_by(idx)\n) |&gt; \n  select(idx, grp, row, col)\n\n# For each of a cell's neighbors, flag if they're in the same group\nneighbors &lt;- groups |&gt; \n  # Get group number of each adjacent cell (N/S/E/W)\n  left_join(transmute(groups, n = grp, row = row + 1, col), join_by(row, col)) |&gt; \n  left_join(transmute(groups, w = grp, col = col + 1, row), join_by(row, col)) |&gt; \n  left_join(transmute(groups, s = grp, row = row - 1, col), join_by(row, col)) |&gt; \n  left_join(transmute(groups, e = grp, col = col - 1, row), join_by(row, col)) |&gt; \n  # Get group number of each diagonal cell (NW/NE/SW/SE)\n  left_join(transmute(groups, nw = grp, row = row + 1, col = col + 1), join_by(row, col)) |&gt; \n  left_join(transmute(groups, ne = grp, row = row + 1, col = col - 1), join_by(row, col)) |&gt; \n  left_join(transmute(groups, sw = grp, row = row - 1, col = col + 1), join_by(row, col)) |&gt; \n  left_join(transmute(groups, se = grp, row = row - 1, col = col - 1), join_by(row, col)) |&gt; \n  select(-c(row, col)) |&gt; \n  # Compare group numbers of adjacent/diagonal cells to the current cell\n  mutate(across(c(n, w, s, e, nw, ne, sw, se), ~ replace_na(.x == grp, FALSE)))\n\n# Compute total number of concave/convex corners for each cell\ncorners &lt;- neighbors |&gt; \n  mutate(\n    convex = (!n & !w) + (!s & !w) + (!s & !e) + (!n & !e),\n    concave = (n & w & !nw) + (s & w & !sw) + (s & e & !se) + (n & e & !ne)\n  )\n\nTotal the number of corners per group and multiply by the group’s area to get the total cost:\n\ncorners |&gt; \n  summarize(\n    area = n(),\n    num_sides = sum(convex + concave), \n    .by = grp\n  ) |&gt; \n  mutate(cost = area * num_sides) |&gt; \n  pull(cost) |&gt; \n  sum()\n\n[1] 855082",
    "crumbs": [
      "2024",
      "Day 12"
    ]
  },
  {
    "objectID": "2024/R/day02.html",
    "href": "2024/R/day02.html",
    "title": "Day 2",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day02.txt\") |&gt; \n  map(~parse_number(str_split_1(.x, \" \")))",
    "crumbs": [
      "2024",
      "Day 2"
    ]
  },
  {
    "objectID": "2024/R/day02.html#setup",
    "href": "2024/R/day02.html#setup",
    "title": "Day 2",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day02.txt\") |&gt; \n  map(~parse_number(str_split_1(.x, \" \")))",
    "crumbs": [
      "2024",
      "Day 2"
    ]
  },
  {
    "objectID": "2024/R/day02.html#part-1",
    "href": "2024/R/day02.html#part-1",
    "title": "Day 2",
    "section": "Part 1",
    "text": "Part 1\n\n# Compute difference between consecutive integers\nseq_gaps &lt;- function(seq)\n  head(lead(seq) - seq, -1)\n\n# Check whether the sequence is incr/decr with gaps between 1 and 3\ngaps_are_valid &lt;- function(gaps)\n  (all(gaps &lt; 0) | all(gaps &gt; 0)) & all(between(abs(gaps), 1, 3))\n\n# Count number of safe reports\ninput |&gt; \n  map(seq_gaps) |&gt; \n  map_lgl(gaps_are_valid) |&gt; \n  sum()\n\n[1] 306",
    "crumbs": [
      "2024",
      "Day 2"
    ]
  },
  {
    "objectID": "2024/R/day02.html#part-2",
    "href": "2024/R/day02.html#part-2",
    "title": "Day 2",
    "section": "Part 2",
    "text": "Part 2\n\ntibble(input) |&gt; \n  \n  # For each report, create a set of versions where each level is removed\n  mutate(\n    id = row_number(),\n    mod = map(input, \\(seq) map(1:length(seq), \\(n) seq[-c(n)])),\n  ) |&gt; \n  unnest(mod) |&gt; \n  \n  # Check validity of each report and its altered versions\n  mutate(\n    report_is_safe = map_lgl(input, ~ gaps_are_valid(seq_gaps(.x))),\n    mod_is_safe    = map_lgl(mod,   ~ gaps_are_valid(seq_gaps(.x))),\n    is_safe = report_is_safe | mod_is_safe\n  ) |&gt; \n  summarize(is_safe = any(is_safe), .by = id) |&gt; \n  \n  # Count all safe reports\n  summarize(total = sum(is_safe)) |&gt; \n  pull()\n\n[1] 366",
    "crumbs": [
      "2024",
      "Day 2"
    ]
  },
  {
    "objectID": "2024/R/day17.html",
    "href": "2024/R/day17.html",
    "title": "Day 17",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(bit64)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day17.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue_data(patterns = c(\n    \"{label}: {value}\"\n  ))",
    "crumbs": [
      "2024",
      "Day 17"
    ]
  },
  {
    "objectID": "2024/R/day17.html#setup",
    "href": "2024/R/day17.html#setup",
    "title": "Day 17",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(bit64)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day17.txt\", skip_empty_rows = TRUE) |&gt; \n  unglue_data(patterns = c(\n    \"{label}: {value}\"\n  ))",
    "crumbs": [
      "2024",
      "Day 17"
    ]
  },
  {
    "objectID": "2024/R/day17.html#part-1",
    "href": "2024/R/day17.html#part-1",
    "title": "Day 17",
    "section": "Part 1",
    "text": "Part 1\nInitialize the machine from the text input:\n\nprogram &lt;- input |&gt; \n  filter(label == \"Program\") |&gt; \n  pull(value) |&gt; \n  str_split_1(\",\") |&gt; \n  as.integer()\n\nA &lt;- input |&gt; \n  filter(label == \"Register A\") |&gt; \n  pull(value) |&gt; \n  as.integer()\n\nB &lt;- input |&gt; \n  filter(label == \"Register B\") |&gt; \n  pull(value) |&gt; \n  as.integer()\n\nC &lt;- input |&gt; \n  filter(label == \"Register C\") |&gt; \n  pull(value) |&gt; \n  as.integer()\n\nmachine &lt;- list(program = program, A = A, B = B, C = C, pointer = 0L, output = NULL)\n\nDefine machine’s helper functions:\n\ncombo &lt;- function(machine, operand) {\n  case_match(operand,\n    0 ~ 0,\n    1 ~ 1,\n    2 ~ 2,\n    3 ~ 3,\n    4 ~ machine$A,\n    5 ~ machine$B,\n    6 ~ machine$C\n   )\n}\n\nrun_opcode &lt;- function(machine, opcode, operand) {\n  func &lt;- case_match(opcode, \n    0 ~ \"adv\",\n    1 ~ \"bxl\",\n    2 ~ \"bst\",\n    3 ~ \"jnz\",\n    4 ~ \"bxc\",\n    5 ~ \"out\",\n    6 ~ \"bdv\",\n    7 ~ \"cdv\"\n  )\n  \n  get(func)(machine, operand)\n}\n\nrun_machine &lt;- function(machine) {\n  while (machine$pointer &lt; length(machine$program)) {\n    opcode  &lt;- machine$program[machine$pointer + 1]\n    operand &lt;- machine$program[machine$pointer + 2]\n    machine &lt;- run_opcode(machine, opcode, operand)\n  }\n  return(machine$output)\n}\n\nNeed to define custom bitwise XOR function to handle very large integers without error:\n\nbitwXor64 &lt;- function(x, y) {\n  x &lt;- as.bitstring(as.integer64(x))\n  y &lt;- as.bitstring(as.integer64(y))\n  \n  base::xor(\n    as.integer(str_split_1(x, \"\")), \n    as.integer(str_split_1(y, \"\"))\n  ) |&gt; \n    as.integer() |&gt; \n    str_c(collapse = \"\") |&gt; \n    structure(class = \"bitstring\") |&gt; \n    as.integer64() |&gt; \n    as.numeric()\n}\n\nDefine the opcode functions:\n\nadv &lt;- function(machine, operand) {\n  machine$A &lt;- floor(machine$A / 2^combo(machine, operand))\n  machine$pointer &lt;- machine$pointer + 2\n  return(machine)\n}\n\nbxl &lt;- function(machine, operand) {\n  machine$B &lt;- bitwXor64(machine$B, operand)\n  machine$pointer &lt;- machine$pointer + 2\n  return(machine)\n}\n\nbst &lt;- function(machine, operand) {\n  machine$B &lt;- combo(machine, operand) %% 8\n  machine$pointer &lt;- machine$pointer + 2\n  return(machine)\n}\n\njnz &lt;- function(machine, operand) {\n  if (machine$A != 0) \n    machine$pointer &lt;- operand\n  else \n    machine$pointer &lt;- machine$pointer + 2\n  return(machine)\n}\n\nbxc &lt;- function(machine, operand) {\n  machine$B &lt;- bitwXor64(machine$B, machine$C)\n  machine$pointer &lt;- machine$pointer + 2\n  return(machine)\n}\n\nout &lt;- function(machine, operand) {\n  machine$output &lt;- c(\n    machine$output, \n    combo(machine, operand) %% 8\n  )\n  machine$pointer &lt;- machine$pointer + 2\n  return(machine)\n}\n\nbdv &lt;- function(machine, operand) {\n  machine$B &lt;- floor(machine$A / 2^combo(machine, operand))\n  machine$pointer &lt;- machine$pointer + 2\n  return(machine)\n}\n\ncdv &lt;- function(machine, operand) {\n  machine$C &lt;- floor(machine$A / 2^combo(machine, operand))\n  machine$pointer &lt;- machine$pointer + 2\n  return(machine)\n}\n\nRun on puzzle input:\n\nrun_machine(machine) |&gt; \n  str_c(collapse = \",\")\n\n[1] \"3,1,4,3,1,7,1,6,3\"",
    "crumbs": [
      "2024",
      "Day 17"
    ]
  },
  {
    "objectID": "2024/R/day17.html#part-2",
    "href": "2024/R/day17.html#part-2",
    "title": "Day 17",
    "section": "Part 2",
    "text": "Part 2\nReverse engineer, testing sequences of 3 bits at a time. Thanks to hints from Reddit:\n\nrun_machine_a &lt;- function(a) run_machine(list(\n  program = program, \n  A = a, \n  B = B, \n  C = C, \n  pointer = 0L, \n  output = NULL\n))\n\nreveng &lt;- function(program, digit = 1, a = 0) {\n  if (digit &gt; length(program))\n    return(a)\n  \n  df &lt;- tibble(candidates = 8 * a + 0:7) |&gt; \n    mutate(\n      output = map(candidates, run_machine_a),\n      output = map(output, head, n = 1)\n    ) |&gt; \n    filter(output == rev(program)[digit]) |&gt; \n    mutate(\n      res = map_dbl(candidates, ~ reveng(program, digit + 1, .x))\n    ) |&gt; \n    filter(!is.na(res))\n  \n  if (nrow(df) == 0) return(Inf)\n  else return(min(df$res))\n}\n\nreveng(program) |&gt; \n  format(scientific = FALSE)\n\n[1] \"37221270076916\"",
    "crumbs": [
      "2024",
      "Day 17"
    ]
  },
  {
    "objectID": "2024/R/day15.html",
    "href": "2024/R/day15.html",
    "title": "Day 15",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day15.txt\")\ninput_wh &lt;- keep(input, ~ str_detect(.x, \"#\"))\ninput_mv &lt;- keep(input, ~ str_detect(.x, \"&lt;|&gt;|\\\\^|v\"))",
    "crumbs": [
      "2024",
      "Day 15"
    ]
  },
  {
    "objectID": "2024/R/day15.html#setup",
    "href": "2024/R/day15.html#setup",
    "title": "Day 15",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day15.txt\")\ninput_wh &lt;- keep(input, ~ str_detect(.x, \"#\"))\ninput_mv &lt;- keep(input, ~ str_detect(.x, \"&lt;|&gt;|\\\\^|v\"))",
    "crumbs": [
      "2024",
      "Day 15"
    ]
  },
  {
    "objectID": "2024/R/day15.html#part-1",
    "href": "2024/R/day15.html#part-1",
    "title": "Day 15",
    "section": "Part 1",
    "text": "Part 1\nConvert warehouse input to a row/column indexed dataframe\n\n# Convert WH input text to a matrix\nmtx &lt;- input_wh |&gt;\n  str_split(\"\") |&gt; \n  matrix() |&gt; \n  unlist() |&gt; \n  matrix(byrow = TRUE, nrow = length(input_wh))\n\n\n# Convert movement sequence to a seq of characters\nmove_seq &lt;- input_mv |&gt; \n  str_c(collapse = \"\") |&gt; \n  str_split_1(\"\")\n\nDefine function to update the map based on a single movement of the robot::\n\nmove_robot &lt;- function(mtx, dir) {\n  # Get the current coordinates of the robot\n  robot &lt;- which(mtx == \"@\", arr.ind = TRUE)\n  row &lt;- robot[1, \"row\"]\n  col &lt;- robot[1, \"col\"]\n  \n  # Define the range of matrix values to adjust according to the movement dir\n  row_end &lt;- case_match(dir, c(\"&lt;\", \"&gt;\") ~ row, \"^\" ~ 1, \"v\" ~ nrow(mtx))\n  col_end &lt;- case_match(dir, c(\"^\", \"v\") ~ col, \"&lt;\" ~ 1, \"&gt;\" ~ nrow(mtx))\n  \n  # Using obstacle logic, determine the set of new characters\n  new &lt;- tibble(\n    orig = mtx[row:row_end, col:col_end],\n    lag = lag(orig)\n  ) |&gt; \n    mutate(\n      is_empty = orig == \".\",\n      is_wall  = orig == \"#\",\n      is_blocked = accumulate(is_wall, `|`),\n      is_fillable = is_empty & !is_blocked,\n      first_fillable = is_fillable & !lag(accumulate(is_fillable, `|`)),\n      can_move = accumulate(first_fillable, `|`, .dir = \"backward\"),\n      new = if_else(can_move, coalesce(lag, \".\"), orig)\n    ) |&gt; \n    pull(new)\n  \n  # Replace the affected characters in the matrix and return\n  mtx[row:row_end, col:col_end] &lt;- new\n  return(mtx)\n}\n\nDefine a function to iteratively run the set of movements\n\nrun_simulation &lt;- function(mtx, move_seq) {\n  mtx_prv &lt;- mtx\n  for (dir in move_seq) {\n    mtx_new &lt;- move_robot(mtx_prv, dir)\n    mtx_prv &lt;- mtx_new\n  }\n  return(mtx_new)\n}\n\nDefine a function to determine the GPS coordinates of all boxes\n\nget_boxes_gps &lt;- function(mtx) {\n  which(mtx == \"O\", arr.ind = TRUE) |&gt; \n    as_tibble() |&gt; \n    mutate(\n      gps = 100 * (row - 1) + (col - 1)\n    ) |&gt; \n    pull(gps)\n}\n\nRun puzzle input:\n\nmtx |&gt; \n  run_simulation(move_seq) |&gt; \n  get_boxes_gps() |&gt;\n  sum()\n\n[1] 1457740",
    "crumbs": [
      "2024",
      "Day 15"
    ]
  },
  {
    "objectID": "2024/R/day15.html#part-2",
    "href": "2024/R/day15.html#part-2",
    "title": "Day 15",
    "section": "Part 2",
    "text": "Part 2\nWiden the map:\n\n# Convert WH input text to a matrix\nmtx &lt;- input_wh |&gt; \n  str_replace_all(\"#\", \"##\") |&gt; \n  str_replace_all(\"O\", \"[]\") |&gt; \n  str_replace_all(\"\\\\.\", \"..\") |&gt; \n  str_replace_all(\"@\", \"@.\") |&gt;\n  str_split(\"\") |&gt; \n  matrix() |&gt; \n  unlist() |&gt; \n  matrix(byrow = TRUE, nrow = length(input_wh))\n\nDefine functions to move boxes around the map:\n\nget_box_coords &lt;- function(mtx, box_num) {\n  as_tibble(which(mtx == box_num, arr.ind = TRUE))\n}\n\nget_next_coords &lt;- function(cur_coords, dir = c(\"&lt;\", \"^\", \"&gt;\", \"v\")) {\n  cur_coords |&gt;\n    mutate(\n      row = row + case_match(dir, \"^\" ~ -1, \"v\" ~ 1, .default = 0),\n      col = col + case_match(dir, \"&lt;\" ~ -1, \"&gt;\" ~ 1, .default = 0),\n    )\n}\n\nget_next_chrs &lt;- function(mtx, cur_coords, dir = c(\"&lt;\", \"^\", \"&gt;\", \"v\")) {\n  # Pull the values of the next cells in the intended direction\n  cur_coords |&gt;\n    get_next_coords(dir) |&gt; \n    mutate(chr = map2_chr(row, col, ~ mtx[.x, .y])) |&gt; \n    anti_join(cur_coords, join_by(row, col)) |&gt; \n    pull(chr) |&gt; \n    unique()\n}\n\nis_blocked &lt;- function(mtx, box_num, dir = c(\"&lt;\", \"^\", \"&gt;\", \"v\")) {\n  \n  cur &lt;- get_box_coords(mtx, box_num)\n  nxt_chrs &lt;- get_next_chrs(mtx, cur, dir)\n  \n  # Test if the current box is completely blocked or completely free\n  if (any(nxt_chrs == '#')) \n    return(TRUE)\n  else if (all(nxt_chrs == '.')) \n    return(FALSE)\n  \n  # Recurse across all later boxes \n  nxt_chrs |&gt; \n    keep(~ str_detect(.x, \"^\\\\d+$\")) |&gt; \n    map_lgl(~ is_blocked(mtx, .x, dir)) |&gt; \n    any()\n}\n\nmove_box &lt;- function(mtx, box_num, dir = c(\"&lt;\", \"^\", \"&gt;\", \"v\")) {\n  # Get the coordinates of the current box and the place it'll move to\n  cur &lt;- get_box_coords(mtx, box_num)\n  nxt &lt;- get_next_coords(cur, dir)\n  \n  # Move all downstream boxes before moving self\n  next_boxes &lt;- get_next_chrs(mtx, cur, dir) |&gt; \n    keep(~ str_detect(.x, \"^\\\\d+$\"))\n  \n  for (box in next_boxes) {\n    mtx &lt;- move_box(mtx, box, dir)\n  }\n  \n  # # Replace the current coords with \".\" and the next coords with the box\n  mtx[cur$row, cur$col] &lt;- \".\"\n  mtx[nxt$row, nxt$col] &lt;- box_num\n  \n  return(mtx)\n}\n\nLoop through puzzle input:\n\nrun_simulation &lt;- function(mtx, move_seq) {\n  # Convert boxes from format \"[]\" into ID numbers unique to each box:\n  coords &lt;- list(l = which(mtx == \"[\"), r = which(mtx == \"]\"))\n  for (i in 1:length(coords$l)) {\n    mtx[coords$l[i]] &lt;- i\n    mtx[coords$r[i]] &lt;- i\n  }\n\n  # Loop through sequence of moves and apply to the map\n  mtx_prv &lt;- mtx\n  for (dir in move_seq) {\n    if (!is_blocked(mtx_prv, box_num = \"@\", dir = dir)) {\n      mtx_new &lt;- move_box(mtx_prv, box_num = \"@\", dir = dir)\n      mtx_prv &lt;- mtx_new\n    } \n  }\n  \n  return(mtx_new)\n}\n\noutput &lt;- run_simulation(mtx, move_seq)\n\nConvert the result to GPS coordinates:\n\noutput |&gt; \n  as_tibble() |&gt; \n  mutate(row = row_number(), .before = everything()) |&gt; \n  pivot_longer(\n    -row, \n    names_to = \"col\", \n    names_prefix = \"V\", \n    names_transform = as.integer\n  ) |&gt; \n  # Select only the leftmost cell of each boxes\n  filter(str_detect(value, \"\\\\d+\")) |&gt; \n  slice_min(col, by = value) |&gt; \n  mutate(\n    dist_top = row - 1,\n    dist_left = col - 1,\n    gps = 100 * dist_top + dist_left\n  ) |&gt; \n  pull(gps) |&gt; \n  sum()\n\n[1] 1467145",
    "crumbs": [
      "2024",
      "Day 15"
    ]
  },
  {
    "objectID": "2024/R/day14.html",
    "href": "2024/R/day14.html",
    "title": "Day 14",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day14.txt\", skip_empty_rows = TRUE)\n\n# Parameters: dimensions of the room\nroom_w &lt;- 101\nroom_h &lt;- 103",
    "crumbs": [
      "2024",
      "Day 14"
    ]
  },
  {
    "objectID": "2024/R/day14.html#setup",
    "href": "2024/R/day14.html#setup",
    "title": "Day 14",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day14.txt\", skip_empty_rows = TRUE)\n\n# Parameters: dimensions of the room\nroom_w &lt;- 101\nroom_h &lt;- 103",
    "crumbs": [
      "2024",
      "Day 14"
    ]
  },
  {
    "objectID": "2024/R/day14.html#part-1",
    "href": "2024/R/day14.html#part-1",
    "title": "Day 14",
    "section": "Part 1",
    "text": "Part 1\nExtract numerical values from input text:\n\ndf &lt;- input |&gt;\n  unglue_data(\"p={x},{y} v={vx},{vy}\") |&gt; \n  mutate(\n    across(everything(), parse_number),\n    robot_id = row_number(),\n    .before = everything()\n  )\n\nFor debugging: define a function to print the current state of the grid\n\nprint_grid &lt;- function(df, w = room_w, h = room_h) {\n  df |&gt; \n    summarize(n = as.character(n()), .by = c(x, y)) |&gt; \n    complete(\n      x = 0:(room_w - 1), \n      y = 0:(room_h - 1), \n      fill = list(n = \"\")\n    ) |&gt; \n    mutate(n = str_pad(n, width = max(str_length(n)), side = \"left\")) |&gt; \n    arrange(desc(y), x) |&gt; \n    group_split(y) |&gt; \n    map_chr(~ pull(.x, n) |&gt; str_c(collapse = \" \")) |&gt; \n    cat(sep = \"\\n\")\n}\n\nDefine a function which gives the location of the robots after n seconds. Multiply n by the velocity, add to the current position, and modulo the room dimensions.\n\npass_time &lt;- function(df, seconds, w = room_w, h = room_h) {\n  df |&gt; \n    mutate(\n      x = (x + vx * seconds) %% w,\n      y = (y + vy * seconds) %% h\n    )\n}\n\nDefine a function to get the current safety factor by counting the number of robots in each quadrant of the room:\n\nget_safety_score &lt;- function(df, w = room_w, h = room_h) {\n  mid_w &lt;- (room_w - 1) / 2\n  mid_h &lt;- (room_h - 1) / 2\n  \n  df |&gt; \n    mutate(\n      half_w = case_when(x &lt; mid_w ~ 0, x &gt; mid_w ~ 1),\n      half_h = case_when(y &lt; mid_h ~ 0, y &gt; mid_h ~ 1),\n      quadrant = half_w + 2 * half_h\n    ) |&gt; \n    drop_na(quadrant) |&gt; \n    summarize(num_robots = n(), .by = quadrant) |&gt; \n    pull(num_robots) |&gt; \n    prod()\n}\n\nCompute safety score of puzzle input:\n\ndf |&gt; \n  pass_time(100) |&gt; \n  get_safety_score()\n\n[1] 208437768",
    "crumbs": [
      "2024",
      "Day 14"
    ]
  },
  {
    "objectID": "2024/R/day14.html#part-2",
    "href": "2024/R/day14.html#part-2",
    "title": "Day 14",
    "section": "Part 2",
    "text": "Part 2\nFirst, find the cycle of seconds where the robots’ positions repeat (no more than the least common multiple of the room width and room height)\n\ncycle &lt;- DescTools::LCM(room_w, room_h)\n\nFor each unique snapshot in the cycle, test for randomness vs structure in the X-Y coordinates.\n\nsimulations &lt;- map_dfr(\n  1:cycle,\n  \\(seconds) {\n    new &lt;- pass_time(df, seconds)\n    c(secs = seconds, xvar = var(new$x), yvar = var(new$y))\n  }\n)\n\nsimulations |&gt; \n  arrange(xvar, yvar, secs) |&gt; \n  filter(row_number() == 1) |&gt; \n  pull(secs)\n\n[1] 7492",
    "crumbs": [
      "2024",
      "Day 14"
    ]
  },
  {
    "objectID": "2024/R/day19.html",
    "href": "2024/R/day19.html",
    "title": "Day 19",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\navailable &lt;- read_lines(\"../input/day19.txt\", n_max = 1) |&gt; str_split_1(\", \")\ndesired   &lt;- read_lines(\"../input/day19.txt\", skip = 2)",
    "crumbs": [
      "2024",
      "Day 19"
    ]
  },
  {
    "objectID": "2024/R/day19.html#setup",
    "href": "2024/R/day19.html#setup",
    "title": "Day 19",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\navailable &lt;- read_lines(\"../input/day19.txt\", n_max = 1) |&gt; str_split_1(\", \")\ndesired   &lt;- read_lines(\"../input/day19.txt\", skip = 2)",
    "crumbs": [
      "2024",
      "Day 19"
    ]
  },
  {
    "objectID": "2024/R/day19.html#part-1",
    "href": "2024/R/day19.html#part-1",
    "title": "Day 19",
    "section": "Part 1",
    "text": "Part 1\n\n# Convert all possible available patterns into a regex string\nregex &lt;- str_c(\"^(\", str_c(available, collapse = \"|\"), \")+$\")\n\n# Test each desired pattern for a regex match and count the number of matches\ndesired |&gt; \n  str_detect(regex) |&gt; \n  sum()\n\n[1] 363",
    "crumbs": [
      "2024",
      "Day 19"
    ]
  },
  {
    "objectID": "2024/R/day19.html#part-2",
    "href": "2024/R/day19.html#part-2",
    "title": "Day 19",
    "section": "Part 2",
    "text": "Part 2\nUse recursion to check for total possible values, and cache results with memoisation to speed up the process:\n\n# Recursively remove matches from the beginning of the string and sum result\nnum_matches &lt;- function(str) {\n  if (str_length(str) == 0)\n    return(1)\n  \n  available |&gt; \n    keep(~ str_starts(str, .x)) |&gt; \n    map_chr(~ str_remove(str, .x)) |&gt; \n    map_dbl(num_matches) |&gt; \n    sum()\n}\n\n# Memoize the recursive function for performance\nnum_matches &lt;- memoise::memoise(num_matches)\n\n# Run on puzzle input:\ndesired |&gt; \n  map_dbl(num_matches) |&gt; \n  sum() |&gt; \n  format(scientific = FALSE)\n\n[1] \"642535800868438\"",
    "crumbs": [
      "2024",
      "Day 19"
    ]
  },
  {
    "objectID": "2024/R/day24.html",
    "href": "2024/R/day24.html",
    "title": "Day 24",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day24.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2024",
      "Day 24"
    ]
  },
  {
    "objectID": "2024/R/day24.html#setup",
    "href": "2024/R/day24.html#setup",
    "title": "Day 24",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day24.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2024",
      "Day 24"
    ]
  },
  {
    "objectID": "2024/R/day24.html#part-1",
    "href": "2024/R/day24.html#part-1",
    "title": "Day 24",
    "section": "Part 1",
    "text": "Part 1\nConvert input to lists of gates and wires:\n\ninit &lt;- input |&gt; \n  unglue::unglue_data(\"{wire}: {value}\", convert = TRUE) |&gt; \n  filter(!is.na(wire))\n\ngates &lt;- input |&gt; \n  unglue::unglue_data(\"{src1} {gate} {src2} -&gt; {target}\") |&gt; \n  filter(!is.na(gate)) |&gt; \n  mutate(gate = case_match(gate, \"AND\" ~ \"&\", \"OR\" ~ \"|\", \"XOR\" ~ \"xor\"))\n\nwires &lt;- init |&gt; \n  complete(wire = unique(c(gates$src1, gates$src2, gates$target))) |&gt; \n  deframe()\n\nLoop through the lists of gates and wires, and whenever a new gate can be activated, get its resulting value. Repeat until all wires have a final output.\n\ndf &lt;- wires |&gt; \n  enframe(name = \"wire\") |&gt;\n  left_join(gates, join_by(wire == target))\n\nrepeat {\n\n  cur_values &lt;- df |&gt; \n    select(wire, value) |&gt; \n    deframe()\n  \n  df &lt;- df |&gt; \n    mutate(\n      val1 = cur_values[src1], \n      val2 = cur_values[src2],\n      value = coalesce(\n        value,\n        pmap_int(list(gate, val1, val2), \\(gate, val1, val2) {\n          if (!is.na(gate) & !is.na(val1) & !is.na(val2))\n            get(gate)(val1, val2)\n          else \n            NA_integer_\n        })\n      )\n    )\n  \n  if (all(!is.na(df$value))) break\n}\n\nConvert the Z-coded wires to a binary number:\n\ndf |&gt; \n  filter(str_starts(wire, \"z\")) |&gt; \n  arrange(wire) |&gt; \n  pull(value) |&gt; \n  imap_dbl(\\(x, i) x * 2^(i - 1)) |&gt; \n  sum() |&gt; \n  format(scientific = FALSE)\n\n[1] \"59364044286798\"",
    "crumbs": [
      "2024",
      "Day 24"
    ]
  },
  {
    "objectID": "2024/R/day24.html#part-2",
    "href": "2024/R/day24.html#part-2",
    "title": "Day 24",
    "section": "Part 2",
    "text": "Part 2\nThanks to hint from Reddit: this method of binary addition using only AND, OR, XOR gates without negation is a “ripple-carry adder.”\nThe gates follow a consistent algorithm, where “Z” digits are the final output digits, and “C” values are carried over to the next digit:\n\nSTEP 00: \n\nZ00 = X00 XOR Y00  (Final output: Z00)\n\nC01 = X00 AND Y00  (Carry forward to next step)\n\nSTEP 01: \n\nZ01A = X01  XOR Y01  (Intermediate step)\nZ01  = Z01A XOR C01  (Final output: Z01)\n\nC02A = X01  AND Y01  (Intermediate step)\nC02B = Z01A AND C01  (Intermediate step)\nC02  = C02A OR  C02B (Carry forward to next step)\n\n(...)\n\nC44  = C44A OR C44B  (Carry forward to next step)\n\nSTEP 44:\n\nZ44A = X44  XOR Y44  (Intermediate step)\nZ44  = Z44A XOR C44  (Final output: Z45)\n\nC45A = X44  AND Y44  (Intermediate step)\nC45B = Z44A AND C44  (Intermediate step)\nC45  = C45A OR  C45B (No further steps to carry over. Set as final output: Z45)\nWe can compare the expected versus actual logic to find steps that don’t match this algorithm.\n\n# Pull lists of all wires of x, y, z, and other types for quick reference\nnlist &lt;- discard(names(wires), ~ str_starts(.x, \"x|y|z\"))\nxlist &lt;- keep(names(wires), ~ str_starts(.x, \"x\"))\nylist &lt;- keep(names(wires), ~ str_starts(.x, \"y\"))\nzlist &lt;- keep(names(wires), ~ str_starts(.x, \"z\"))\nxylist &lt;- c(xlist, ylist)\nzmax  &lt;- max(zlist)\n\n# Put source gates in alphabetical order for easier comparison\ngates &lt;- gates |&gt; \n  mutate(src = map2(src1, src2, ~ sort(c(.x, .y)))) |&gt; \n  select(-c(src1, src2)) |&gt; \n  unnest_wider(src, names_sep = \"\")\n\nPull invalid outputs according to their gate type and inputs:\n\ninvalid_by_gate &lt;- gates |&gt; \n  pmap_lgl(\\(gate, target, src1, src2) {\n    case_when(\n      # All z-target cases:\n      target == \"z00\"   ~ src1 == \"x00\" & src2 == \"y00\" & gate == \"xor\",\n      target == zmax    ~ src1 %in% nlist & src2 %in% nlist & gate == \"|\",\n      target %in% zlist ~ src1 %in% nlist & src2 %in% nlist & gate == \"xor\",\n      # N-target cases by gate type:\n      gate == \"xor\" ~ src1 %in% xylist & src2 %in% xylist,\n      gate == \"|\"   ~ src1 %in% nlist  & src2 %in% nlist\n    )\n  }) |&gt; \n  set_names(gates$target) |&gt; \n  keep(~ !is.na(.x) & .x == FALSE) |&gt; \n  names()\n\nIdentify invalid outputs by following their logic trail forward and checking the gate types of the logic they are used as later input for:\n\ninvalid_by_path &lt;- gates |&gt; \n  left_join(select(gates, src1, gate), join_by(x$target == y$src1), suffix = c(\"\", \"1\")) |&gt; \n  left_join(select(gates, src2, gate), join_by(x$target == y$src2), suffix = c(\"\", \"2\")) |&gt; \n  nest(nxt = c(gate1, gate2), .by = -c(gate1, gate2)) |&gt; \n  mutate(\n    nxt = map(nxt, ~ .x |&gt; unlist() |&gt; discard(is.na) |&gt; unname())\n  ) |&gt; \n  unnest_wider(nxt, names_sep = \"_\") |&gt; \n  mutate(\n    valid = case_when(\n      target %in% zlist \n        ~ NA,\n      gate == \"xor\" \n        ~ nxt_1 %in% c(\"xor\", \"&\") & \n          nxt_2 %in% c(\"xor\", \"&\") & \n          nxt_1 != nxt_2 & \n          !is.na(nxt_1) & \n          !is.na(nxt_2),\n      gate == \"|\" \n        ~ nxt_1 %in% c(\"xor\", \"&\") & \n          nxt_2 %in% c(\"xor\", \"&\") & \n          nxt_1 != nxt_2 & \n          !is.na(nxt_1) & \n          !is.na(nxt_2),\n      gate == \"&\" & !(src1 %in% c(\"x00\", \"y00\"))\n        ~ nxt_1 == \"|\" | nxt_2 == \"|\"\n    )\n  ) |&gt; \n  filter(!valid) |&gt; \n  pull(target)\n\nConcatenate all invalid gates alphabetically:\n\nc(invalid_by_gate, invalid_by_path) |&gt; \n  unique() |&gt; \n  sort() |&gt; \n  str_c(collapse = \",\")\n\n[1] \"cbj,cfk,dmn,gmt,qjj,z07,z18,z35\"",
    "crumbs": [
      "2024",
      "Day 24"
    ]
  },
  {
    "objectID": "2024/R/day22.html",
    "href": "2024/R/day22.html",
    "title": "Day 22",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(bit64)\nlibrary(memoise)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day22.txt\", skip_empty_rows = TRUE) |&gt; \n  as.numeric()",
    "crumbs": [
      "2024",
      "Day 22"
    ]
  },
  {
    "objectID": "2024/R/day22.html#setup",
    "href": "2024/R/day22.html#setup",
    "title": "Day 22",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(bit64)\nlibrary(memoise)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day22.txt\", skip_empty_rows = TRUE) |&gt; \n  as.numeric()",
    "crumbs": [
      "2024",
      "Day 22"
    ]
  },
  {
    "objectID": "2024/R/day22.html#part-1",
    "href": "2024/R/day22.html#part-1",
    "title": "Day 22",
    "section": "Part 1",
    "text": "Part 1\nDefine custom bitwise XOR function, needed to handle large integers:\n\nbitwXor64 &lt;- function(x, y) {\n  x &lt;- as.bitstring(as.integer64(x))\n  y &lt;- as.bitstring(as.integer64(y))\n  \n  map2_chr(\n    x |&gt; str_split(\"\") |&gt; map(as.integer), \n    y |&gt; str_split(\"\") |&gt; map(as.integer),\n    ~ base::xor(.x, .y) |&gt; \n      as.integer() |&gt; \n      str_c(collapse = \"\")\n  ) |&gt; \n    structure(class = \"bitstring\") |&gt;\n    as.integer64() |&gt;\n    as.numeric()\n}\n\nDefine the algorithm for producing a sequence of “secret” numbers:\n\nmix   &lt;- memoise::memoise(\\(a, b) bitwXor64(a, b))\nprune &lt;- \\(x) x %% 16777216\n\nsecret_alg &lt;- function(x) {\n  x1 &lt;- prune(mix(x, x * 64))\n  x2 &lt;- prune(mix(x1, floor(x1 / 32)))\n  x3 &lt;- prune(mix(x2, x2 * 2048))\n  return(x3)\n}\n\nsecret_seq &lt;- function(init, len) {\n  out &lt;- list(init)\n  for (i in 2:len) {\n    out[[i]] &lt;- secret_alg(pluck(out, i - 1))\n  }\n  out\n}\n\nRun puzzle input:\n\nsecret_nums &lt;- secret_seq(input, len = 2001)\n\nsecret_nums |&gt; \n  tail(n = 1) |&gt; \n  unlist() |&gt; \n  sum()\n\n[1] 20401393616",
    "crumbs": [
      "2024",
      "Day 22"
    ]
  },
  {
    "objectID": "2024/R/day22.html#part-2",
    "href": "2024/R/day22.html#part-2",
    "title": "Day 22",
    "section": "Part 2",
    "text": "Part 2\n\n# Convert sequences to a data frame by buyer and time\ndiffs &lt;- secret_nums |&gt; \n  imap_dfr(\\(x, idx) tibble(time = idx, secret_number = x)) |&gt; \n  mutate(\n    buyer_id = row_number(),\n    .by = time\n  ) |&gt; \n  mutate(\n    # Get the price at each time by taking the ones digit of each secret number\n    price = secret_number %% 10L,\n    # Compute the difference in price at the current time vs the previous time\n    diff = price - lag(price),\n    # Compute the sequence of 4 price changes preceeding the current price\n    lag1 = lag(diff, n = 1L),\n    lag2 = lag(diff, n = 2L),\n    lag3 = lag(diff, n = 3L),\n    diff_seq = str_c(lag3, lag2, lag1, diff, sep = \",\"),\n    .by = buyer_id\n  ) |&gt; \n  arrange(buyer_id, time)\n\n# For each price change seq, compute the bananas you will get from each buyer:\nbananas_by_seq &lt;- diffs |&gt; \n  filter(!is.na(diff_seq)) |&gt; \n  summarize(\n    bananas = head(price, 1),\n    .by = c(buyer_id, diff_seq)\n  )\n\n# Find the most advantageous sequence:\nbananas_by_seq |&gt; \n  summarize(bananas = sum(bananas), .by = diff_seq) |&gt; \n  slice_max(bananas) |&gt; \n  pull(bananas)\n\n[1] 2272",
    "crumbs": [
      "2024",
      "Day 22"
    ]
  },
  {
    "objectID": "2024/R/day20.html",
    "href": "2024/R/day20.html",
    "title": "Day 20",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_table(\"../input/day20.txt\", col_names = \"char\") |&gt; \n  mutate(\n    row = row_number(),\n    char = str_split(char, \"\")\n  ) |&gt; \n  unnest_longer(char, indices_to = \"col\")",
    "crumbs": [
      "2024",
      "Day 20"
    ]
  },
  {
    "objectID": "2024/R/day20.html#setup",
    "href": "2024/R/day20.html#setup",
    "title": "Day 20",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_table(\"../input/day20.txt\", col_names = \"char\") |&gt; \n  mutate(\n    row = row_number(),\n    char = str_split(char, \"\")\n  ) |&gt; \n  unnest_longer(char, indices_to = \"col\")",
    "crumbs": [
      "2024",
      "Day 20"
    ]
  },
  {
    "objectID": "2024/R/day20.html#part-1",
    "href": "2024/R/day20.html#part-1",
    "title": "Day 20",
    "section": "Part 1",
    "text": "Part 1\nExtract the sequence of tiles in the original path:\n\n# Compute coordinates of each tile and extract the path sequence, ignoring walls\ndf &lt;- input |&gt; \n  filter(row &gt; 1 & row &lt; max(row) & col &gt; 1 & col &lt; max(col)) |&gt; \n  mutate(\n    id = row_number(),\n    row = row - 1, \n    col = col - 1\n  ) |&gt; \n  filter(char %in% c(\"S\", \"E\", \".\")) |&gt; \n  arrange(col, row)\n\n# Re-number the tiles on the path by their ordering from start to finish\npath_seq &lt;- df |&gt; \n  filter(char == \"S\") |&gt; \n  pull(id)\n\nwhile (length(path_seq) &lt; nrow(df)) {\n  path_seq &lt;- c(\n    path_seq, \n    df |&gt; \n      filter(id == tail(path_seq, 1)) |&gt; \n      cross_join(df) |&gt; \n      filter(\n        (abs(col.x - col.y) == 1 & abs(row.x - row.y) == 0) |\n        (abs(col.x - col.y) == 0 & abs(row.x - row.y) == 1)\n      ) |&gt; \n      filter(!(id.y %in% path_seq)) |&gt; \n      pull(id.y)\n  )\n}\n\n# Attach path order onto the list of path tiles with their coordinates\ndf_path &lt;- left_join(\n  df, \n  enframe(path_seq, name = \"path_idx\", value = \"id\"), \n  join_by(id)\n) |&gt; \n  select(path_idx, row, col) |&gt; \n  arrange(path_idx)\n\nCount the total seconds saved when collision is disabled for n seconds. Possible cheat end locations, and the time it takes to arrive there, can be calculated using Manhattan distance.\n\nmanhattan_dist &lt;- function(a_row, a_col, b_row, b_col) {\n  abs(a_row - b_row) + abs(a_col - b_col)\n}\n\ncount_cheats &lt;- function(cheat_length) {\n\n  df_path |&gt; \n    # Find all possible time-saving cheats if collision is disabled for n secs\n    left_join(df_path, join_by(x$path_idx &lt; y$path_idx)) |&gt; \n    mutate(dist = manhattan_dist(row.x, col.x, row.y, col.y)) |&gt; \n    filter(dist &lt;= cheat_length) |&gt; \n    mutate(saved = path_idx.y - path_idx.x - dist) |&gt; \n    summarize(n = n(), .by = saved) |&gt; \n    arrange(saved) |&gt; \n    \n    # Count the total number of cheats that save at least 100 seconds\n    filter(saved &gt;= 100) |&gt; \n    pull(n) |&gt;\n    sum()\n  \n}\n\nRun on puzzle input:\n\ncount_cheats(2)\n\n[1] 1417",
    "crumbs": [
      "2024",
      "Day 20"
    ]
  },
  {
    "objectID": "2024/R/day20.html#part-2",
    "href": "2024/R/day20.html#part-2",
    "title": "Day 20",
    "section": "Part 2",
    "text": "Part 2\n\ncount_cheats(20)\n\n[1] 1014683",
    "crumbs": [
      "2024",
      "Day 20"
    ]
  },
  {
    "objectID": "2024/R/day09.html",
    "href": "2024/R/day09.html",
    "title": "Day 9",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day09.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split_1(\"\") |&gt; \n  as.integer()",
    "crumbs": [
      "2024",
      "Day 9"
    ]
  },
  {
    "objectID": "2024/R/day09.html#setup",
    "href": "2024/R/day09.html#setup",
    "title": "Day 9",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day09.txt\", skip_empty_rows = TRUE) |&gt; \n  str_split_1(\"\") |&gt; \n  as.integer()",
    "crumbs": [
      "2024",
      "Day 9"
    ]
  },
  {
    "objectID": "2024/R/day09.html#part-1",
    "href": "2024/R/day09.html#part-1",
    "title": "Day 9",
    "section": "Part 1",
    "text": "Part 1\nDefine custom file functions:\n\nmove_files &lt;- function(filesys) {\n  repeat {\n    first_blank &lt;- min(which(is.na(filesys)))\n    last_file   &lt;- max(which(!is.na(filesys)))\n    \n    # If all files have been compressed, exit\n    if (first_blank &gt; last_file) break\n    \n    # Otherwise, move the last file into the first blank location\n    filesys[first_blank] &lt;- filesys[last_file]\n    filesys[last_file]   &lt;- NA_integer_\n  }\n  filesys\n}\n\nchecksum &lt;- function(filesys) {\n  filesys |&gt; \n    imap_int(\\(x, idx) if_else(is.na(x), 0, x * (idx - 1))) |&gt; \n    sum() |&gt; \n    format(scientific = FALSE)\n}\n\nRun puzzle input:\n\n# Uncompress file layout\nfilesys &lt;- input|&gt; \n  imap(function(x, idx) {\n    # Even entries are files; odd entries are spaces\n    file_id &lt;- if_else(idx %% 2 == 1, floor(idx / 2), NA_integer_)\n    rep(file_id, x)\n  }) |&gt; \n  unlist()\n\nfilesys |&gt; \n  move_files() |&gt; \n  checksum()\n\n[1] \"6330095022244\"",
    "crumbs": [
      "2024",
      "Day 9"
    ]
  },
  {
    "objectID": "2024/R/day09.html#part-2",
    "href": "2024/R/day09.html#part-2",
    "title": "Day 9",
    "section": "Part 2",
    "text": "Part 2\nUpdate the compression function:\n\nmove_blocks &lt;- function(filesys) {\n  for (file_id in max(na.omit(filesys)):1) {\n    \n    # Pull the location and length of the file block for the current ID\n    file_block &lt;- which(filesys == file_id)\n    n &lt;- length(file_block)\n    \n    # Pull indices of all empty values before the current file block\n    empty_idx &lt;- which(is.na(filesys[1:min(file_block)]))\n    \n    # Pull all valid starting indices of empty blocks of the right length\n    if (n == 1) {\n      valid_idx &lt;- empty_idx\n    } else {\n      valid_block &lt;- replace_na(lead(empty_idx, n - 1) - empty_idx == n - 1, FALSE)\n      valid_idx &lt;- empty_idx[valid_block]\n    }\n    \n    # If valid indices exist, move the file block to the first valid location\n    if (length(valid_idx) &gt; 0) {\n      idx_start &lt;- min(valid_idx)\n      filesys[idx_start:(idx_start + n - 1)] &lt;- file_id\n      filesys[file_block] &lt;- NA_integer_\n    }\n    \n  }\n  filesys\n}\n\nRun puzzle input:\n\nfilesys |&gt; \n  move_blocks() |&gt; \n  checksum()\n\n[1] \"6359491814941\"",
    "crumbs": [
      "2024",
      "Day 9"
    ]
  },
  {
    "objectID": "2023/R/day04.html",
    "href": "2023/R/day04.html",
    "title": "Day 4",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day04.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 4"
    ]
  },
  {
    "objectID": "2023/R/day04.html#setup",
    "href": "2023/R/day04.html#setup",
    "title": "Day 4",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day04.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 4"
    ]
  },
  {
    "objectID": "2023/R/day04.html#part-1",
    "href": "2023/R/day04.html#part-1",
    "title": "Day 4",
    "section": "Part 1",
    "text": "Part 1\nReformat input into lists of winning numbers vs chosen numbers for each card, then score each card:\n\ncards &lt;- input |&gt; \n  \n  # Reformat as a data frame of winning vs chosen numbers per card\n  str_remove(\"Card .*:\") |&gt; \n  enframe(name = \"card_id\", value = \"txt\") |&gt; \n  separate(txt, into = c(\"winning\", \"chosen\"), sep = \"\\\\|\") |&gt; \n  mutate(across(c(winning, chosen), \\(vec) {\n    vec |&gt; \n      trimws() |&gt; \n      str_split(\"\\\\s+\") |&gt; \n      map(parse_number)\n  })) |&gt; \n  \n  # Count the number of overlapping chosen & winning numbers per card:\n  mutate(\n    n_common = map2_int(winning, chosen, ~ length(intersect(.x, .y))),\n    score = if_else(n_common == 0, 0, 2^(n_common - 1))\n  )\n\nSum all cards’ scores:\n\nsum(cards$score)\n\n[1] 24542",
    "crumbs": [
      "2023",
      "Day 4"
    ]
  },
  {
    "objectID": "2023/R/day04.html#part-2",
    "href": "2023/R/day04.html#part-2",
    "title": "Day 4",
    "section": "Part 2",
    "text": "Part 2\nCreate a reference table of the outputs received for each winning card:\n\nrewards &lt;- cards |&gt; \n  mutate(\n    reward_start = card_id + 1,\n    reward_end = pmin(card_id + n_common, max(card_id)),\n    reward = pmap(list(reward_start, reward_end, n_common), \\(start, end, n) {\n      if (n == 0) \n        rep(0, nrow(cards))\n      else \n        rep(0, nrow(cards)) |&gt; \n        modify_at(.at = seq(start, end), ~1)\n    })\n  ) |&gt; \n  pull(reward)\n\nLoop through each card in the inventory, accumulate rewards at each step, then sum the final total number of cards:\n\ncollect_reward &lt;- \\(inventory, i) inventory + inventory[[i]] * rewards[[i]]\n\nreduce(1:nrow(cards), collect_reward, .init = rep(1, nrow(cards))) |&gt; \n  sum()\n\n[1] 8736438",
    "crumbs": [
      "2023",
      "Day 4"
    ]
  },
  {
    "objectID": "2023/R/day11.html",
    "href": "2023/R/day11.html",
    "title": "Day 11",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day11.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 11"
    ]
  },
  {
    "objectID": "2023/R/day11.html#setup",
    "href": "2023/R/day11.html#setup",
    "title": "Day 11",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day11.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 11"
    ]
  },
  {
    "objectID": "2023/R/day11.html#part-1",
    "href": "2023/R/day11.html#part-1",
    "title": "Day 11",
    "section": "Part 1",
    "text": "Part 1\nConvert text input to a matrix:\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  map(partial(matrix, nrow = 1)) |&gt; \n  reduce(rbind)\n\nDetermine the initial indices of each galaxy:\n\ngalaxies &lt;- which(mtx == '#', arr.ind = TRUE) |&gt; \n  as_tibble() |&gt; \n  mutate(id = row_number(), .before = everything())\n\nGet the indices of the rows and columns that contain only empty space:\n\nempty_rows &lt;- split(mtx, row(mtx))  |&gt; \n  map_lgl(~ all(.x == '.')) |&gt; \n  which() |&gt; \n  unname()\n\nempty_cols &lt;- split(mtx, col(mtx))  |&gt; \n  map_lgl(~ all(.x == '.')) |&gt; \n  which() |&gt; \n  unname()\n\nAdjust the coordinates of the galaxies by doubling the empty rows and columns:\n\ngalaxies &lt;- galaxies |&gt; \n  mutate(\n    empty_pre_rows = map_int(row, ~ sum(empty_rows &lt; .x)),\n    empty_pre_cols = map_int(col, ~ sum(empty_cols &lt; .x))\n  )\n\nDefine a function that adjusts the coordinates of each galaxy by expanding all empty rows and columns by n, computes the manhattan distance between each resulting pair of galaxies, and sums the result:\n\nexpanded_galaxy_dist &lt;- function(n) {\n  \n  new_galaxies &lt;- galaxies |&gt; \n    mutate(\n      new_row = row + empty_pre_rows * (n - 1),\n      new_col = col + empty_pre_cols * (n - 1)\n    )\n  \n  left_join(\n    select(new_galaxies, id, row = new_row, col = new_col),\n    select(new_galaxies, id, row = new_row, col = new_col),\n    join_by(x$id &lt; y$id)\n  ) |&gt; \n    mutate(dist = abs(row.x - row.y) + abs(col.x - col.y)) |&gt; \n    pull(dist) |&gt; \n    sum(na.rm = TRUE)\n  \n}\n\nRun on puzzle input:\n\nexpanded_galaxy_dist(2)\n\n[1] 9608724",
    "crumbs": [
      "2023",
      "Day 11"
    ]
  },
  {
    "objectID": "2023/R/day11.html#part-2",
    "href": "2023/R/day11.html#part-2",
    "title": "Day 11",
    "section": "Part 2",
    "text": "Part 2\n\nexpanded_galaxy_dist(1000000)\n\n[1] 904633799472",
    "crumbs": [
      "2023",
      "Day 11"
    ]
  },
  {
    "objectID": "2023/R/day13.html",
    "href": "2023/R/day13.html",
    "title": "Day 13",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day13.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 13"
    ]
  },
  {
    "objectID": "2023/R/day13.html#setup",
    "href": "2023/R/day13.html#setup",
    "title": "Day 13",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day13.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 13"
    ]
  },
  {
    "objectID": "2023/R/day13.html#part-1",
    "href": "2023/R/day13.html#part-1",
    "title": "Day 13",
    "section": "Part 1",
    "text": "Part 1\nConvert each set of input strings into its own matrix:\n\nmtx &lt;- tibble(chr = input) |&gt; \n  group_split(cumsum(chr == \"\")) |&gt; \n  map(~ pull(.x, chr)) |&gt; \n  map(\n    ~ str_split(.x, \"\") |&gt; \n      unlist() |&gt; \n      matrix(nrow = sum(.x != \"\"), byrow = TRUE)\n  )\n\nDefine a function that checks for a mirror along the given dimension (rows vs columns) of a given matrix:\n\nmirror_idx &lt;- function(mtx, dim = c(\"row\", \"col\")) {\n  vecs &lt;- split(mtx, get(case_match(dim, \"row\" ~ \"col\", \"col\" ~ \"row\"))(mtx))\n  len  &lt;- get(str_c(\"n\", dim))(mtx)\n  \n  refl_idx &lt;- c(0)\n  \n  for (idx in 1:(len - 1)) {\n    n_trim &lt;- min(idx, len - idx)\n    \n    is_mirror &lt;- vecs |&gt; \n      map_lgl(\\(vec) {\n        h1 &lt;- rev(vec[1:idx])[1:n_trim]\n        h2 &lt;- vec[(idx + 1):(idx + n_trim)]\n        all(h1 == h2)\n      }) |&gt; \n      all()\n    \n    if (is_mirror) \n      refl_idx &lt;- c(refl_idx, idx)\n  }\n  \n  refl_idx\n}\n\nFor each matrix in the list, add the column indices of each vertical reflection line with 100 times the row indices of each horizontal reflection line:\n\nscore_matrices &lt;- function(mtx_list) {\n  mtx_list |&gt; \n    map_dbl(~ sum(mirror_idx(.x, \"col\")) + sum(mirror_idx(.x, \"row\") * 100)) |&gt; \n    sum()\n}\n\nscore_matrices(mtx)\n\n[1] 30575",
    "crumbs": [
      "2023",
      "Day 13"
    ]
  },
  {
    "objectID": "2023/R/day13.html#part-2",
    "href": "2023/R/day13.html#part-2",
    "title": "Day 13",
    "section": "Part 2",
    "text": "Part 2\nDefine a function that finds the row or column index of the single smudge for a given matrix:\n\nsmudge_idx &lt;- function(mtx, dim = c(\"row\", \"col\")) {\n  \n  vecs &lt;- split(mtx, get(case_match(dim, \"row\" ~ \"col\", \"col\" ~ \"row\"))(mtx))\n  len  &lt;- get(str_c(\"n\", dim))(mtx)\n  \n  for (idx in 1:(len - 1)) {\n    n_trim &lt;- min(idx, len - idx)\n    \n    noteq &lt;- vecs |&gt; \n      map(\\(vec) {\n        h1 &lt;- rev(vec[1:idx])[1:n_trim]\n        h2 &lt;- vec[(idx + 1):(idx + n_trim)]\n        which(h1 != h2)\n      })\n    \n    if (length(unlist(noteq)) == 1) return(idx)\n  }\n  return(0)\n}\n\nRe-score the input:\n\nscore_unsmudged &lt;- function(mtx_list) {\n  mtx_list |&gt; \n    map_dbl(~ sum(smudge_idx(.x, \"col\")) + sum(smudge_idx(.x, \"row\") * 100)) |&gt; \n    sum()\n}\n\nscore_unsmudged(mtx)\n\n[1] 37478",
    "crumbs": [
      "2023",
      "Day 13"
    ]
  },
  {
    "objectID": "2023/R/day06.html",
    "href": "2023/R/day06.html",
    "title": "Day 6",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day06.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 6"
    ]
  },
  {
    "objectID": "2023/R/day06.html#setup",
    "href": "2023/R/day06.html#setup",
    "title": "Day 6",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day06.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 6"
    ]
  },
  {
    "objectID": "2023/R/day06.html#part-1",
    "href": "2023/R/day06.html#part-1",
    "title": "Day 6",
    "section": "Part 1",
    "text": "Part 1\nConvert input text into a set of time/distance vectors for each race:\n\nraces &lt;- c(\"time\" = 1, \"distance\" = 2) |&gt; \n  imap(\\(i, name) {\n    input[[i]] |&gt;\n      str_remove(regex(str_c(name, \":\\\\s+\"), ignore_case = T)) |&gt;\n      str_split_1(\"\\\\s+\") |&gt;\n      as.numeric()\n  }) |&gt; \n  pmap(\\(time, distance) list(time = time, record = distance))\n\nDefine a function to compute your traveled distance in each race, given the amount of time you hold the button:\n\nrace_dist &lt;- function(time_race, time_hold) {\n  (time_race - time_hold) * time_hold\n}\n\nFor each race, count the number of record-beating ways to win:\n\nraces |&gt; \n  map_int(\\(race) sum(race_dist(race$time, 0:race$time) &gt; race$record)) |&gt; \n  prod()\n\n[1] 32076",
    "crumbs": [
      "2023",
      "Day 6"
    ]
  },
  {
    "objectID": "2023/R/day06.html#part-2",
    "href": "2023/R/day06.html#part-2",
    "title": "Day 6",
    "section": "Part 2",
    "text": "Part 2\nCombine the individual race numbers into one single race:\n\nrace &lt;- races |&gt; \n  enframe(name = \"pos\") |&gt; \n  unnest_wider(value) |&gt; \n  summarize(across(c(time, record), ~ as.numeric(str_c(.x, collapse = \"\")))) |&gt; \n  pivot_longer(everything()) |&gt; \n  deframe() |&gt; \n  as.list()\n\nCompute roots of the race distance function using the quadratic equation to determine the range of record-winning hold times:\n\nwinning_methods &lt;- function(time_race, record) {\n  root1 &lt;- (time_race + sqrt(time_race^2 - 4 * record)) / 2\n  root2 &lt;- (time_race - sqrt(time_race^2 - 4 * record)) / 2\n  \n  bnd_l &lt;- ceiling(max(min(root1, root2), 0))\n  bnd_r &lt;- floor(min(max(root1, root2), time_race))\n  \n  bnd_l &lt;- if_else(race_dist(time_race, bnd_l) == record, bnd_l + 1, bnd_l)\n  bnd_r &lt;- if_else(race_dist(time_race, bnd_r) == record, bnd_r - 1, bnd_r)\n  \n  bnd_r - bnd_l + 1\n}\n\nRun on puzzle input:\n\nwinning_methods(race$time, race$record)\n\n[1] 34278221",
    "crumbs": [
      "2023",
      "Day 6"
    ]
  },
  {
    "objectID": "2023/R/day16.html",
    "href": "2023/R/day16.html",
    "title": "Day 16",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 16"
    ]
  },
  {
    "objectID": "2023/R/day16.html#setup",
    "href": "2023/R/day16.html#setup",
    "title": "Day 16",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day16.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 16"
    ]
  },
  {
    "objectID": "2023/R/day16.html#part-1",
    "href": "2023/R/day16.html#part-1",
    "title": "Day 16",
    "section": "Part 1",
    "text": "Part 1\nConvert text input to a character matrix:\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  map(~ matrix(.x, nrow = 1)) |&gt; \n  reduce(rbind)\n\nDefine a function that converts a direction, direction index, and sublocation along that direction into standard row/column form, then into a single ID value:\n\nmtx_id &lt;- function(dir, vec_idx, loc_idx) {\n  row &lt;- case_match(dir, c('W', 'E') ~ vec_idx, c('N', 'S') ~ loc_idx)\n  col &lt;- case_match(dir, c('W', 'E') ~ loc_idx, c('N', 'S') ~ vec_idx)\n  \n  (row - 1) * ncol(mtx) + col\n}\n\nDefine a function that tracks the beam through the matrix and returns the IDs of the elements visited:\n\nbeam &lt;- function(dir, vec_idx = 1, start_idx, visited) {\n  \n  if (!between(start_idx, 1, nrow(mtx))) return(visited)\n  \n  # Initialize\n  vec &lt;- if (dir %in% c('W', 'E')) mtx[vec_idx,] else mtx[,vec_idx]\n\n  end_idx      &lt;- case_match(dir, c('E', 'S') ~ length(vec), c('N', 'W') ~ 1)\n  chr_split    &lt;- case_match(dir, c('W', 'E') ~ '|',         c('N', 'S') ~ '-')\n  chr_turn_neg &lt;- case_match(dir, c('N', 'W') ~ '\\\\',        c('S', 'E') ~ '/')\n  chr_turn_pos &lt;- case_match(dir, c('N', 'W') ~ '/',         c('S', 'E') ~ '\\\\')\n  dir_split_1  &lt;- case_match(dir, c('W', 'E') ~ 'N',         c('N', 'S') ~ 'W')\n  dir_split_2  &lt;- case_match(dir, c('W', 'E') ~ 'S',         c('N', 'S') ~ 'E')\n  dir_turn_neg &lt;- case_match(dir, c('N', 'S') ~ 'W',         c('W', 'E') ~ 'N')\n  dir_turn_pos &lt;- case_match(dir, c('N', 'S') ~ 'E',         c('W', 'E') ~ 'S')\n  \n  for (i in start_idx:end_idx) {\n    \n    id &lt;- mtx_id(dir, vec_idx, i)\n    \n    if (id %in% visited[[dir]])\n      return(visited)\n    else\n      visited[[dir]] &lt;- c(visited[[dir]], id)\n    \n    if (vec[[i]] == chr_split) {\n      visited &lt;- beam(dir_split_1, i, vec_idx - 1, visited)\n      visited &lt;- beam(dir_split_2, i, vec_idx + 1, visited)\n      break\n    }\n    else if (vec[[i]] == chr_turn_neg) {\n      visited &lt;- beam(dir_turn_neg, i, vec_idx - 1, visited)\n      break\n    }\n    else if (vec[[i]] == chr_turn_pos) {\n      visited &lt;- beam(dir_turn_pos, i, vec_idx + 1, visited)\n      break\n    }\n  }\n  \n  visited\n}\n\nStarting from upper left, loop through the matrix and count the number of energized tiles:\n\ninit_visited &lt;- map(set_names(c(\"N\", \"S\", \"W\", \"E\")), ~ c())\n\nbeam(\"E\", vec_idx = 1, start_idx = 1, visited = init_visited) |&gt; \n  unlist() |&gt; \n  unique() |&gt; \n  length()\n\n[1] 7046",
    "crumbs": [
      "2023",
      "Day 16"
    ]
  },
  {
    "objectID": "2023/R/day16.html#part-2",
    "href": "2023/R/day16.html#part-2",
    "title": "Day 16",
    "section": "Part 2",
    "text": "Part 2\nIf the beam can enter from any edge, find the maximum number of energizable tiles:\n\nenergize_from &lt;- function(dir, vec_idx, start_idx) {\n  beam(dir, vec_idx, start_idx, init_visited) |&gt; \n    unlist() |&gt; \n    unique() |&gt; \n    length()\n}\n\nexpand_grid(dir = c('N', 'S', 'W', 'E'), vec = 1:nrow(mtx)) |&gt; \n  mutate(start = case_match(dir, c('S', 'E') ~ 1, c('N', 'W') ~ nrow(mtx))) |&gt; \n  pmap_dbl(\\(dir, vec, start) energize_from(dir, vec, start)) |&gt; \n  max()\n\n[1] 7313",
    "crumbs": [
      "2023",
      "Day 16"
    ]
  },
  {
    "objectID": "2023/R/day03.html",
    "href": "2023/R/day03.html",
    "title": "Day 3",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day03.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 3"
    ]
  },
  {
    "objectID": "2023/R/day03.html#setup",
    "href": "2023/R/day03.html#setup",
    "title": "Day 3",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day03.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 3"
    ]
  },
  {
    "objectID": "2023/R/day03.html#part-1",
    "href": "2023/R/day03.html#part-1",
    "title": "Day 3",
    "section": "Part 1",
    "text": "Part 1\nConvert the input strings into a character matrix for ease of indexing:\n\nmtx &lt;- input |&gt; \n  str_split(\"\") |&gt; \n  unlist() |&gt; \n  matrix(nrow = length(input), byrow = TRUE)\n\nmax_row &lt;- nrow(mtx)\nmax_col &lt;- ncol(mtx)\n\nIdentify all candidates for part numbers and their coordinates in the matrix representation of the input:\n\n# Pull all candidates from the text input\nparts &lt;- input |&gt; \n  str_extract_all(\"\\\\d+\") |&gt; \n  map(unique)\n\n# Compute the indices of each candidate within each input string\nparts_locations &lt;- map2(input, parts, \\(chr_row, row_parts) {\n  chr_row |&gt; \n    str_locate_all(str_c(\"\\\\b\", row_parts, \"\\\\b\")) |&gt;\n    map(partial(asplit, MARGIN = 1))\n})\n\nIdentify all neighbors of each part number candidate:\n\nparts_df &lt;- parts_locations |&gt; \n  \n  # Combine all candidates and their indices into a data frame of coordiantes\n  enframe(name = \"row\") |&gt; \n  unnest_longer(value, values_to = \"locations\", indices_to = \"part_id\") |&gt; \n  unnest_longer(locations, values_to = \"col_seq\", indices_to = \"loc_id\") |&gt; \n  mutate(col_seq = map(col_seq, partial(full_seq, period = 1))) |&gt; \n  left_join(\n    parts |&gt; \n      enframe(name = \"row\") |&gt; \n      unnest_longer(\n        value, \n        values_to = \"part_int\", \n        indices_to = \"part_id\", \n        transform = as.integer\n      ),\n    join_by(row, part_id)\n  ) |&gt; \n  mutate(part_id = cur_group_id(), .by = c(row, part_id, loc_id)) |&gt; \n  \n  # Pull the neighboring characters for every part in the input\n  mutate(\n    search_rows = map(row, \\(row) {\n      c(row - 1, row, row + 1) |&gt; \n        keep(partial(between, left = 1, right = max_row))\n    }),\n    search_cols = map(col_seq, \\(col_seq) {\n      c(min(col_seq) - 1, col_seq, max(col_seq) + 1) |&gt; \n        keep(partial(between, left = 1, right = max_row))\n    }),\n    neighbor = map2(search_rows, search_cols, \\(rows, cols) {\n      expand_grid(row = rows, col = cols) |&gt; \n        mutate(chr = map2_chr(row, col, \\(row, col) mtx[row, col]))\n    })\n  ) |&gt; \n  unnest(neighbor, names_sep = \"_\") |&gt; \n  \n  # Simplify into a list of part IDs, integer values, and neighboring chars\n  select(row, part_id, part_int, starts_with(\"neighbor\")) |&gt; \n  mutate(\n    neighbor_id = cur_group_id(), \n    .by = c(neighbor_row, neighbor_col),\n    .before = neighbor_chr\n  )\n\nPull all candidates that are true part numbers (have a neighboring symbol) and sum their values:\n\nparts_df |&gt; \n  filter(!str_detect(neighbor_chr, \"[0-9.]\")) |&gt; \n  distinct(part_id, part_int) |&gt; \n  pull(part_int) |&gt; \n  sum()\n\n[1] 522726",
    "crumbs": [
      "2023",
      "Day 3"
    ]
  },
  {
    "objectID": "2023/R/day03.html#part-2",
    "href": "2023/R/day03.html#part-2",
    "title": "Day 3",
    "section": "Part 2",
    "text": "Part 2\nPull symbols with exactly two adjacent parts, multiply the part integers to get each gear ratio, and sum the total of the gear ratios:\n\nparts_df |&gt; \n  filter(!str_detect(neighbor_chr, \"[0-9.]\")) |&gt; \n  filter(n() == 2, .by = neighbor_id) |&gt; \n  summarize(gear_ratio = prod(part_int), .by = neighbor_id) |&gt; \n  pull(gear_ratio) |&gt; \n  sum()\n\n[1] 81721933",
    "crumbs": [
      "2023",
      "Day 3"
    ]
  },
  {
    "objectID": "2023/R/day01.html",
    "href": "2023/R/day01.html",
    "title": "Day 1",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day01.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 1"
    ]
  },
  {
    "objectID": "2023/R/day01.html#setup",
    "href": "2023/R/day01.html#setup",
    "title": "Day 1",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day01.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 1"
    ]
  },
  {
    "objectID": "2023/R/day01.html#part-1",
    "href": "2023/R/day01.html#part-1",
    "title": "Day 1",
    "section": "Part 1",
    "text": "Part 1\nExtract numbers from the text strings using regex and sum:\n\ninput |&gt; \n  str_extract_all(\"\\\\d\") |&gt; \n  map(as.integer) |&gt; \n  map_int(~ head(.x, 1) * 10 + tail(.x, 1)) |&gt; \n  sum()\n\n[1] 54390",
    "crumbs": [
      "2023",
      "Day 1"
    ]
  },
  {
    "objectID": "2023/R/day01.html#part-2",
    "href": "2023/R/day01.html#part-2",
    "title": "Day 1",
    "section": "Part 2",
    "text": "Part 2\nAdd patterns to the regex for spelled-out digits. Search from the front of the string as usual, but for the last digit, search from the end by reversing all strings. Otherwise, regex will only recognize the first match in case of an overlap: “eightwo” needs to be recognized as 82, not just 8.\n\ndigits &lt;- c(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\npattern_fwd &lt;- str_c(c(\"\\\\d\", digits), collapse = \"|\")\npattern_bwd &lt;- str_c(c(\"\\\\d\", stringi::stri_reverse(digits)), collapse = \"|\")\n\n# Match the first digit from the front of the string\nd1 &lt;- input |&gt; \n  str_extract(pattern_fwd)\n\n# Match the second digit from the end of the string\nd2 &lt;- input |&gt; \n  stringi::stri_reverse() |&gt; \n  str_extract(pattern_bwd) |&gt; \n  stringi::stri_reverse()\n\n# Convert to integer values and sum\nmap2(d1, d2, c) |&gt; \n  map(~ coalesce(parse_number(.x, na = digits), match(.x, digits))) |&gt; \n  map_int(~ head(.x, 1) * 10 + tail(.x, 1)) |&gt; \n  sum()\n\n[1] 54277",
    "crumbs": [
      "2023",
      "Day 1"
    ]
  },
  {
    "objectID": "2023/R/day19.html",
    "href": "2023/R/day19.html",
    "title": "Day 19",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sets)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day19.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 19"
    ]
  },
  {
    "objectID": "2023/R/day19.html#setup",
    "href": "2023/R/day19.html#setup",
    "title": "Day 19",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\nlibrary(sets)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day19.txt\", skip_empty_rows = FALSE)",
    "crumbs": [
      "2023",
      "Day 19"
    ]
  },
  {
    "objectID": "2023/R/day19.html#part-1",
    "href": "2023/R/day19.html#part-1",
    "title": "Day 19",
    "section": "Part 1",
    "text": "Part 1\nSeparate the input into rules and parts:\n\nparts &lt;- input |&gt; \n  keep(~ str_starts(.x, \"\\\\{\")) |&gt; \n  unglue_data(\n    \"{x=[x],m=[m],a=[a],s=[s]}\", \n    open = \"[\", \n    close = \"]\", \n    convert = TRUE\n  ) |&gt; \n  pmap(\\(x, m, a, s) lst(x, m, a, s))\n\nrules &lt;- input |&gt; \n  keep(~ str_starts(.x, \"\\\\w\")) |&gt; \n  unglue_data(\"[name]{[rules]}\", open = \"[\", close = \"]\") |&gt; \n  mutate(rules = str_split(rules, \",\")) |&gt; \n  unnest_longer(rules, values_to = \"condition\", indices_to = \"cond_num\") |&gt; \n  unglue_unnest(\n    condition, \n    c(\"{var}{eq=[&lt;&gt;]}{val}:{goto}\", \"{goto}\"), \n    convert = TRUE\n  ) |&gt; \n  mutate(value = pmap(\n    lst(var, eq, val, goto), \n    ~ lst(var = ..1, eq = ..2, val = ..3, goto = ..4)\n  )) |&gt; \n  summarize(value = list(value), .by = name) |&gt; \n  deframe()\n\nDefine a function that rates a part according to the rule list for each workflow:\n\nrate &lt;- function(part, workflow = \"in\") {\n  if (workflow %in% c('A', 'R')) \n    return(workflow == 'A')\n  \n  workflow &lt;- rules[[workflow]]\n  \n  for (rule in workflow) {\n    if (is.na(rule$var))\n      return(rate(part, rule$goto))\n    if (get(rule$eq)(part[[rule$var]], rule$val))\n      return(rate(part, rule$goto))\n  }\n}\n\nRate the list of parts, then for the accepted parts, add all ratings:\n\nkeep(parts, map_lgl(parts, rate)) |&gt; \n  unlist() |&gt; \n  sum()\n\n[1] 397643",
    "crumbs": [
      "2023",
      "Day 19"
    ]
  },
  {
    "objectID": "2023/R/day19.html#part-2",
    "href": "2023/R/day19.html#part-2",
    "title": "Day 19",
    "section": "Part 2",
    "text": "Part 2\nDefine a function to cut the valid set of inputs into a set of intervals. Looping through our rules, trim down the intervals for x, m, a, and s until we have the final set of valid inputs:\n\nkeys  &lt;- set_names(c(\"x\", \"m\", \"a\", \"s\"))\nempty &lt;- map(keys, ~ interval(domain = 'Z'))\ninit  &lt;- map(keys, ~ interval(l = 1, r = 4000, domain = 'Z'))\n\nrate_range &lt;- function(cur_range, workflow = \"in\") {\n  \n  if (workflow == 'A') \n    return(list(cur_range))\n  if (workflow == 'R')\n    return(list())\n  \n  workflow &lt;- rules[[workflow]]\n  accepted &lt;- list()\n\n  for (rule in workflow) {\n    if (is.na(rule$var)) {\n      accepted &lt;- c(accepted, rate_range(cur_range, rule$goto))\n      return(accepted)\n    }\n\n    rule_range &lt;- sets::interval(\n      l = case_match(rule$eq, '&lt;' ~ 1,            '&gt;' ~ rule$val + 1),\n      r = case_match(rule$eq, '&lt;' ~ rule$val - 1, '&gt;' ~ 4000),\n      domain = 'Z'\n    )\n\n    rule_pass &lt;- cur_range |&gt;\n      modify_at(rule$var, ~ interval_intersection(.x, rule_range))\n    rule_fail &lt;- cur_range |&gt;\n      modify_at(rule$var, ~ interval_complement(rule_range, .x))\n\n    accepted &lt;- c(accepted, rate_range(rule_pass, rule$goto))\n    cur_range &lt;- rule_fail\n  }\n}\n\nRun and compute the number of total valid combinations:\n\nrate_range(init) |&gt; \n  map(\\(intrvl) map_dbl(intrvl, ~ length(as.set(.x)))) |&gt; \n  map_dbl(prod) |&gt;\n  sum() |&gt; \n  format(scientific = FALSE)\n\n[1] \"132392981697081\"",
    "crumbs": [
      "2023",
      "Day 19"
    ]
  },
  {
    "objectID": "2023/R/day08.html",
    "href": "2023/R/day08.html",
    "title": "Day 8",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day08.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 8"
    ]
  },
  {
    "objectID": "2023/R/day08.html#setup",
    "href": "2023/R/day08.html#setup",
    "title": "Day 8",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\nlibrary(unglue)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day08.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 8"
    ]
  },
  {
    "objectID": "2023/R/day08.html#part-1",
    "href": "2023/R/day08.html#part-1",
    "title": "Day 8",
    "section": "Part 1",
    "text": "Part 1\nParse input text into sets of left/right instructions and the maps of the node network:\n\ninstructions &lt;- input |&gt; \n  head(1) |&gt; \n  str_split_1(\"\")\n\nnetwork &lt;- input |&gt; \n  tail(-1) |&gt; \n  unglue_data(\"{node} = ({L}, {R})\") |&gt; \n  nest(LR = c(L, R)) |&gt; \n  mutate(LR = map(LR, as.list)) |&gt; \n  deframe()\n\nStarting at the AAA node, advance through the list of instructions until the ZZZ node is reached:\n\n# Initialize\nn_rep    &lt;- length(instructions)\ncur_node &lt;- \"AAA\"\ni        &lt;- 0\n\nrepeat {\n  if (cur_node == \"ZZZ\") break\n  \n  cur_dir  &lt;- instructions[i %% n_rep + 1]\n  cur_node &lt;- network[[cur_node]][[cur_dir]]\n  i &lt;- i + 1\n}\n\ni\n\n[1] 19631",
    "crumbs": [
      "2023",
      "Day 8"
    ]
  },
  {
    "objectID": "2023/R/day08.html#part-2",
    "href": "2023/R/day08.html#part-2",
    "title": "Day 8",
    "section": "Part 2",
    "text": "Part 2\nFor each node ending with ‘A’, compute the number of necessary steps until it reaches a node ending with ‘Z’ and loops.\n\nsteps_to_z &lt;- function(node_start) {\n\n  # Initialize\n  cur_node &lt;- node_start\n  i        &lt;- 0\n  \n  repeat {\n    if (str_ends(cur_node, \"Z\")) return(i)\n    \n    cur_dir  &lt;- instructions[i %% n_rep + 1]\n    cur_node &lt;- network[[cur_node]][[cur_dir]]\n    i &lt;- i + 1\n  }\n}\n\ncycles &lt;- names(network) |&gt; \n  keep(~ str_ends(.x, \"A\")) |&gt; \n  map_dbl(steps_to_z)\n\nTake the least common multiple of the result:\n\nreduce(cycles, numbers::LCM) |&gt; \n  format(scientific = FALSE)\n\n[1] \"21003205388413\"",
    "crumbs": [
      "2023",
      "Day 8"
    ]
  },
  {
    "objectID": "2023/R/day09.html",
    "href": "2023/R/day09.html",
    "title": "Day 9",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day09.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 9"
    ]
  },
  {
    "objectID": "2023/R/day09.html#setup",
    "href": "2023/R/day09.html#setup",
    "title": "Day 9",
    "section": "",
    "text": "# Libraries\nlibrary(tidyverse)\n\n# Read input from file\ninput &lt;- read_lines(\"../input/day09.txt\", skip_empty_rows = TRUE)",
    "crumbs": [
      "2023",
      "Day 9"
    ]
  },
  {
    "objectID": "2023/R/day09.html#part-1",
    "href": "2023/R/day09.html#part-1",
    "title": "Day 9",
    "section": "Part 1",
    "text": "Part 1\nConvert text input into a series of numeric sequences:\n\nseqs &lt;- input |&gt; \n  str_split(\"\\\\s+\") |&gt; \n  map(as.numeric)\n\nDefine a function to get the next value in a sequence:\n\nextrapolate_next &lt;- function(x) {\n  if (all(x == 0))\n    return(0)\n  else\n    return(tail(x, 1) + extrapolate_next(diff(x)))\n}\n\nCompute next value of every sequence in the input, then sum the result:\n\nseqs |&gt; \n  map_dbl(extrapolate_next) |&gt; \n  sum()\n\n[1] 1641934234",
    "crumbs": [
      "2023",
      "Day 9"
    ]
  },
  {
    "objectID": "2023/R/day09.html#part-2",
    "href": "2023/R/day09.html#part-2",
    "title": "Day 9",
    "section": "Part 2",
    "text": "Part 2\nModify the function to get the preceeding sequence value, rather than the next:\n\nextrapolate_prev &lt;- function(x) {\n  if (all(x == 0))\n    return(0)\n  else\n    return(head(x, 1) - extrapolate_prev(diff(x)))\n}\n\nRun on puzzle input:\n\nseqs |&gt; \n  map_dbl(extrapolate_prev) |&gt; \n  sum()\n\n[1] 975",
    "crumbs": [
      "2023",
      "Day 9"
    ]
  }
]